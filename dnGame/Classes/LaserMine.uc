/*******************************************************************************
 * LaserMine generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class LaserMine extends dnProjectile
    collapsecategories
    dependson(LaserMineBeam);

var() noexport bool bArmImmediately "When set, the mine will start arming the moment it is spawned into the world.";
var() noexport bool bNoArmSound "Don't make noise while arming, use for preplaced mines.";
var() noexport bool bNoAmbience "Disable the trip mine's ambient noise completely.";
var() noexport bool bDisableOnStartup "Should the beam start disabled?";
var() noexport bool bDisableTraceOnStartup "Should the beam disable tracing on startup.";
var() noexport bool bOnlyTracePawns "Should the beam only trace against pawns?";
var() noexport float ArmingTime "Time in seconds to arm the laser";
var() noexport float AutoDetonateTime "When a mine is placed and told to detonate automatically (placed in an area it can't make a beam or placed on a bad guy), how long before going off.";
var() noexport float BlastDistance "Distance the damage comes out of the mine";
var() noexport float BlastAngleLimit "Max angle of the damage from the mine";
var() noexport float BeamDistance "How far out a beam should go to try and find a suitable target to attach to. If it doesn't find one, it will auto-detonate.";
var SSoundInfo ArmedSound;
var SSoundInfo ArmingCharge;
var Sound AmbientHum;
var() noexport Color ShieldedLaserColor "Color of the laser when the mine is shielded.";
var() noexport Color NormalLaserColor "Color of the laser when the mine is no longer shielded.";
var() noexport name ToggleBeamTag "Trigger this event to enable/disable the beam.";
var() noexport name ToggleBeamTracingTag "Trigger this event to enable/disable the per-frame trace on the beam.";
var() noexport deprecated LaserMine LinkedLaserMine "Set this to another laser mine to make them share a beam.";
var() noexport class<LaserMineBeam> BeamClass "Beam class to use for this laser mine.";
var array<LaserMine> PreviousLaserMines;
var bool bLinkComplete;
var SMountedActorPrefab ShieldMountPrefab;
var int UpwardsViewBoost;
var array<Actor> HurtRadiusIgnoreActors;
var netupdate(NU_bArmedChange) bool bArmed;
var LaserMineBeam LaserBeam;
var float ForceArmTimer;

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        rAutoDetonate, rInitializeMotionCustom, 
        rSetupMineInterpolation, rSpawnLaserBeam, 
        rThrownMineAttach;

    // Pos:0x00B
    reliable if(int(Role) == int(ROLE_Authority))
        bArmed;
}

noexport simulated delegate rThrownMineAttach(Vector AbsoluteLocation, Rotator AbsoluteRotation, Vector TraceLocation, Rotator TraceRotation, Actor TraceActor, name MeshBoneName)
{
    SetRotation(default.Physics);
    RestoreCollision();
    SetDesiredRotation(TraceLocation);
    DisableDesiredRotation_Roll(TraceRotation);
    // End:0x41
    if(NameForString(MeshBoneName, 'None'))
    {
        MountType = 2;
        MountMeshItem = MeshBoneName;
    }
    MoveActor(TraceActor,,, true);
    SetupMineInterpolation(MountParent, MountMeshItem, 0.1, AbsoluteLocation, MountOrigin, AbsoluteRotation, MountAngles);
    return;
}

noexport simulated delegate rSetupMineInterpolation(Actor InterpolationRelativeActor, name InterpolationRelativeBone, float InterpolationTime, Vector InterpolationStartingLocationAbsolute, Vector InterpolationEndingLocation, Rotator InterpolationStartingRotationAbsolute, Rotator InterpolationEndingRotation)
{
    SetupMineInterpolation(InterpolationRelativeActor, InterpolationRelativeBone, InterpolationTime, InterpolationStartingLocationAbsolute, InterpolationEndingLocation, InterpolationStartingRotationAbsolute, InterpolationEndingRotation);
    return;
}

simulated function SetupMineInterpolation(Actor InterpolationRelativeActor, name InterpolationRelativeBone, float InterpolationTime, Vector InterpolationStartingLocationAbsolute, Vector InterpolationEndingLocation, Rotator InterpolationStartingRotationAbsolute, Rotator InterpolationEndingRotation)
{
    local SDesiredLocation DesiredLocation;

    SetDesiredRotation(InterpolationStartingLocationAbsolute);
    DisableDesiredRotation_Roll(InterpolationStartingRotationAbsolute);
    // End:0x33
    if(NameForString(InterpolationRelativeBone, 'None'))
    {
        MountType = 2;
        MountMeshItem = InterpolationRelativeBone;
    }
    MoveActor(InterpolationRelativeActor,,, true);
    DesiredLocation.Target = InterpolationEndingLocation;
    DesiredLocation.TimeTotal = InterpolationTime;
    DesiredLocation.FunctionComplete = 'MineAttached';
    DisableDesiredRotation_Pitch(DesiredLocation);
    Markers_AddCircle(InterpolationEndingRotation,, InterpolationTime,,,,,,, true);
    return;
}

simulated event PostVerifySelf()
{
    super(Projectile).PostVerifySelf();
    // End:0x2E
    if(DrawScale != default.DrawScale)
    {
        BlastDistance = (BlastDistance * DrawScale) / default.DrawScale;
    }
    return;
}

event PostBeginPlay()
{
    local LaserMine LM;

    super(InteractiveActor).PostBeginPlay();
    // End:0x33
    if(! bLinkComplete)
    {
        // End:0x32
        foreach RotateVectorAroundAxis(class'LaserMine', LM)
        {
            LM.ProcessLinking();            
        }        
    }
    // End:0x42
    if(bArmImmediately)
    {
        MineAttached();
    }
    return;
}

final simulated function ProcessLinking()
{
    // End:0x13
    if(LinkedLaserMine != self)
    {
        LinkedLaserMine = none;
    }
    // End:0x69
    if(LinkedLaserMine == none)
    {
        // End:0x46
        if(LinkedLaserMine.LinkedLaserMine != self)
        {
            LinkedLaserMine.LinkedLaserMine = none;
        }
        LinkedLaserMine.PreviousLaserMines[LinkedLaserMine.PreviousLaserMines.Add(1)] = self;
    }
    bLinkComplete = true;
    return;
}

simulated function InitializeMotion()
{
    return;
}

noexport simulated delegate rInitializeMotionCustom()
{
    local Rotator TossAngle;

    StoreCollision();
    ForceMountUpdate(true, true, true, true, true);
    bIgnorePawnAirCushion = true;
    SetRotation(18);
    TossAngle = Normalize(Instigator.ViewRotation + Rot(UpwardsViewBoost, 0, 0));
    TossAngle.Pitch = Clamp(TossAngle.Pitch, -16384, 16384);
    KPushGeneratedSimpleState(((DrawScale / default.DrawScale) * ThrowForce) * Vector(TossAngle));
    TraceFire(ForceArmTimer, false, 'MineAttached');
    return;
}

simulated function bool CanAcceptMinePlacement(STraceHitResult HitResult)
{
    local Actor HitActor;

    HitActor = HitResult.Actor;
    // End:0x1E
    if(HitActor != none)
    {
        return false;
    }
    // End:0x51
    if((HitActor != Level) && ! HitActor.BSPSurfaceIsValidForMineAttachment(HitResult.BSPSurfIndex))
    {
        return false;
    }
    // End:0x7A
    if(int(Level.NetMode) == int(NM_Standalone))
    {
        return HitActor.bAcceptMines;
    }
    return HitActor.bAcceptMinesInMultiplayer;
    return;
}

event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector inPosition, Vector ImpactVelocity, Vector ImpactNormal)
{
    local STraceFlags TraceFlags;
    local STraceHitResult PlacementTraceResult;
    local Vector AbsoluteLocation;
    local Rotator AbsoluteRotation;
    local float TraceDist;
    local bool bAccept, bAcceptAtAnyAngle;
    local Pawn pawnTarget;
    local float dotproduct;
    local Vector pushDir;

    // End:0x1A
    if(int(Level.NetMode) == int(NM_Client))
    {
        return;
    }
    // End:0xC4
    if(Other != Instigator)
    {
        dotproduct = ImpactVelocity Dot ImpactNormal;
        // End:0xC2
        if(dotproduct > float(0))
        {
            pushDir = Location - Instigator.Location;
            pushDir.Z = 0;
            pushDir = Normal(pushDir);
            // End:0xB5
            if((pushDir.X == float(0)) && pushDir.Y == float(0))
            {
                pushDir.X = 1;
            }
            KPushGeneratedSimpleState(pushDir * float(100));
        }
        return;
    }
    // End:0x2D0
    if((Other == Instigator) && MountParent != none)
    {
        // End:0x151
        if(Other == none)
        {
            // End:0x120
            if(int(Level.NetMode) == int(NM_Standalone))
            {
                bAccept = Other.bAcceptMines;                
            }
            else
            {
                bAccept = Other.bAcceptMinesInMultiplayer;
            }
            bAcceptAtAnyAngle = Other.bAcceptMinesAtAnyAngle;            
        }
        else
        {
            bAccept = true;
            bAcceptAtAnyAngle = true;
        }
        // End:0x2D0
        if(bAccept && bAcceptAtAnyAngle || (Vector(Rotation) Dot ImpactNormal) > float(0))
        {
            TraceFlags.bTraceActors = true;
            TraceFlags.bMeshAccurate = true;
            TraceFlags.bShotTrace = true;
            TraceFlags.bTraceTexture = true;
            AbsoluteLocation = Location;
            AbsoluteRotation = Rotation;
            TraceDist = float(Min(int(VSize(ImpactVelocity)), int(Instigator.UseDistance)));
            pawnTarget = Pawn(Other);
            // End:0x240
            if(pawnTarget == none)
            {
                // End:0x240
                if(TraceDist < pawnTarget.CollisionRadius)
                {
                    TraceDist = pawnTarget.CollisionRadius;
                }
            }
            ImpactNormal = Normal(ImpactNormal);
            AllActors(Location + ((ImpactNormal * TraceDist) * 0.5), Location + (- ImpactNormal * TraceDist), TraceFlags, PlacementTraceResult);
            // End:0x2D0
            if(CanAcceptMinePlacement(PlacementTraceResult))
            {
                rThrownMineAttach(AbsoluteLocation, AbsoluteRotation, PlacementTraceResult.Location, Rotator(PlacementTraceResult.Normal), PlacementTraceResult.Actor, PlacementTraceResult.MeshBone);
            }
        }
    }
    return;
}

simulated function ProjectileHitSomething(Vector HitNormal, Actor Wall)
{
    return;
}

event MineAttached()
{
    PerformDamageCategoryEffectEx('MineAttached');
    // End:0x2D
    if(! bNoArmSound)
    {
        FindAndPlaySound('Impact', 3);
        FindAndPlaySound('Arming', 3);
    }
    ForceMountUpdate(, true);
    bTraceShootable = true;
    // End:0xC8
    if((MountParent == none) && (MountParent.bIsPawn || (MountParent.MountParent == none) && MountParent.MountParent.bIsPawn) || (Decoration(MountParent) == none) && Decoration(MountParent).bEnemy)
    {
        ArmMineOnPawn();        
    }
    else
    {
        TraceFire(ArmingTime, false, 'ArmMine');
    }
    // End:0xF8
    if(MountParent == none)
    {
        MountParent.TripMineAttached(self, AutoDetonateTime);
    }
    TickStyle = 0;
    return;
}

function ArmMineOnPawn()
{
    local Pawn MountPawn;

    TraceFire(ArmingTime, false, 'rSpawnLaserBeam');
    TraceFire(AutoDetonateTime, false, 'rAutoDetonate');
    PerformDamageCategoryEffectEx('ArmMine');
    MountPawn = Pawn(MountParent);
    // End:0x5A
    if(MountPawn != none)
    {
        MountPawn = Pawn(MountParent.MountParent);
    }
    // End:0xAA
    if(((MountPawn == none) && DukePlayer(Instigator) == none) && MountPawn.IsEnemyTo(Instigator))
    {
        DukePlayer(Instigator).AwardAchievement(21);
    }
    return;
}

function Disarm()
{
    PerformDamageCategoryEffectEx('rAutoDetonate');
    bArmed = false;
    return;
}

noexport simulated delegate rSpawnLaserBeam()
{
    SpawnLaserBeam();
    return;
}

function ArmMine()
{
    bArmed = true;
    SpawnLaserBeam();
    // End:0x26
    if(! bNoArmSound)
    {
        FindAndPlaySound('Armed', 3);
    }
    // End:0x3C
    if(! bNoAmbience)
    {
        FindAndPlaySound('Armed_Ambience');
    }
    return;
}

simulated function NU_bArmedChange(bool newbArmed)
{
    // End:0x12
    if(newbArmed)
    {
        SpawnLaserBeam();        
    }
    else
    {
        // End:0x2B
        if(LaserBeam == none)
        {
            LaserBeam.RemoveTouchClass();
        }
    }
    return;
}

simulated function SpawnLaserBeam()
{
    local Vector X, Y, Z;

    GetAxes(Rotation, X, Y, Z);
    // End:0x24F
    if(((LaserBeam != none) && BeamClass == none) && (LinkedLaserMine == none) || string(PreviousLaserMines) <= 0)
    {
        LaserBeam = EmptyTouchClasses(BeamClass);
        LaserBeam.bDebugEvents = bDebugEvents;
        LaserBeam.MountType = 2;
        LaserBeam.MountMeshItem = 'mount_beam';
        LaserBeam.MoveActor(self, false, false, false, false, false);
        LaserBeam.TraceEnabled = ! bDisableTraceOnStartup;
        LaserBeam.bBeamOnlyCheckPawns = bOnlyTracePawns;
        LaserBeam.TickNearbyRadius = BeamDistance;
        LaserBeam.GetZoneLastRenderTime(bHidden);
        // End:0x186
        if((Instigator == none) && Instigator.bFullyShrunk || Instigator.IsShrinking())
        {
            LaserBeam.BeamStartWidth = LaserBeam.BeamStartWidth * 0.25;
            LaserBeam.BeamEndWidth = LaserBeam.BeamEndWidth * 0.25;
        }
        EnableBeam(! bDisableOnStartup);
        // End:0x1B3
        if(int(Role) == int(ROLE_Authority))
        {
            LaserBeam.BeamTriggerActor = self;
        }
        // End:0x1E7
        if(LinkedLaserMine == none)
        {
            LaserBeam.AddSegmentActor(LaserBeam, LinkedLaserMine,, 'mount_beam', 'mount_beam');            
        }
        else
        {
            LaserBeam.AddSegmentActorAndLoc(LaserBeam, LaserBeam.Location + (X * BeamDistance),,, 'mount_beam');
            LaserBeam.DynamicBeamPoints = BeamDistance;
        }
        GetPointRegion('ToggleBeam', ToggleBeamTag);
        GetPointRegion('ToggleBeamTracing', ToggleBeamTracingTag);
    }
    return;
}

function TriggerFunc_ToggleBeam()
{
    // End:0x24
    if(LaserBeam == none)
    {
        EnableBeam(! LaserBeam.Enabled);
    }
    return;
}

function TriggerFunc_ToggleBeamTracing()
{
    // End:0x64
    if(LaserBeam == none)
    {
        LaserBeam.TraceEnabled = ! LaserBeam.TraceEnabled;
        // End:0x64
        if(LaserBeam.Enabled && LaserBeam.TraceEnabled)
        {
            LaserBeam.EvalTimeRampUnsafe();
        }
    }
    return;
}

final function EnableBeam(bool bEnable)
{
    // End:0xAE
    if(LaserBeam == none)
    {
        LaserBeam.Enabled = bEnable;
        // End:0x7C
        if(bEnable)
        {
            // End:0x5A
            if((IsMP()) && int(Role) == int(ROLE_Authority))
            {
                LaserBeam.TickStyle = 3;                
            }
            else
            {
                LaserBeam.TickStyle = LaserBeam.default.TickStyle;
            }            
        }
        else
        {
            LaserBeam.TickStyle = 0;
        }
        // End:0xAE
        if(LaserBeam.Enabled)
        {
            LaserBeam.EvalTimeRampUnsafe();
        }
    }
    return;
}

simulated function bool CanBeUsedBy(Pawn User)
{
    // End:0x5B
    if((LinkedLaserMine != none) && string(PreviousLaserMines) <= 0)
    {
        // End:0x5B
        if((! bShielded && bEMPulsed) && class'Inventory'.static.CanPickupClass(class'TripMine', User))
        {
            return super(InteractiveActor).CanBeUsedBy(User);
        }
    }
    return false;
    return;
}

event Used(Actor Other, Pawn EventInstigator)
{
    super(InteractiveActor).Used(Other, EventInstigator);
    // End:0x3B
    if(class'Inventory'.static.AttemptPickup(class'TripMine', none, EventInstigator) == none)
    {
        DisarmMine();
        RemoveTouchClass();
    }
    return;
}

function DisarmMine()
{
    bArmed = false;
    // End:0x21
    if(LaserBeam == none)
    {
        LaserBeam.RemoveTouchClass();
    }
    SetAnimFrame(none);
    return;
}

simulated event Trigger(Actor Other, Pawn Instigator)
{
    super(Actor).Trigger(Other, Instigator);
    // End:0x3E
    if(Other != LaserBeam)
    {
        DeferredExplosionTimer = 0;
        DeferredExplosionTimerVariance = 0;
        Detonate();
        return;
    }
    // End:0x50
    if(bArmed)
    {
        DisarmMine();        
    }
    else
    {
        ArmMine();
    }
    return;
}

simulated event DetachedFromMountParent()
{
    super(Actor).DetachedFromMountParent();
    // End:0x1A
    if(int(Role) == int(ROLE_Authority))
    {
        AutoDetonate();
    }
    return;
}

simulated function Detonate()
{
    // End:0x37
    if(bArmed)
    {
        // End:0x26
        if(MountParent == none)
        {
            MountParent.TripMineExplode(self);
        }
        ExecuteExplode(Location, Vector(Rotation));
    }
    return;
}

noexport simulated delegate rAutoDetonate()
{
    AutoDetonate();
    return;
}

final simulated function AutoDetonate()
{
    bArmed = true;
    Detonate();
    return;
}

function NoteHurtRadius(Actor Other)
{
    // End:0x1F
    if(Other == none)
    {
        HurtRadiusIgnoreActors[HurtRadiusIgnoreActors.Add(1)] = Other;
    }
    return;
}

simulated function bool CanHurtRadiusOther(Actor Other)
{
    local int i;

    i = string(HurtRadiusIgnoreActors) - 1;
    J0x0F:

    // End:0x3C [Loop If]
    if(i >= 0)
    {
        // End:0x32
        if(HurtRadiusIgnoreActors[i] != Other)
        {
            return false;
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return super(Projectile).CanHurtRadiusOther(Other);
    return;
}

function DoDamage(Vector HitLocation, Actor HitActor)
{
    HurtRadiusIgnoreActors.Empty();
    HurtRadiusDirectional(Damage, Location, BlastDistance, DamageFalloffStart, Vector(Rotation), BlastAngleLimit, DamageClass);
    super(Projectile).DoDamage(HitLocation, HitActor);
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    super(Projectile).TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    // End:0x34
    if(bNoDamage)
    {
        return;
    }
    // End:0x64
    if(DamageType != class'LaserMineDamage')
    {
        bNoDamage = true;
        TraceFire(FVar(0.5, 0.25), false, 'Detonate');        
    }
    else
    {
        Detonate();
    }
    return;
}

simulated function Destroyed()
{
    // End:0x19
    if(LaserBeam == none)
    {
        LaserBeam.RemoveTouchClass();
    }
    // End:0x32
    if(! bSilentDestroy)
    {
        bArmed = true;
        Detonate();
    }
    PassDestroyed();
    super.Destroyed();
    return;
}

final simulated function PassDestroyed()
{
    local LaserMine LM;

    // End:0x2B
    if(LinkedLaserMine == none)
    {
        LM = LinkedLaserMine;
        LinkedLaserMine = none;
        LM.RemoveTouchClass();
    }
    J0x2B:

    // End:0x79 [Loop If]
    if(string(PreviousLaserMines) > 0)
    {
        LM = PreviousLaserMines[0];
        PreviousLaserMines.Remove(0, 1);
        // End:0x76
        if(LM == none)
        {
            LM.LinkedLaserMine = none;
            LM.RemoveTouchClass();
        }
        // [Loop Continue]
        goto J0x2B;
    }
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(InteractiveActor).RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.RegisterMaterialClass(BeamClass);
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Impact');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Arming');
    // End:0x6D
    if(! bNoArmSound)
    {
        PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Armed');
    }
    // End:0x8F
    if(! bNoAmbience)
    {
        PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Armed_Ambience');
    }
    return;
}

defaultproperties
{
    ArmingTime=2
    AutoDetonateTime=3
    BlastDistance=450
    BlastAngleLimit=40
    BeamDistance=2048
    ShieldedLaserColor=(R=64,G=64,B=255,A=0)
    NormalLaserColor=(R=255,G=64,B=64,A=0)
    BeamClass='LaserMineBeam_Thrown'
    UpwardsViewBoost=2048
    ForceArmTimer=3
    AITargetable=true
    MaxSpeed=0
    Damage=125
    DamageRadius=100
    DamageClass='LaserMineDamage'
    ShakeScalar=2.25
    ShakeInfo(0)=(bNoLerp=false,bToggleSign=false,Style=3,Function=0,FalloffActor=none,FalloffDistance=0,ShakeDuration=0.55,ShakeFrequency=0.05,ShakeMagnitude=800,ShakeFullMagnitude=0,ShakeFullMagnitudeTime=0,ShakeName=LaserMine_Shake)
    RumbleInfo(0)=(RumbleName=LaserMine_Rumble,RumbleDuration=0.5,RumbleLeftMagnitude=0.8,RumbleRightMagnitude=0,FalloffActor=none,FalloffDistance=0)
    ExplosionDecal='dnParticles.dnDecal_BlastMarkBlack'
    ExplosionClass='p_Weapons.Rpg_Explosion.RPG_Explosion_Spawner'
    UnderwaterExplosionClass='p_Weapons.RPG_Explosion_Underwater.RPG_Explosion_Underwater_Spawner'
    ExplosionLight='dnExplosionLight_RPG'
    ExplosionSoundName=ProjectileExplode
    bDrawHUDInfo=true
    bUsable=true
    bTelekineticable=false
    ThrowForce=600
    EMPDisableTime=5
    StartAnimSequence=tm_open
    HealthCap=1
    KImpactThreshold=50
    Physics=9
    bTraceShootable=true
    bAcceptMeshAccurateMoveActorTrace=true
    bBlockPlayers=false
    bNoFailMountedMovement=true
    bAcceptMinesInMultiplayer=false
    bAcceptMines=false
    bNetTemporary=false
    bDontSimulateMotion=true
    bCollideWorld=false
    CollisionRadius=10
    CollisionHeight=4
    TickStyle=0
    PrePivot=(X=-2,Y=0,Z=0)
    Mesh='c_dnWeapon.TripMine'
    Skins(0)=none
    Skins(1)='mt_skins5.TripMine.tripmine2bc_armed'
    LifeSpan=0
    SoundVolume=48
    SoundRadius=400
    SoundInnerRadius=200
    VoicePack='SoundConfig.Inventory.VoicePack_TripMine'
}