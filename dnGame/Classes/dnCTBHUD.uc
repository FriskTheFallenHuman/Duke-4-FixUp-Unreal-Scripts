/*******************************************************************************
 * dnCTBHUD generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class dnCTBHUD extends dnTeamDeathmatchHUD
    config(User)
    collapsecategories;

var Texture BlueBackground;
var Texture RedBackground;
var Texture BabeLeftImage;
var Texture droppedWarning;
var Texture carriedWarning;
var Texture babeLocTexture;
var Texture returnPointTexture;
var Texture arrowTex;
var float ImagescaleX;
var float ImagescaleY;
var float IconXLowBounds;
var float IconYLowBounds;
var float IconXHighBounds;
var float IconYHighBounds;
var int indicatorRadius;
var Color Team0Color;
var Color Team1Color;
var float BkgX;
var float BkgY;
var localized string strMsgBabeCarried;
var localized string strMsgBabeScored;
var localized string strMsgBabeDropped;
var localized string strMsgBabeStanding;
var localized string BlueStr;
var localized string RedStr;
var config float CombatTextStartXPos;
var config float CombatTextStartYPos;
var dnCaptureTheBabe_Babe redBabe;
var dnCaptureTheBabe_Babe blueBabe;
var float OMCageZOffset;
var float OMBabeZOffset;

simulated event PostPostRender(Canvas C)
{
    local dnDeathmatchGameReplicationInfo GRI;

    GRI = dnDeathmatchGameReplicationInfo(Level.GRI);
    super.PostPostRender(C);
    // End:0xA0
    if(((((GRI == none) && GRI.RoundTimeLimit > 0) && ! GRI.bWaitingForPlayers) && GRI.CountDown <= 0) && GRI.ShowWinnerSeconds <= 0)
    {
        DrawBabeStateHUD(C);
    }
    DrawWorldIcons(C);
    return;
}

simulated function PostBeginPlay()
{
    super(dnDeathmatchGameHUD).PostBeginPlay();
    return;
}

function SetBabeState(int Team, dnDeathmatchGameReplicationInfo.EBabeState BabeState, string HudMsg)
{
    local dnDeathmatchGameReplicationInfo GRI;

    GRI = dnDeathmatchGameReplicationInfo(Level.GRI);
    // End:0x7E
    if(((GRI == none) && GRI.bWaitingForPlayers) || (dnMultiplayer(Level.Game) == none) && dnMultiplayer(Level.Game).IsAlone())
    {
        return;
    }
    // End:0xA8
    if(int(BabeState) != int(0))
    {
        // End:0xA1
        if(Team == 1)
        {
            Team = 0;            
        }
        else
        {
            Team = 1;
        }
    }
    AddCTBScrollingCombatText(HudMsg, byte(Team));
    return;
}

function AddCTBScrollingCombatText(string Text, byte Team)
{
    local HUDScrollingMessage msg;

    msg.Message = Text;
    // End:0x2F
    if(int(Team) == 1)
    {
        msg.DrawColor = RedColor;        
    }
    else
    {
        msg.DrawColor = BlueColor;
    }
    msg.ScreenX = SizeX * CombatTextStartXPos;
    msg.ScreenY = SizeY * CombatTextStartYPos;
    msg.VelX = 0;
    msg.VelY = -0.1;
    msg.Lifetime = 3;
    msg.FadeTime = 3;
    ScrollingCombatText[ScrollingCombatText.Add(1)] = msg;
    return;
}

simulated function DrawBabeStateHUD(Canvas C)
{
    local float backgroundBlueX, backgroundRedX, backgroundY, backgroundXLeft, backgroundXRight, backgroundImageSizeX,
	    backgroundImageSizeY, babeBlueX, babeRedX, babeY, babeXLeft,
	    babeXRight, babeImageSizeX, babeImageSizeY;

    local bool blueMirrorHoriz, redMirrorHoriz;
    local float carriedDroppedBlueX, carriedDroppedRedX, carriedDroppedY, carriedDroppedXLeft, carriedDroppedXRight, carriedImageSizeX,
	    carriedImageSizeY, DroppedImageSizeX, DroppedImageSizeY;

    // End:0x0D
    if(! CheckBabes())
    {
        return;
    }
    backgroundXLeft = 310 * HUDScaleX;
    backgroundXRight = 520 * HUDScaleX;
    // End:0x6A
    if(int(PlayerOwner.PlayerReplicationInfo.Team) == 0)
    {
        backgroundBlueX = backgroundXLeft;
        backgroundRedX = backgroundXRight;        
    }
    else
    {
        backgroundBlueX = backgroundXRight;
        backgroundRedX = backgroundXLeft;
    }
    backgroundY = 50 * HUDScaleY;
    babeXLeft = 370 * HUDScaleX;
    babeXRight = 555 * HUDScaleX;
    // End:0xFF
    if(int(PlayerOwner.PlayerReplicationInfo.Team) == 0)
    {
        babeBlueX = babeXLeft;
        babeRedX = babeXRight;
        blueMirrorHoriz = false;
        redMirrorHoriz = true;        
    }
    else
    {
        babeBlueX = babeXRight;
        babeRedX = babeXLeft;
        blueMirrorHoriz = true;
        redMirrorHoriz = false;
    }
    babeY = 50 * HUDScaleY;
    carriedDroppedXLeft = 345 * HUDScaleX;
    carriedDroppedXRight = 585 * HUDScaleX;
    // End:0x194
    if(int(PlayerOwner.PlayerReplicationInfo.Team) == 0)
    {
        carriedDroppedBlueX = carriedDroppedXLeft;
        carriedDroppedRedX = carriedDroppedXRight;        
    }
    else
    {
        carriedDroppedBlueX = carriedDroppedXRight;
        carriedDroppedRedX = carriedDroppedXLeft;
    }
    carriedDroppedY = 50 * HUDScaleY;
    backgroundImageSizeX = float(BlueBackground.DrawStatic()) * HUDScaleX;
    backgroundImageSizeY = float(BlueBackground.DrawTile()) * HUDScaleY;
    babeImageSizeX = float(BabeLeftImage.DrawStatic()) * HUDScaleX;
    babeImageSizeY = float(BabeLeftImage.DrawTile()) * HUDScaleY;
    carriedImageSizeX = float(carriedWarning.DrawStatic()) * HUDScaleX;
    carriedImageSizeY = float(carriedWarning.DrawTile()) * HUDScaleY;
    DroppedImageSizeX = float(droppedWarning.DrawStatic()) * HUDScaleX;
    DroppedImageSizeY = float(droppedWarning.DrawTile()) * HUDScaleY;
    C.SetPause(backgroundBlueX, backgroundY);
    C.SetClampMode(BlueBackground, backgroundImageSizeX, backgroundImageSizeY, 0, 0, float(BlueBackground.DrawStatic()), float(BlueBackground.DrawTile()));
    backgroundImageSizeX = float(RedBackground.DrawStatic()) * HUDScaleX;
    backgroundImageSizeY = float(RedBackground.DrawTile()) * HUDScaleY;
    C.SetPause(backgroundRedX, backgroundY);
    C.SetClampMode(RedBackground, backgroundImageSizeX, backgroundImageSizeY, 0, 0, float(RedBackground.DrawStatic()), float(RedBackground.DrawTile()));
    C.SetPause(babeBlueX, babeY);
    C.SetClampMode(BabeLeftImage, babeImageSizeX, babeImageSizeY, 0, 0, float(BabeLeftImage.DrawStatic()), float(BabeLeftImage.DrawTile()),,,,,, blueMirrorHoriz);
    C.SetPause(babeRedX, babeY);
    C.SetClampMode(BabeLeftImage, babeImageSizeX, babeImageSizeY, 0, 0, float(BabeLeftImage.DrawStatic()), float(BabeLeftImage.DrawTile()),,,,,, redMirrorHoriz);
    // End:0x4C4
    if(int(dnDeathmatchGameReplicationInfo(Level.GRI).Team0BabeState) == int(1))
    {
        C.SetPause(carriedDroppedBlueX, carriedDroppedY);
        C.SetClampMode(carriedWarning, carriedImageSizeX, carriedImageSizeY, 0, 0, float(carriedWarning.DrawStatic()), float(carriedWarning.DrawTile()));
    }
    // End:0x544
    if(int(dnDeathmatchGameReplicationInfo(Level.GRI).Team1BabeState) == int(1))
    {
        C.SetPause(carriedDroppedRedX, carriedDroppedY);
        C.SetClampMode(carriedWarning, carriedImageSizeX, carriedImageSizeY, 0, 0, float(carriedWarning.DrawStatic()), float(carriedWarning.DrawTile()));
    }
    // End:0x5C4
    if(int(dnDeathmatchGameReplicationInfo(Level.GRI).Team0BabeState) == int(2))
    {
        C.SetPause(carriedDroppedBlueX, carriedDroppedY);
        C.SetClampMode(droppedWarning, DroppedImageSizeX, DroppedImageSizeY, 0, 0, float(droppedWarning.DrawStatic()), float(droppedWarning.DrawTile()));
    }
    // End:0x644
    if(int(dnDeathmatchGameReplicationInfo(Level.GRI).Team1BabeState) == int(2))
    {
        C.SetPause(carriedDroppedRedX, carriedDroppedY);
        C.SetClampMode(droppedWarning, DroppedImageSizeX, DroppedImageSizeY, 0, 0, float(droppedWarning.DrawStatic()), float(droppedWarning.DrawTile()));
    }
    return;
}

simulated function DrawWorldIcons(Canvas C)
{
    // End:0x0D
    if(! CheckBabes())
    {
        return;
    }
    // End:0x2A
    if(Level.TickHint().IsDead())
    {
        return;
    }
    ImagescaleX = HUDScaleX;
    // End:0x4F
    if(ImagescaleX > 1)
    {
        ImagescaleX = 1;
    }
    ImagescaleY = HUDScaleY;
    // End:0x74
    if(ImagescaleY > 1)
    {
        ImagescaleY = 1;
    }
    IconXLowBounds = float(C.SizeX) * 0.15;
    IconYLowBounds = float(C.SizeY) * 0.15;
    IconXHighBounds = float(C.SizeX) * 0.85;
    IconYHighBounds = float(C.SizeY) * 0.85;
    // End:0x1B2
    if(int(PlayerOwner.PlayerReplicationInfo.Team) == 0)
    {
        DrawHUDIcon_TheirBabe(C, redBabe, dnDeathmatchGameReplicationInfo(Level.GRI).Team1BabeState);
        // End:0x1AF
        if((int(dnDeathmatchGameReplicationInfo(Level.GRI).Team1BabeState) == int(1)) && redBabe.CarriedBy != Level.TickHint())
        {
            DrawHUDIcon_ReturnPnt(C, redBabe, dnDeathmatchGameReplicationInfo(Level.GRI).Team1BabeState);
        }        
    }
    else
    {
        DrawHUDIcon_TheirBabe(C, blueBabe, dnDeathmatchGameReplicationInfo(Level.GRI).Team0BabeState);
        // End:0x259
        if((int(dnDeathmatchGameReplicationInfo(Level.GRI).Team0BabeState) == int(1)) && blueBabe.CarriedBy != Level.TickHint())
        {
            DrawHUDIcon_ReturnPnt(C, blueBabe, dnDeathmatchGameReplicationInfo(Level.GRI).Team0BabeState);
        }
    }
    return;
}

simulated function DrawHUDIcon_TheirBabe(Canvas C, dnCaptureTheBabe_Babe babe, dnDeathmatchGameReplicationInfo.EBabeState BabeState)
{
    local float X, Y, babeLocUSize, babeLocVSize, arrowOffset;

    local Vector babeLoc;
    local Pawn LocalPlayer;

    LocalPlayer = Level.TickHint();
    // End:0x4F
    if(((int(BabeState) == int(1)) && babe.CarriedBy != LocalPlayer) || int(BabeState) == int(3))
    {
        return;
    }
    arrowOffset = 50 * ImagescaleX;
    indicatorRadius = int(float(285) * ImagescaleX);
    babeLocUSize = float(babeLocTexture.DrawStatic()) * ImagescaleX;
    babeLocVSize = float(babeLocTexture.DrawTile()) * ImagescaleY;
    babeLoc = babe.Location + Vect(0, 0, OMBabeZOffset);
    // End:0x1EF
    if(C.DrawBlurryDesaturation(babeLoc, X, Y))
    {
        X -= (babeLocUSize / float(2));
        Y -= (babeLocVSize / float(2));
        // End:0x193
        if((((X < IconXLowBounds) || X > IconXHighBounds) || Y < IconYLowBounds) || Y > IconYHighBounds)
        {
            DrawString(C, babeLocTexture, babeLoc, float(indicatorRadius),,,,, true);
            DrawString(C, arrowTex, babeLoc, float(indicatorRadius) + arrowOffset);            
        }
        else
        {
            C.SetPause(X, Y);
            C.SetClampMode(babeLocTexture, babeLocUSize, babeLocVSize, 0, 0, float(babeLocTexture.DrawStatic()), float(babeLocTexture.DrawTile()));
        }        
    }
    else
    {
        DrawString(C, babeLocTexture, babeLoc, float(indicatorRadius),,,,, true);
        DrawString(C, arrowTex, babeLoc, float(indicatorRadius) + arrowOffset);
    }
    return;
}

simulated function DrawHUDIcon_ReturnPnt(Canvas C, dnCaptureTheBabe_Babe babe, dnDeathmatchGameReplicationInfo.EBabeState BabeState)
{
    local float X, Y, returnPntUSize, returnPntVSize, arrowOffset;

    local Vector returnPntLoc;

    arrowOffset = 50 * ImagescaleX;
    indicatorRadius = int(float(285) * ImagescaleX);
    returnPntUSize = float(returnPointTexture.DrawStatic()) * ImagescaleX;
    returnPntVSize = float(returnPointTexture.DrawTile()) * ImagescaleY;
    returnPntLoc = babe.AreaOppositeLocation + Vect(0, 0, OMCageZOffset);
    // End:0x1A0
    if(C.DrawBlurryDesaturation(returnPntLoc, X, Y))
    {
        X -= (returnPntUSize / float(2));
        Y -= (returnPntVSize / float(2));
        // End:0x144
        if((((X < IconXLowBounds) || X > IconXHighBounds) || Y < IconYLowBounds) || Y > IconYHighBounds)
        {
            DrawString(C, returnPointTexture, returnPntLoc, float(indicatorRadius),,,,, true);
            DrawString(C, arrowTex, returnPntLoc, float(indicatorRadius) + arrowOffset);            
        }
        else
        {
            C.SetPause(X, Y);
            C.SetClampMode(returnPointTexture, returnPntUSize, returnPntVSize, 0, 0, float(returnPointTexture.DrawStatic()), float(returnPointTexture.DrawTile()));
        }        
    }
    else
    {
        DrawString(C, returnPointTexture, returnPntLoc, float(indicatorRadius),,,,, true);
        DrawString(C, arrowTex, returnPntLoc, float(indicatorRadius) + arrowOffset);
    }
    return;
}

simulated function bool CheckBabes()
{
    local Pawn P;
    local dnCaptureTheBabe_Babe temp;

    // End:0xA5
    if((redBabe != none) || blueBabe != none)
    {
        P = Level.PawnList;
        J0x2F:

        // End:0xA5 [Loop If]
        if(P == none)
        {
            // End:0x8D
            if(P.bIsCTBBabe)
            {
                temp = dnCaptureTheBabe_Babe(P);
                // End:0x82
                if(int(temp.Team) == 0)
                {
                    blueBabe = temp;                    
                }
                else
                {
                    redBabe = temp;
                }
            }
            P = P.NextPawn;
            // [Loop Continue]
            goto J0x2F;
        }
    }
    // End:0xC1
    if((redBabe != none) || blueBabe != none)
    {
        return false;
    }
    return true;
    return;
}

simulated function bool CheckAreas(dnCaptureTheBabe_Babe babe)
{
    return true;
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super.RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.RegisterAnimationControllerEntry(BlueBackground);
    PrecacheIndex.RegisterAnimationControllerEntry(RedBackground);
    PrecacheIndex.RegisterAnimationControllerEntry(BabeLeftImage);
    PrecacheIndex.RegisterAnimationControllerEntry(droppedWarning);
    PrecacheIndex.RegisterAnimationControllerEntry(carriedWarning);
    PrecacheIndex.RegisterAnimationControllerEntry(babeLocTexture);
    PrecacheIndex.RegisterAnimationControllerEntry(returnPointTexture);
    PrecacheIndex.RegisterAnimationControllerEntry(arrowTex);
    return;
}

defaultproperties
{
    BlueBackground='dt_hud.ingame_hud.ctb_blueBackground'
    RedBackground='dt_hud.ingame_hud.ctb_redBackground'
    BabeLeftImage='dt_hud.ingame_hud.ctb_babeLeft'
    droppedWarning='dt_hud.ingame_hud.ctb_droppedWarning'
    carriedWarning='dt_hud.ingame_hud.ctb_inTransitWarning'
    babeLocTexture='dt_hud.ingame_hud.locationmarker_get'
    returnPointTexture='dt_hud.ingame_hud.locationmarker_give'
    arrowTex='dt_hud.ingame_hud.locationmarker_arrow'
    indicatorRadius=240
    Team0Color=(R=27,G=90,B=255,A=0)
    Team1Color=(R=255,G=0,B=0,A=0)
    BkgX=128
    BkgY=64
    strMsgBabeCarried="<?int?dnGame.dnCTBHUD.strMsgBabeCarried?>"
    strMsgBabeScored="<?int?dnGame.dnCTBHUD.strMsgBabeScored?>"
    strMsgBabeDropped="<?int?dnGame.dnCTBHUD.strMsgBabeDropped?>"
    strMsgBabeStanding="<?int?dnGame.dnCTBHUD.strMsgBabeStanding?>"
    BlueStr="<?int?dnGame.dnCTBHUD.BlueStr?>"
    RedStr="<?int?dnGame.dnCTBHUD.RedStr?>"
    CombatTextStartXPos=0.5
    CombatTextStartYPos=0.3
    OMCageZOffset=80
    OMBabeZOffset=50
    BabeOffCenterOffset=0.05
    BabeScale=196
    BabeOffsetY=0.005
    PickupEventYOffset=0.75
}