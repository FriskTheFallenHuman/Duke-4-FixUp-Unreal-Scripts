/*******************************************************************************
 * dnUsableSomething generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class dnUsableSomething extends dnDecoration
    abstract
    native
    collapsecategories;

cpptext
{
// Stripped
}

struct SHUDKeyHelp
{
    var() Engine.Object.ESpecialKeys Key;
    var() Engine.Object.ESpecialKeys KeyAlt;
    var() string HelpText;
};

struct SUsableExitAnim
{
    var() Vector LocationOffset;
    var() Rotator RotationOffset;
    var() anim name Animation;
    var() name SoundName;
};

struct SUsableSpaceExit
{
    var() bool bEnabled;
    var() SUsableExitAnim EnterInfo;
    var() SUsableExitAnim ExitInfo;
    var() SUsableExitAnim ExitEndInfo;
};

var() class<ControlRemapperEx> ControlRemapperClass;
var ControlRemapperEx InternalControlRemapper;
var() noexport bool bUseHomePose "If true, this item will use old robotic style system of using intermediate home poses instead of animation crossfading.";
var float InterpolationInTime;
var float InterpolationOutTime;
var() noexport array<SHUDKeyHelp> HUDHelpEntries "Help text entries that show on the HUD.";
var() noexport array<SUsableSpaceExit> UsableExits "Relative positions/rotations from which this decoration can be used.";
var() noexport float DisplayInputHelpTime "Amount of time to display input help.  Stays up forever is <= 0.0f.";
var float DisplayInputStopTime;
var() SMountPrefab UserMountPrefab;
var() noexport bool bDisableCrosshairHUD "Should the crosshair hud be hidden when we're using this dnUsableSomething?";
var() noexport bool bDisableCrosshair "Not the same as bDisableCrosshairHUD.  This jsut control the crosshair.";
var() noexport float FOVScalar "Scale the user's FOV by the amount while attached to this UsableSomething.";
var() noexport float FOVTransitionTime "Amount of time to take for FOV scale transition.";
var() noexport class<Pawn> UsableClass "An actor must be of this class to be used by this decoration.";
var() float ViewingAngleThreshold;
var Rotator ForwardRotationOffset;
var() noexport float ReuseTime "How long before this decoration can be used again?";
var float TimeGate;
var noexport bool bStandardUseRestriction "Force this actor to auto-enable the standard use restrictions on Pawns (Must be walking and standing upright for example).";
var() noexport bool bDetachOnDamage "When damaged, the user will try to detach automatically.";
var() noexport bool bDebugPositioning "If true, this will draw a bunch of markers showing various degrees of position checking and junk.  It's a mess.";
var() noexport bool bExitAssumeValid "If true, the first enabled exit will always be used without doing the CanFit test.";
var() name SE_ForcePlayerAttach;
var() name SE_ForcePlayerAttachComplete;
var() name SE_ForcePlayerDetach;
var() name SE_ForcePlayerDetachComplete;
var() name SE_DisablePlayerLock;
var() name SE_EnablePlayerLock;
var() name SE_TogglePlayerLock;
var() float MouseInputScaleX;
var() float MouseInputScaleY;
var() float AnalogInputScaleX;
var() float AnalogInputScaleY;
var float MouseInputX;
var float MouseInputY;
var float ServerMouseInputX;
var float ServerMouseInputY;
var float MaxMouseDelta;
var bool CamRelativeMouseInput;
var() Rotator HeadAimMinOffset;
var() Rotator HeadAimMaxOffset;
var() bool bManipulateViewOnAttach;
var() bool bManipulateViewOnIdle;
var() bool bManipulateViewOnDetach;
var bool bUsePreRender;
var bool bCorrectInverse;
var bool bInternalUseDetach;
var bool bPreserveInternalUseDetach;
var int ActiveUsableExit;
var Actor PretendSelf;
var Pawn User;
var PlayerPawn PlayerUser;
var Pawn AIReserved;
var() noexport name AttachUserSoundName "Entry in the VoicePack to use for playing a sound of the user attaching.";
var() noexport name DetachUserSoundName "Entry in the VoicePack to use for playing a sound of the user detaching.";
var Vector LocalCollisionCenter;
var Vector LocalCollisionDimensions;
var float InterpRelevantDrawscaleDifference;
var Vector InterpRelevantLocation;
var Rotator InterpRelevantRotation;
var() noexport float ShakeViewScale "Scale of view shaking when the player is on this control.";

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        ActiveUsableExit, InternalControlRemapper, 
        PretendSelf;

    // Pos:0x00B
    reliable if(int(Role) == int(ROLE_Authority))
        rAttachPawnSuccess, rDetachPawnSuccess;

    // Pos:0x016
    reliable if((int(Role) == int(ROLE_Authority)) && User == none)
        User;

    // Pos:0x02F
    reliable if((int(Role) == int(ROLE_Authority)) && PlayerUser == none)
        PlayerUser;

    // Pos:0x048
    reliable if(int(Role) == int(ROLE_Authority))
        ServerMouseInputX, ServerMouseInputY;
}

event PreBeginPlay()
{
    GetPointRegion('ForcePlayerAttach', SE_ForcePlayerAttach);
    GetPointRegion('ForcePlayerAttachComplete', SE_ForcePlayerAttachComplete);
    GetPointRegion('ForcePlayerDetach', SE_ForcePlayerDetach);
    GetPointRegion('ForcePlayerDetachComplete', SE_ForcePlayerDetachComplete);
    GetPointRegion('DisablePlayerLock', SE_DisablePlayerLock);
    GetPointRegion('EnablePlayerLock', SE_EnablePlayerLock);
    GetPointRegion('TogglePlayerLock', SE_TogglePlayerLock);
    PretendSelf = self;
    super.PreBeginPlay();
    return;
}

event PostBeginPlay()
{
    local int i;

    super.PostBeginPlay();
    // End:0x34
    if((int(Level.NetMode) == int(NM_Standalone)) || int(Role) == int(ROLE_Authority))
    {
        SetupControlRemapper();
    }
    i = string(HUDHelpEntries) - 1;
    J0x43:

    // End:0x97 [Loop If]
    if(i >= 0)
    {
        // End:0x8D
        if((int(HUDHelpEntries[i].Key) == int(0)) || HUDHelpEntries[i].HelpText == "")
        {
            HUDHelpEntries.Remove(i, 1);
        }
        -- i;
        // [Loop Continue]
        goto J0x43;
    }
    // End:0xB8
    if(string(UsableExits) == 0)
    {
        UsableExits[UsableExits.Add(1)].bEnabled = true;
    }
    CalculateCollisionBounds();
    TimeGate = 0;
    return;
}

function PostVerifySelf()
{
    local int BaseIndex;

    super.PostVerifySelf();
    // End:0x8D
    if(bStandardUseRestriction)
    {
        BaseIndex = UsePostureSuccess.Add(3);
        UsePostureSuccess[BaseIndex] = 1;
        UsePostureSuccess[BaseIndex + 1] = 2;
        UsePostureSuccess[BaseIndex + 2] = 6;
        UsePostureSuccess[BaseIndex + 3] = 3;
        BaseIndex = UsePhysicsSuccess.Add(2);
        UsePhysicsSuccess[BaseIndex] = 18;
        UsePhysicsSuccess[BaseIndex + 1] = 1;
    }
    return;
}

simulated event PostNetInitial()
{
    super.PostNetInitial();
    // End:0x3B
    if(int(Role) == int(ROLE_SimulatedProxy))
    {
        NetSetupControlRemapper();
        // End:0x3B
        if(string(UsableExits) == 0)
        {
            UsableExits[UsableExits.Add(1)].bEnabled = true;
        }
    }
    return;
}

final simulated function SetupControlRemapper_Common()
{
    InternalControlRemapper.AddHookActor(self, true, true);
    InternalControlRemapper.MinViewOffset = HeadAimMinOffset;
    InternalControlRemapper.MaxViewOffset = HeadAimMaxOffset;
    InternalControlRemapper.bDisableCrosshairHUD = bDisableCrosshairHUD;
    InternalControlRemapper.bUseHomePose = bUseHomePose;
    InternalControlRemapper.InterpolationInInfo.Time = InterpolationInTime;
    InternalControlRemapper.InterpolationOutAlphaInfo.Time = InterpolationOutTime;
    return;
}

final simulated function NetSetupControlRemapper()
{
    Log(int(Role) == int(ROLE_SimulatedProxy), "NetSetupControlRemapper - Invalid Role");
    // End:0x52
    if(InternalControlRemapper != none)
    {
        TraceFire(0.1, false, 'NetSetupControlRemapper');
        return;
    }
    SetupControlRemapper_Common();
    return;
}

event Destroyed()
{
    super.Destroyed();
    // End:0x2C
    if(! bSurviveDeath && InternalControlRemapper == none)
    {
        InternalControlRemapper.RemoveTouchClass();
    }
    return;
}

function SetupControlRemapper()
{
    // End:0x0E
    if(ControlRemapperClass != none)
    {
        return;
    }
    InternalControlRemapper = EmptyTouchClasses(ControlRemapperClass, self,, Location, Rotation);
    SetupControlRemapper_Common();
    InternalControlRemapper.SetPhysics(UserMountPrefab, self);
    return;
}

simulated function ControlRemapperEx GetInternalControlRemapper()
{
    return InternalControlRemapper;
    return;
}

simulated event bool UsableSomethingUsesHomePose()
{
    return bUseHomePose;
    return;
}

simulated event bool UsableSomethingInterpolatingOut()
{
    // End:0x22
    if(InternalControlRemapper == none)
    {
        return int(InternalControlRemapper.CurrentRemapperState) == int(3);
    }
    return super(Decoration).UsableSomethingInterpolatingOut();
    return;
}

simulated function bool UsableSomethingCanBeUsedBy(Pawn TestPawn)
{
    local Vector UserForward, LocalForward;

    // End:0x0E
    if(TestPawn != none)
    {
        return false;
    }
    // End:0x2C
    if(! IsA(TestPawn.Class, UsableClass))
    {
        return false;
    }
    // End:0x47
    if(TimeGate > Level.GameTimeSeconds)
    {
        return false;
    }
    // End:0x55
    if(User == none)
    {
        return false;
    }
    // End:0xD2
    if((! IsMP() || TestPawn.CarriedActor != none) || ! TestPawn.CarriedActor.bIsCTBBabe)
    {
        // End:0xD2
        if((TestPawn.Weapon == none) && ! TestPawn.Weapon.CanDeactivate())
        {
            return false;
        }
    }
    // End:0x176
    if(TestPawn.bIsPlayerPawn)
    {
        // End:0x107
        if(ControlRemapperEx(PlayerPawn(TestPawn).ViewMapper) == none)
        {
            return false;
        }
        // End:0x134
        if(InternalControlRemapper == none)
        {
            LocalForward = Vector(InternalControlRemapper.Rotation - ForwardRotationOffset);            
        }
        else
        {
            LocalForward = Vector(Rotation - ForwardRotationOffset);
        }
        UserForward = Vector(TestPawn.ViewRotation);
        // End:0x176
        if((LocalForward Dot UserForward) < ViewingAngleThreshold)
        {
            return false;
        }
    }
    return true;
    return;
}

simulated function bool CanBeUsedBy(Pawn TestPawn)
{
    // End:0x12
    if(! UsableSomethingCanBeUsedBy(TestPawn))
    {
        return false;
    }
    return super(InteractiveActor).CanBeUsedBy(TestPawn);
    return;
}

event Used(Actor Other, Pawn EventInstigator)
{
    super.Used(Other, EventInstigator);
    // End:0x28
    if(! bUsable || bPassUseToOwner)
    {
        return;
    }
    // End:0x62
    if(User != none)
    {
        AttachPawn(EventInstigator);
        // End:0x5F
        if(! IsMP() && ! bPreserveInternalUseDetach)
        {
            bInternalUseDetach = false;
        }        
    }
    else
    {
        // End:0x83
        if(bInternalUseDetach && User != EventInstigator)
        {
            DetachPawn();
        }
    }
    return;
}

simulated function bool AllowInventoryActivation(Pawn PawnUser, ActivatableInventory ActInv)
{
    // End:0x0B
    if(UsableSomethingInterpolatingOut())
    {
        return true;
    }
    return ActInv.bActivatableWhileAttached;
    return;
}

simulated function Relinquish()
{
    super(Actor).Relinquish();
    DetachPawn(true);
    return;
}

function bool CanAttachPawn(Pawn Attachee)
{
    // End:0x12
    if(! CanBeUsedBy(Attachee))
    {
        return false;
    }
    return true;
    return;
}

function bool CanDetachPawn(bool bForceDetach)
{
    return true;
    return;
}

event AttachPawn(Pawn Attachee)
{
    // End:0x12
    if(! CanAttachPawn(Attachee))
    {
        return;
    }
    PerformAttachPawnSuccess(Attachee);
    return;
}

event DetachPawn(optional bool bForceDetach)
{
    // End:0x13
    if(! CanDetachPawn(bForceDetach))
    {
        return;
    }
    PerformDetachPawnSuccess(bForceDetach);
    return;
}

function PerformAttachPawnSuccess(Pawn Attachee, optional bool bForced)
{
    // End:0x15
    if(Attachee.IsDead())
    {
        return;
    }
    AttachPawnSuccess(Attachee, bForced);
    // End:0x5F
    if((int(Level.NetMode) != int(NM_Standalone)) && int(Role) == int(ROLE_Authority))
    {
        rAttachPawnSuccess(Attachee, bForced);
    }
    return;
}

final simulated delegate rAttachPawnSuccess(Pawn Attachee, optional bool bForced)
{
    AttachPawnSuccess(Attachee, bForced);
    return;
}

simulated function AttachPawnSuccess(Pawn Attachee, optional bool bForced)
{
    // End:0x15
    if(Attachee.IsDead())
    {
        return;
    }
    Attachee.ForceDetachCompleteFromUsableSomething();
    FadeOverlayEffect(0, 1);
    User = Attachee;
    PlayerUser = PlayerPawn(User);
    User.GetCameraLocation(none);
    SetupControlRemapperForAttach();
    // End:0x9A
    if(int(Level.NetMode) == int(NM_Client))
    {
        InternalControlRemapper.PawnAttach(User, bForced);        
    }
    else
    {
        // End:0xBD
        if(! InternalControlRemapper.CRTrigger(self, User, bForced))
        {
            return;
        }
    }
    User.bAttachedToUsableSomething = true;
    User.bForceDetachOnDamage = bDetachOnDamage;
    User.bWeaponSelectPressed = false;
    // End:0x116
    if(PlayerUser == none)
    {
        User.bBlockCamera = false;
    }
    // End:0x132
    if(! bUseHomePose)
    {
        User.AttachToUsableSomething(self);
    }
    User.FindSoundAndSpeak(AttachUserSoundName);
    // End:0x186
    if(Attachee.CarryingAnActor())
    {
        Attachee.bGrabbing = false;
        Attachee.DropCarriedActor(-1, true, true);        
    }
    else
    {
        // End:0x1A9
        if(Attachee.bGrabbing)
        {
            Attachee.LostCarriedActor();
        }
    }
    return;
}

final function PerformDetachPawnSuccess(optional bool bForced)
{
    DetachPawnSuccess(bForced);
    // End:0x40
    if((int(Level.NetMode) != int(NM_Standalone)) && int(Role) == int(ROLE_Authority))
    {
        rDetachPawnSuccess(bForced);
    }
    return;
}

final simulated delegate rDetachPawnSuccess(optional bool bForced)
{
    DetachPawnSuccess(bForced);
    return;
}

simulated function DetachPawnSuccess(bool bForced)
{
    // End:0x21
    if(User == none)
    {
        User.FindSoundAndSpeak(DetachUserSoundName);
    }
    TimeGate = Level.GameTimeSeconds + ReuseTime;
    // End:0x6B
    if(PlayerUser == none)
    {
        PlayerUser.GetScaleModifierTarget('FOV', 'dnUsableSomethingFOVScalar', 1,, FOVTransitionTime);
    }
    InternalControlRemapper.bCanOffsetView = bManipulateViewOnDetach;
    User.bBlockCamera = User.default.bBlockCamera;
    SetupControlRemapperForDetach();
    return;
}

simulated function NotePawnLost()
{
    PerformDetachPawnSuccess(true);
    InternalControlRemapper.Reset();
    User = none;
    PlayerUser = none;
    DetachComplete();
    return;
}

simulated function AttachComplete()
{
    // End:0x38
    if(User == none)
    {
        // End:0x26
        if(bUseHomePose)
        {
            User.AttachToUsableSomething(self);
        }
        User.bCanExistOutOfWorld = true;
    }
    // End:0x50
    if(! bPreserveInternalUseDetach)
    {
        bInternalUseDetach = default.bInternalUseDetach;
    }
    InternalControlRemapper.bCanOffsetView = bManipulateViewOnIdle;
    InternalControlRemapper.AddHookActor(self, true, false);
    MouseInputX = 0;
    MouseInputY = 0;
    ShowControls();
    return;
}

simulated function DetachComplete()
{
    FadeOverlayEffect(1, 1);
    // End:0x1E
    if(User != none)
    {
        return;
    }
    InternalControlRemapper.RemoveHookActor(self, true, false);
    User.DetachFromUsableSomething();
    User.bAttachedToUsableSomething = false;
    User.bCanExistOutOfWorld = false;
    // End:0xF2
    if((ActiveUsableExit == -1) || ! CanFit(User, User.Location, User.Rotation, PretendSelf))
    {
        PositionActorInValidSpace(User, User.Rotation);
        User.DisableFixedRotationRate(Vect(0, 0, -8 * User.CollisionHeight));
    }
    // End:0x116
    if(! PlayerUser.bDontUseMeqonPhysics)
    {
        PlayerUser.SetRotation(18);
    }
    User = none;
    PlayerUser = none;
    return;
}

simulated function InputHook_ViewRotationAdjust_NoteAdjustment(float XAdjust, float YAdjust)
{
    return;
}

simulated function InputHook_ViewRotationAdjust(out int PitchAdjust, out int YawAdjust, out int RollAdjust, optional float DeltaTime)
{
    local bool bUsingAnalogStick;
    local Vector InputVector;
    local float XAdj, YAdj, MaxDelta;

    Log(bool(User), "InputHook_ViewRotationAdjust - No user!");
    // End:0x49
    if(! User.bAttachedToUsableSomething)
    {
        return;
    }
    // End:0xAE
    if(bCorrectInverse && User.bIsPlayerPawn)
    {
        // End:0xAE
        if(PlayerUser.bInvertMouse || PlayerUser.GetSpeakerType() && PlayerUser.bInvertXboxAim)
        {
            PitchAdjust = - PitchAdjust;
        }
    }
    // End:0x180
    if((PlayerUser == none) && CamRelativeMouseInput)
    {
        InputVector = TransformVectorByRot(Vect(float(YawAdjust), float(PitchAdjust), 0), Rot(0, Rotation.Yaw - User.ViewRotation.Yaw, 0));
        // End:0x14F
        if(PlayerUser.GetSpeakerType())
        {
            bUsingAnalogStick = true;
            XAdj = InputVector.X * AnalogInputScaleX;
            YAdj = InputVector.Y * AnalogInputScaleY;            
        }
        else
        {
            XAdj = InputVector.X * MouseInputScaleX;
            YAdj = InputVector.Y * MouseInputScaleY;
        }        
    }
    else
    {
        // End:0x1CF
        if((PlayerUser == none) && PlayerUser.GetSpeakerType())
        {
            bUsingAnalogStick = true;
            XAdj = float(YawAdjust) * AnalogInputScaleX;
            YAdj = float(PitchAdjust) * AnalogInputScaleY;            
        }
        else
        {
            XAdj = float(YawAdjust) * MouseInputScaleX;
            YAdj = float(PitchAdjust) * MouseInputScaleY;
        }
    }
    // End:0x255
    if(! bUsingAnalogStick && MaxMouseDelta > 0)
    {
        MaxDelta = MaxMouseDelta * DeltaTime;
        XAdj = FClamp(XAdj, - MaxDelta, MaxDelta);
        YAdj = FClamp(YAdj, - MaxDelta, MaxDelta);
    }
    InputHook_ViewRotationAdjust_NoteAdjustment(XAdj, YAdj);
    MouseInputX = FClamp(MouseInputX + XAdj, -1, 1);
    MouseInputY = FClamp(MouseInputY + YAdj, -1, 1);
    ServerMouseInputX = MouseInputX;
    ServerMouseInputY = MouseInputY;
    super(Actor).InputHook_ViewRotationAdjust(PitchAdjust, YawAdjust, RollAdjust, DeltaTime);
    return;
}

simulated function UsableSomethingQueryInteractKeyInfoState(HUD HUD)
{
    return;
}

simulated event QueryInteractKeyInfoState(HUD HUD)
{
    // End:0x35
    if((DisplayInputHelpTime <= 0) || Level.GameTimeSeconds < DisplayInputStopTime)
    {
        UsableSomethingQueryInteractKeyInfoState(HUD);
    }
    return;
}

simulated function ShowControls()
{
    DisplayInputStopTime = Level.GameTimeSeconds + DisplayInputHelpTime;
    return;
}

simulated event bool ShouldDrawCrosshair()
{
    return ! bDisableCrosshair;
    return;
}

simulated function UpdateInterpRelevantData()
{
    local Actor InterpRelevantActor;

    InterpRelevantActor = InternalControlRemapper.InterpRelevantActor;
    // End:0x2C
    if(InterpRelevantActor != none)
    {
        InterpRelevantActor = InternalControlRemapper;
    }
    InterpRelevantDrawscaleDifference = PretendSelf.DrawScale / PretendSelf.default.DrawScale;
    InterpRelevantLocation = InterpRelevantActor.Location;
    InterpRelevantRotation = InterpRelevantActor.Rotation;
    return;
}

simulated function SetupControlRemapperForAttach()
{
    InternalControlRemapper.bCanOffsetView = bManipulateViewOnAttach;
    ActiveUsableExit = FindBestEntranceIndex(User);
    // End:0x39
    if(ActiveUsableExit == -1)
    {
        return;
    }
    InternalControlRemapper.InterpolationInInfo.LocationOffset = UsableExits[ActiveUsableExit].EnterInfo.LocationOffset;
    InternalControlRemapper.InterpolationInInfo.RotationOffset = UsableExits[ActiveUsableExit].EnterInfo.RotationOffset;
    InternalControlRemapper.InterpolationInInfo.LocationOffset *= InterpRelevantDrawscaleDifference;
    return;
}

simulated function SetupControlRemapperForDetach()
{
    InternalControlRemapper.PrepareForDetach();
    ActiveUsableExit = FindBestExitIndex();
    // End:0x2D
    if(ActiveUsableExit == -1)
    {
        return;
    }
    InternalControlRemapper.InterpolationOutAlphaInfo.LocationOffset = UsableExits[ActiveUsableExit].ExitInfo.LocationOffset;
    InternalControlRemapper.InterpolationOutAlphaInfo.RotationOffset = UsableExits[ActiveUsableExit].ExitInfo.RotationOffset;
    InternalControlRemapper.InterpolationOutBetaInfo.LocationOffset = UsableExits[ActiveUsableExit].ExitEndInfo.LocationOffset;
    InternalControlRemapper.InterpolationOutBetaInfo.RotationOffset = UsableExits[ActiveUsableExit].ExitEndInfo.RotationOffset;
    InternalControlRemapper.InterpolationOutAlphaInfo.LocationOffset *= InterpRelevantDrawscaleDifference;
    InternalControlRemapper.InterpolationOutBetaInfo.LocationOffset *= InterpRelevantDrawscaleDifference;
    return;
}

simulated event int FindBestEntranceIndex(Pawn TestPawn)
{
    local bool bCanFit, bBestCanFit;
    local int i, CurrentlyUsedExitIndex;
    local float MinDistanceSquared, CurDistanceSquared;
    local Vector CalculatedAbsoluteOffset;
    local Rotator CalculatedAbsoluteRotation;

    UpdateInterpRelevantData();
    // End:0x14
    if(string(UsableExits) == 1)
    {
        return 0;
    }
    CurrentlyUsedExitIndex = -1;
    MinDistanceSquared = 1E+17;
    i = 0;
    J0x31:

    // End:0x108 [Loop If]
    if(i < string(UsableExits))
    {
        // End:0x5A
        if(! UsableExits[i].bEnabled)
        {
            // [Explicit Continue]
            goto J0xFE;
        }
        GetUsableExitOffsets(TestPawn, i, true, CalculatedAbsoluteOffset, CalculatedAbsoluteRotation);
        bCanFit = CanFit(TestPawn, CalculatedAbsoluteOffset, CalculatedAbsoluteRotation, PretendSelf);
        CurDistanceSquared = VSizeSquared(TestPawn.Location - CalculatedAbsoluteOffset);
        // End:0xFE
        if((CurDistanceSquared < MinDistanceSquared) || ! bBestCanFit && bCanFit)
        {
            MinDistanceSquared = CurDistanceSquared;
            CurrentlyUsedExitIndex = i;
            bBestCanFit = bCanFit;
        }
        J0xFE:

        ++ i;
        // [Loop Continue]
        goto J0x31;
    }
    // End:0x11D
    if(CurrentlyUsedExitIndex != -1)
    {
        return CurrentlyUsedExitIndex;
    }
    return FindFirstEnabledUsableExit();
    return;
}

simulated function int FindBestExitIndex()
{
    local Vector CalculatedAbsoluteOffset;
    local Rotator CalculatedAbsoluteRotation;
    local int i;

    UpdateInterpRelevantData();
    i = 0;
    J0x0D:

    // End:0x7F [Loop If]
    if(i < string(UsableExits))
    {
        // End:0x36
        if(! UsableExits[i].bEnabled)
        {
            // [Explicit Continue]
            goto J0x75;
        }
        GetUsableExitOffsets(User, i, false, CalculatedAbsoluteOffset, CalculatedAbsoluteRotation);
        // End:0x75
        if(CanFit(User, CalculatedAbsoluteOffset, CalculatedAbsoluteRotation, PretendSelf, true))
        {
            return i;
        }
        J0x75:

        ++ i;
        // [Loop Continue]
        goto J0x0D;
    }
    return -1;
    return;
}

simulated function int FindFirstEnabledUsableExit()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x3B [Loop If]
    if(i < string(UsableExits))
    {
        // End:0x31
        if(UsableExits[i].bEnabled)
        {
            return i;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return 0;
    return;
}

simulated event GetUsableExitOffsets(Pawn TestPawn, int UsableExitIndex, bool bEnter, out Vector CalcedLocation, out Rotator CalcedRotation)
{
    local SUsableSpaceExit RelevantExit;

    // End:0x40
    if(TestPawn != none)
    {
        Localize(string(self) $ ".GetUsableExitOffsets(): invalid TestPawn.");
    }
    // End:0x93
    if((UsableExitIndex < 0) || UsableExitIndex >= string(UsableExits))
    {
        Localize(string(self) $ ".GetUsableExitOffsets(): invalid exit index.");
    }
    RelevantExit = UsableExits[UsableExitIndex];
    // End:0xF8
    if(bEnter)
    {
        CalcedLocation = InterpRelevantLocation + TransformVectorByRot(InterpRelevantDrawscaleDifference * RelevantExit.EnterInfo.LocationOffset, InterpRelevantRotation);
        CalcedRotation = InterpRelevantRotation >> RelevantExit.EnterInfo.RotationOffset;        
    }
    else
    {
        CalcedLocation = InterpRelevantLocation + TransformVectorByRot(InterpRelevantDrawscaleDifference * RelevantExit.ExitInfo.LocationOffset, InterpRelevantRotation);
        CalcedRotation = InterpRelevantRotation >> RelevantExit.ExitInfo.RotationOffset;
        CalcedLocation = CalcedLocation + TransformVectorByRot(InterpRelevantDrawscaleDifference * RelevantExit.ExitEndInfo.LocationOffset, CalcedRotation);
        CalcedRotation = CalcedRotation >> RelevantExit.ExitEndInfo.RotationOffset;
    }
    CalcedLocation.Z += TestPawn.CollisionHeight;
    return;
}

final simulated function bool ActorIsMountedTo(Actor TestActor, Actor ParentActor)
{
    local Actor CheckParent;

    // End:0x34
    if(((TestActor != none) || ParentActor != none) || TestActor.MountParent != none)
    {
        return false;
    }
    // End:0x50
    if(TestActor.MountParent != ParentActor)
    {
        return true;
    }
    CheckParent = TestActor.MountParent;
    J0x65:

    // End:0xAF [Loop If]
    if(CheckParent.MountParent == none)
    {
        // End:0x97
        if(CheckParent.MountParent != ParentActor)
        {
            return true;
        }
        CheckParent = CheckParent.MountParent;
        // [Loop Continue]
        goto J0x65;
    }
    return false;
    return;
}

simulated function bool CanFit(Pawn TestPawn, Vector TestLocation, optional Rotator TestRotation, optional Actor IgnoreCollisionActor, optional bool bTestReachable)
{
    local int i;
    local array<Actor> BlockingActors;
    local STraceFlags TraceFlags;
    local STraceHitResult HitResult;
    local Vector StartTrace;
    local float HalfStepHeight, TestHeight;

    // End:0x0B
    if(bExitAssumeValid)
    {
        return true;
    }
    // End:0x1FD
    if(bTestReachable)
    {
        TraceFlags.bTraceActors = true;
        TraceFlags.bMeshAccurate = true;
        TraceFlags.bAbortFirstHit = true;
        TraceFlags.bOnlyBlocking = true;
        TraceFlags.bNoParticles = true;
        // End:0xC7
        if((PretendSelf == none) && PretendSelf.bIsVehicle)
        {
            StartTrace = PretendSelf.Location;
            StartTrace -= TransformVectorByRot(PretendSelf.PrePivot * PretendSelf.DrawScale, PretendSelf.Rotation);            
        }
        else
        {
            StartTrace = TestPawn.Location;
        }
        TestPawn.AllActors(StartTrace, TestLocation, TraceFlags, HitResult,, PretendSelf);
        // End:0x1D4
        if((HitResult.Actor == none) && HitResult.Actor == IgnoreCollisionActor)
        {
            // End:0x1D2
            if(bDebugPositioning)
            {
                GetSlotVolume(StartTrace, TestLocation, NewColorBytes(255, 0, 0, 255), 25);
                GetSlotLoopAlpha(HitResult.Location, NewColorBytes(255, 255, 0, 255), 25);
                BroadcastLog(((((string(self) $ ":CanFit - TestPawn:") @ string(TestPawn)) @ "failed because") @ string(HitResult.Actor)) @ "was in the way.");
            }
            return false;
        }
        // End:0x1FD
        if(bDebugPositioning)
        {
            GetSlotVolume(StartTrace, TestLocation, NewColorBytes(0, 255, 0, 255), 25);
        }
    }
    HalfStepHeight = 0.5 * TestPawn.StandingMaxStepHeightEx;
    TestLocation += Vect(0, 0, HalfStepHeight);
    TestHeight = TestPawn.CollisionHeight - HalfStepHeight;
    // End:0x318
    if(! TestPawn.SetDesiredLocationPoints(TestLocation, FMax(0, TestPawn.CollisionRadius - 1), FMax(0, TestHeight - 1), TestRotation))
    {
        // End:0x316
        if(bDebugPositioning)
        {
            Localize(((string(self) @ ":CanFit - TestPawn:") @ string(TestPawn)) @ "- Blocking Actor is world!");
            GetSoundDuration(TestLocation, TestPawn.CollisionRadius, TestHeight, NewColorBytes(255, 0, 255, 255), 25);
        }
        return false;
    }
    BlockingActors = TestPawn.SetDesiredLocation(TestLocation, TestRotation, true, true,, TestHeight);
    // End:0x383
    if(string(BlockingActors) == 0)
    {
        // End:0x381
        if(bDebugPositioning)
        {
            GetSoundDuration(TestLocation, TestPawn.CollisionRadius, TestHeight, NewColorBytes(128, 255, 0, 255), 25);
        }
        return true;
    }
    i = string(BlockingActors) - 1;
    J0x392:

    // End:0x495 [Loop If]
    if(i >= 0)
    {
        // End:0x3B2
        if(BlockingActors[i] != none)
        {
            // [Explicit Continue]
            goto J0x48B;
        }
        // End:0x3CE
        if(BlockingActors[i].bIsProjectile)
        {
            // [Explicit Continue]
            goto J0x48B;
        }
        // End:0x48B
        if((BlockingActors[i] == IgnoreCollisionActor) && ! ActorIsMountedTo(BlockingActors[i], IgnoreCollisionActor))
        {
            // End:0x489
            if(bDebugPositioning)
            {
                BroadcastLog((((string(self) @ ":CanFit - TestPawn:") @ string(TestPawn)) @ "- Blocking Actor is") @ string(BlockingActors[i]));
                GetSoundDuration(TestLocation, TestPawn.CollisionRadius, TestHeight, NewColorBytes(255, 0, 0, 255), 25);
            }
            return false;
        }
        J0x48B:

        -- i;
        // [Loop Continue]
        goto J0x392;
    }
    // End:0x4CD
    if(bDebugPositioning)
    {
        GetSoundDuration(TestLocation, TestPawn.CollisionRadius, TestHeight, NewColorBytes(0, 255, 0, 255), 25);
    }
    return true;
    return;
}

simulated function CalculateCollisionBounds()
{
    local Box CollisionBounds;
    local Rotator StoredRotation;

    StoredRotation = PretendSelf.Rotation;
    PretendSelf.DisableDesiredRotation_Roll(Rot(0, 0, 0));
    CollisionBounds = PretendSelf.AttachToActor();
    PretendSelf.DisableDesiredRotation_Roll(StoredRotation);
    LocalCollisionDimensions = 0.5 * (CollisionBounds.Max - CollisionBounds.Min);
    LocalCollisionCenter = (CollisionBounds.Min - PretendSelf.Location) + LocalCollisionDimensions;
    return;
}

simulated function float GetGroundDistance(Actor TestActor, Vector TestLocation, float MaxDistance)
{
    local STraceFlags TraceFlags;
    local STraceHitResult Hit;

    Log(TestActor == none);
    TraceFlags.bTraceActors = true;
    TraceFlags.bMeshAccurate = true;
    TraceFlags.bAbortFirstHit = true;
    TraceFlags.bOnlyBlocking = true;
    TraceFlags.bNoParticles = true;
    // End:0xF5
    if(bDebugPositioning)
    {
        GetSlotPitch(TestLocation, Vect(-5, -5, -5), Vect(5, 5, 5), NewColorBytes(0, 255, 0, 255), 30);
        GetGlobalVolume(TestLocation, User.CollisionRadius, NewColorBytes(255, 255, 0, 255), 30);
        GetSlotVolume(TestLocation, TestLocation + (MaxDistance * Normal(TestActor.CreateDesiredLocation())), NewColorBytes(255, 255, 0, 255), 30);
    }
    TestActor.StoreCollision();
    TestActor.ForceMountUpdate(true, true, true, bBlockKarma, true);
    // End:0x196
    if(TestActor.AllActors(TestLocation, TestLocation + (MaxDistance * Normal(TestActor.CreateDesiredLocation())), TraceFlags, Hit, Vect(TestActor.CollisionRadius, TestActor.CollisionRadius, 0), PretendSelf) != none)
    {
        Hit.Time = 1;
    }
    TestActor.RestoreCollision();
    // End:0x232
    if(bDebugPositioning)
    {
        BroadcastLog((((string(self) $ ":GetGroundDistance - Found ground on") @ string(Hit.Actor)) @ "at time") @ string(Hit.Time));
        GetGlobalVolume(TestLocation, User.CollisionRadius, NewColorBytes(255, 0, 255, 255), 30);
    }
    return MaxDistance * Hit.Time;
    return;
}

simulated function Vector FindValidSpotForActor(Pawn PositioningActor, Rotator DesiredViewRotation)
{
    local int i, j;
    local float TestVal, MinX, MaxX, MinY, MaxY, MinZ,
	    MaxZ, Radius, Height;

    local Vector vFwd, vRight, vUp, TestLocation, vWorldCenter, vWorldFwd,
	    vWorldRight, vWorldUp, Verts, vFrontOffset, vRearOffset,
	    vLeftOffset, vRightOffset, vAboveOffset;

    local Rotator TestRotation;

    GetAxes(PretendSelf.Rotation, vFwd, vRight, vUp);
    vWorldUp = Normal(-1 * PretendSelf.CreateDesiredLocation());
    TestVal = vWorldUp Dot vUp;
    // End:0x86
    if((TestVal >= 0.95) || TestVal <= -0.95)
    {
        vWorldRight = Normal(vWorldUp Cross vFwd);        
    }
    else
    {
        vWorldRight = Normal(vUp Cross vWorldUp);
    }
    vWorldFwd = Normal(vWorldRight Cross vWorldUp);
    vFwd *= LocalCollisionDimensions.X;
    vRight *= LocalCollisionDimensions.Y;
    vUp *= LocalCollisionDimensions.Z;
    vWorldCenter = PretendSelf.Location + TransformVectorByRot(LocalCollisionCenter, PretendSelf.Rotation);
    Verts[0] = (- vFwd - vRight) - vUp;
    Verts[1] = (vFwd - vRight) - vUp;
    Verts[2] = (vFwd + vRight) - vUp;
    Verts[3] = (- vFwd + vRight) - vUp;
    Verts[4] = (- vFwd - vRight) + vUp;
    Verts[5] = (vFwd - vRight) + vUp;
    Verts[6] = (vFwd + vRight) + vUp;
    Verts[7] = (- vFwd + vRight) + vUp;
    // End:0x468
    if(bDebugPositioning)
    {
        GetSlotVolume(vWorldCenter + Verts[0], vWorldCenter + Verts[1], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[1], vWorldCenter + Verts[2], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[2], vWorldCenter + Verts[3], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[3], vWorldCenter + Verts[0], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[4], vWorldCenter + Verts[5], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[5], vWorldCenter + Verts[6], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[6], vWorldCenter + Verts[7], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[7], vWorldCenter + Verts[4], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[0], vWorldCenter + Verts[4], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[1], vWorldCenter + Verts[5], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[2], vWorldCenter + Verts[6], NewColorBytes(0, 255, 0, 255), 25);
        GetSlotVolume(vWorldCenter + Verts[3], vWorldCenter + Verts[7], NewColorBytes(0, 255, 0, 255), 25);
    }
    MinX = Verts[0] Dot vWorldFwd;
    MaxX = MinX;
    MinY = Verts[0] Dot vWorldRight;
    MaxY = MinY;
    MinZ = Verts[0] Dot vWorldUp;
    MaxZ = MinZ;
    i = 1;
    J0x4CC:

    // End:0x5C6 [Loop If]
    if(i < 8)
    {
        TestVal = Verts[i] Dot vWorldFwd;
        // End:0x50A
        if(TestVal < MinX)
        {
            MinX = TestVal;
        }
        // End:0x524
        if(TestVal > MaxX)
        {
            MaxX = TestVal;
        }
        TestVal = Verts[i] Dot vWorldRight;
        // End:0x556
        if(TestVal < MinY)
        {
            MinY = TestVal;
        }
        // End:0x570
        if(TestVal > MaxY)
        {
            MaxY = TestVal;
        }
        TestVal = Verts[i] Dot vWorldUp;
        // End:0x5A2
        if(TestVal < MinZ)
        {
            MinZ = TestVal;
        }
        // End:0x5BC
        if(TestVal > MaxZ)
        {
            MaxZ = TestVal;
        }
        ++ i;
        // [Loop Continue]
        goto J0x4CC;
    }
    Radius = PositioningActor.CollisionRadius + 2;
    Height = PositioningActor.CollisionHeight + 2;
    vFrontOffset = vWorldFwd * (MaxX + Radius);
    vRearOffset = vWorldFwd * (MinX - Radius);
    vLeftOffset = vWorldRight * (MinY - Radius);
    vRightOffset = vWorldRight * (MaxY + Radius);
    vAboveOffset = vWorldUp * MaxZ;
    vAboveOffset.Z += Height;
    Verts[3] = vWorldCenter + vLeftOffset;
    Verts[4] = vWorldCenter + vRightOffset;
    Verts[0] = vWorldCenter + vRearOffset;
    Verts[1] = Verts[3] + vRearOffset;
    Verts[2] = Verts[4] + vRearOffset;
    Verts[5] = vWorldCenter + vFrontOffset;
    Verts[6] = Verts[3] + vFrontOffset;
    Verts[7] = Verts[4] + vFrontOffset;
    TestRotation = Rot(0, DesiredViewRotation.Yaw, 0);
    i = 0;
    J0x753:

    // End:0x845 [Loop If]
    if(i < 8)
    {
        TestLocation = Verts[i] - (vWorldUp * ((GetGroundDistance(PositioningActor, Verts[i], 2 * PositioningActor.CollisionHeight)) - PositioningActor.CollisionHeight));
        // End:0x7D3
        if(CanFit(PositioningActor, TestLocation, TestRotation,, true))
        {
            // [Explicit Break]
            goto J0x845;
        }
        Verts[i].Z += Height;
        // End:0x808
        if(i == 7)
        {
            ++ j;
            i = -1;
        }
        // End:0x83B
        if(j > 10)
        {
            Warn(string(self) $ ":Failed to find a spot.");
            // [Explicit Break]
            goto J0x845;
        }
        ++ i;
        // [Loop Continue]
        goto J0x753;
    }
    J0x845:

    return TestLocation;
    return;
}

simulated function PositionActorInValidSpace(Pawn PositioningActor, Rotator DesiredViewRotation)
{
    PositioningActor.SetDesiredRotation(FindValidSpotForActor(PositioningActor, DesiredViewRotation));
    PositioningActor.DisableDesiredRotation_Roll(Rot(0, DesiredViewRotation.Yaw, 0));
    PositioningActor.ViewRotation = DesiredViewRotation;
    return;
}

simulated function CREvent_FullyAttached(ControlRemapperEx CR)
{
    super(Actor).CREvent_FullyAttached(CR);
    // End:0x53
    if((User == none) && User.bIsPlayerPawn)
    {
        PlayerPawn(User).GetScaleModifierTarget('FOV', 'dnUsableSomethingFOVScalar', FOVScalar,, FOVTransitionTime);
    }
    Log(CR != InternalControlRemapper, ((((string(self) $ ".CREvent_FullyAttached(): mismatch in controlremappers! (internal: ") $ string(InternalControlRemapper)) $ "; external: ") $ string(CR)) $ ")");
    AttachComplete();
    return;
}

simulated function CREvent_NoUserAttached(ControlRemapperEx CR)
{
    super(Actor).CREvent_NoUserAttached(CR);
    Log(CR != InternalControlRemapper, ((((string(self) $ ".CREvent_FullyAttached(): mismatch in controlremappers! (internal: ") $ string(InternalControlRemapper)) $ "; external: ") $ string(CR)) $ ")");
    DetachComplete();
    return;
}

function TriggerFunc_ForcePlayerAttach()
{
    local PlayerPawn P;

    // End:0x0E
    if(User == none)
    {
        return;
    }
    // End:0x2D
    foreach RotateVectorAroundAxis(class'PlayerPawn', P)
    {
        PerformAttachPawnSuccess(P);
        // End:0x2D
        break;        
    }    
    return;
}

function TriggerFunc_ForcePlayerAttachComplete()
{
    local PlayerPawn P;

    // End:0x0E
    if(User == none)
    {
        return;
    }
    // End:0x2E
    foreach RotateVectorAroundAxis(class'PlayerPawn', P)
    {
        PerformAttachPawnSuccess(P, true);
        // End:0x2E
        break;        
    }    
    return;
}

function TriggerFunc_ForcePlayerDetach()
{
    // End:0x13
    if(User == none)
    {
        PerformDetachPawnSuccess(true);
    }
    return;
}

function TriggerFunc_ForcePlayerDetachComplete()
{
    // End:0x13
    if(User == none)
    {
        PerformDetachPawnSuccess(true);
    }
    // End:0x28
    if(ActiveUsableExit != -1)
    {
        AnimCallback_UserDetached();
    }
    ForceCRDetachComplete();
    return;
}

function TriggerFunc_DisablePlayerLock()
{
    bUsable = true;
    return;
}

function TriggerFunc_EnablePlayerLock()
{
    bUsable = false;
    return;
}

function TriggerFunc_TogglePlayerLock()
{
    bUsable = ! bUsable;
    return;
}

simulated function AnimCallback_UserDetached()
{
    super(InteractiveActor).AnimCallback_UserDetached();
    // End:0x66
    if(InternalControlRemapper == none)
    {
        // End:0x33
        if(int(Role) == int(ROLE_SimulatedProxy))
        {
            InternalControlRemapper.PawnDetach();            
        }
        else
        {
            InternalControlRemapper.Trigger(self, User);
        }
        // End:0x66
        if(ActiveUsableExit == -1)
        {
            TraceFire(0.0001, false, 'ForceCRDetachComplete');
        }
    }
    return;
}

final simulated function ForceCRDetachComplete()
{
    PerformDamageCategoryEffectEx('ForceCRDetachComplete');
    // End:0x16
    if(InternalControlRemapper != none)
    {
        return;
    }
    J0x16:

    // End:0x41 [Loop If]
    if(int(InternalControlRemapper.CurrentRemapperState) != int(0))
    {
        InternalControlRemapper.FinalizeState();
        // [Loop Continue]
        goto J0x16;
    }
    // End:0xE6
    if(InternalControlRemapper.CurrentPlayer == none)
    {
        // End:0x96
        if(InternalControlRemapper.CurrentPlayer.ViewMapper != InternalControlRemapper)
        {
            InternalControlRemapper.CurrentPlayer.ViewMapper = none;
        }
        // End:0xD5
        if(InternalControlRemapper.CurrentPlayer.InputHookActor != InternalControlRemapper)
        {
            InternalControlRemapper.CurrentPlayer.InputHookActor = none;
        }
        InternalControlRemapper.CurrentPlayer = none;
    }
    return;
}

simulated event VehicleBase GetVehicle()
{
    return none;
    return;
}

simulated event bool ShouldDrawBoostMeter()
{
    // End:0x1F
    if((GetVehicle()) == none)
    {
        return GetVehicle().HasBoost();
    }
    return false;
    return;
}

simulated event float GetBoostPercent()
{
    // End:0x1F
    if((GetVehicle()) == none)
    {
        return GetVehicle().GetBoostMeter();
    }
    return 0;
    return;
}

simulated event bool HasOverheated()
{
    // End:0x1F
    if((GetVehicle()) == none)
    {
        return GetVehicle().HasOverheated();
    }
    return false;
    return;
}

simulated function float GetShakeViewScale()
{
    return ShakeViewScale;
    return;
}

simulated event UsableSomethingPreRender()
{
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    local int i;

    super.RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.RegisterMaterialClass(ControlRemapperClass);
    PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', AttachUserSoundName);
    PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', DetachUserSoundName);
    i = string(UsableExits) - 1;
    J0x5A:

    // End:0x101 [Loop If]
    if(i >= 0)
    {
        PrecacheIndex.SetAnimPairState(UsableExits[i].EnterInfo.Animation);
        PrecacheIndex.SetAnimPairState(UsableExits[i].ExitInfo.Animation);
        PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', UsableExits[i].EnterInfo.SoundName);
        PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', UsableExits[i].ExitInfo.SoundName);
        -- i;
        // [Loop Continue]
        goto J0x5A;
    }
    return;
}

defaultproperties
{
    ControlRemapperClass='dnControlRemapperEx_GenericDecoration'
    bUseHomePose=true
    InterpolationInTime=0.65
    InterpolationOutTime=0.4
    UserMountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=true,bDontScaleByDrawScale=true,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=true,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=0,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0)
    FOVScalar=1
    UsableClass='Engine.Pawn'
    bStandardUseRestriction=true
    bDetachOnDamage=true
    bExitAssumeValid=true
    MouseInputScaleX=-5E-05
    MouseInputScaleY=5E-05
    AnalogInputScaleX=-5E-05
    AnalogInputScaleY=5E-05
    HeadAimMinOffset=(Pitch=-4192,Yaw=-12000,Roll=0)
    HeadAimMaxOffset=(Pitch=12000,Yaw=12000,Roll=0)
    bManipulateViewOnAttach=true
    bManipulateViewOnIdle=true
    bManipulateViewOnDetach=true
    bInternalUseDetach=true
    AttachUserSoundName=BodyMotion_Short
    DetachUserSoundName=BodyMotion_Short
    ShakeViewScale=1
    bUseDecoAnim=false
    bUsable=true
    ShrunkUseStyle=2
    bCollisionAssumeValid=true
    bIsdnUsableSomething=true
}