/*******************************************************************************
 * DukeBot generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class DukeBot extends DukeMultiplayerAssets
    config(User)
    collapsecategories;

var Vector NextPathPos;
var Vector PathDestination;
var Vector LastLocation;
var float StuckTime;
var bool bNeverMelee;
var bool bAllowGodMode;
var bool bAllowInfiniteAmmo;
var bool bStopFiring;
var bool bPickupLock;
var float FireWaitTime;
var float FireDelayTime;
var float PipeBombFrequency;
var float TripMineFrequency;
var float BeerFrequency;
var float SteroidsFrequency;
var float JetpackFrequency;
var float HolodukeFrequency;
var float DuckFrequency;
var float JumpFrequency;
var bool bAICanPickupStuff;
var bool bAllowMelee;

simulated event PreBeginPlay()
{
    super(PlayerPawn).PreBeginPlay();
    NextPathPos = Location;
    return;
}

function Restart()
{
    local bool bOnlyAmmo;

    super(DukeMultiPlayer).Restart();
    // End:0x16
    if(int(Role) < int(ROLE_Authority))
    {
        return;
    }
    bOnlyAmmo = false;
    bCheatsEnabled = true;
    bAdmin = true;
    bInfiniteAmmo = true;
    switch(Rand(11))
    {
        // End:0x67
        case 0:
            GiveWeaponCheat("dnGame.MP_Pistol_Gold", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x8D
        case 1:
            GiveWeaponCheat("dnGame.MP_RailGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xB0
        case 2:
            GiveWeaponCheat("dnGame.MP_RPG", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xDA
        case 3:
            GiveWeaponCheat("dnGame.MP_Devastator", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x103
        case 4:
            GiveWeaponCheat("dnGame.MP_ShrinkRay", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x12C
        case 5:
            GiveWeaponCheat("dnGame.MP_FreezeRay", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x153
        case 6:
            GiveWeaponCheat("dnGame.MP_ATLaser", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x17E
        case 7:
            GiveWeaponCheat("dnGame.MP_EnforcerGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1AC
        case 8:
            GiveWeaponCheat("dnGame.MP_ATCaptainLaser", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1D3
        case 9:
            GiveWeaponCheat("dnGame.MP_Shotgun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1FD
        case 10:
            GiveWeaponCheat("dnGame.MP_MachineGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xFFFF
        default:
            break;
    }
    GiveRandomInventoryMP(0.5, 0.5, 0.5, 0.5);
    TraceFire(FRand() * PipeBombFrequency, false, 'PipeBombUse');
    TraceFire(FRand() * TripMineFrequency, false, 'TripMineUse');
    TraceFire(FRand() * BeerFrequency, false, 'FortyOunceBeerUse');
    TraceFire(FRand() * SteroidsFrequency, false, 'SteroidsUse');
    TraceFire(FRand() * JetpackFrequency, false, 'JetpackUse');
    TraceFire(FRand() * HolodukeFrequency, false, 'HolodukeUse');
    TraceFire(FRand() * DuckFrequency, false, 'DuckUse');
    TraceFire(FRand() * JumpFrequency, false, 'JumpUse');
    return;
}

function DiedActivity(optional Pawn Killer, optional int Damage, optional Vector DamageOrigin, optional Vector DamageDirection, optional class<DamageType> DamageType, optional name HitBoneName)
{
    super(DukeMultiPlayer).DiedActivity(Killer, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName);
    Target = none;
    return;
}

simulated function bool WantsToFire(Weapon W)
{
    // End:0x2A
    if((int(Role) == int(ROLE_AutonomousProxy)) || int(RemoteRole) == int(ROLE_AutonomousProxy))
    {
        return super(DukeMultiPlayer).WantsToFire(W);
    }
    // End:0x35
    if(bStopFiring)
    {
        return false;
    }
    // End:0x5D
    if(bAllowInfiniteAmmo)
    {
        bInfiniteAmmo = Level.TickHint().bInfiniteAmmo;
    }
    return ((Weapon != W) && Target == none) && ! WantsToMelee(W);
    return;
}

function bool ImmuneToDamage()
{
    // End:0x28
    if(bAllowGodMode && Level.TickHint().bGodMode)
    {
        return true;
    }
    return super(DukePlayer).ImmuneToDamage();
    return;
}

simulated function bool WantsToMelee(Weapon W)
{
    local float MinRadiusSq;

    // End:0x20
    if(! bAllowMelee || MP_FreezeRay(Weapon) == none)
    {
        return false;
    }
    // End:0x4A
    if((int(Role) == int(ROLE_AutonomousProxy)) || int(RemoteRole) == int(ROLE_AutonomousProxy))
    {
        return super(PlayerPawn).WantsToMelee(W);
    }
    // End:0x55
    if(bNeverMelee)
    {
        return false;
    }
    // End:0xBC
    if((Weapon != W) && Target == none)
    {
        MinRadiusSq = Square((CollisionRadius + Target.CollisionRadius) + 60);
        // End:0xBC
        if(VSizeSquared(Location - Target.Location) <= MinRadiusSq)
        {
            return true;
        }
    }
    return false;
    return;
}

function bool ShouldInputWakePlayerPhysics()
{
    return true;
    return;
}

function AdditionalAI()
{
    // End:0x3E
    if(bAICanPickupStuff)
    {
        // End:0x3E
        if((TouchingWeaponPickup == none) && ! bPickupLock)
        {
            ServerUseDown();
            bPickupLock = true;
            TraceFire(3, false, 'PickupTimer');
        }
    }
    return;
}

simulated function bool CanBeUsedBy(Pawn TestPawn)
{
    // End:0x1C
    if(CanBeExecutedBy(TestPawn))
    {
        Used(self, TestPawn);
        return true;
    }
    return super(DukePlayer).CanBeUsedBy(TestPawn);
    return;
}

function PipeBombUse()
{
    local ActivatableInventory D;

    UseWeapon("dnGame.PipeBomb");
    TraceFire(FRand() * PipeBombFrequency, false, 'PipeBombUse');
    // End:0x64
    if(FRand() > 0.5)
    {
        D = ActivatableInventory(PhysController_SetConstraintStrength('MP_Detonator'));
        // End:0x64
        if(D == none)
        {
            ChangeToWeapon(MP_Detonator(D));
        }
    }
    return;
}

function TripMineUse()
{
    UseWeapon("dnGame.TripMine");
    TraceFire(FRand() * TripMineFrequency, false, 'TripMineUse');
    return;
}

function FortyOunceBeerUse()
{
    UseWeapon("dnGame.FortyOunceBeer");
    TraceFire(FRand() * BeerFrequency, false, 'FortyOunceBeerUse');
    return;
}

function SteroidsUse()
{
    UseWeapon("dnGame.Steroids");
    TraceFire(FRand() * SteroidsFrequency, false, 'SteroidsUse');
    return;
}

function JetpackUse()
{
    DoJetpack();
    TraceFire(FRand() * JetpackFrequency, false, 'JetpackUse');
    return;
}

function DuckUse()
{
    DuckDown();
    TraceFire(FRand() * 1, false, 'DuckUpUse');
    return;
}

function DuckUpUse()
{
    DuckUp();
    TraceFire(FRand() * DuckFrequency, false, 'DuckUse');
    return;
}

function JumpUse()
{
    JumpDown();
    TraceFire(FRand() * 1, false, 'JumpUpUse');
    return;
}

function JumpUpUse()
{
    JumpUp();
    TraceFire(FRand() * JumpFrequency, false, 'JumpUpUse');
    return;
}

function HolodukeUse()
{
    local Pawn P;
    local bool bFail;

    P = Level.PawnList;
    J0x15:

    // End:0x8A [Loop If]
    if(P == none)
    {
        // End:0x72
        if(DukeMultiPlayer(P) == none)
        {
            // End:0x72
            if((DukeMultiPlayer(P).ActiveHoloActor == none) || DukeMultiPlayer(P).ActiveHoloDuke == none)
            {
                bFail = true;
            }
        }
        P = P.NextPawn;
        // [Loop Continue]
        goto J0x15;
    }
    // End:0x9B
    if(! bFail)
    {
        DoHoloDuke();
    }
    TraceFire(FRand() * HolodukeFrequency, false, 'HolodukeUse');
    return;
}

simulated function PickupTimer()
{
    bPickupLock = false;
    return;
}

simulated event Tick(float DeltaTime)
{
    super(DukeMultiPlayer).Tick(DeltaTime);
    AdditionalAI();
    // End:0x35
    if(bDontUseMeqonPhysics && int(RemoteRole) != int(ROLE_AutonomousProxy))
    {
        CalculatePawnPhysics(DeltaTime);
    }
    return;
}

function bool IsValidKillTarget(Actor NewTarget)
{
    // End:0x13
    if(DukeMultiPlayer(NewTarget) != none)
    {
        return false;
    }
    return IsEnemyTo(Pawn(NewTarget));
    return;
}

simulated event CalculatePawnPhysics(float DeltaTime)
{
    local Vector TargetLoc, RelativeMovementDir, X, Y, Z;

    local int FinalDest;
    local Rotator DesiredViewRotation;

    // End:0x4A
    if(VSizeSquared(Location - LastLocation) < float(1))
    {
        StuckTime += DeltaTime;
        // End:0x47
        if(StuckTime > float(10))
        {
            TraceFire(1E-05, false, 'Suicide');
            StuckTime = 0;
        }        
    }
    else
    {
        StuckTime = 0;
    }
    // End:0x6D
    if(int(RemoteRole) == int(ROLE_AutonomousProxy))
    {
        CanSprint(DeltaTime);
        return;
    }
    // End:0xD4
    if(int(Role) == int(ROLE_AutonomousProxy))
    {
        // End:0xD1
        if(! bStopFiring)
        {
            FireWaitTime += DeltaTime;
            // End:0xC2
            if(! bIFire && FireWaitTime > FireDelayTime)
            {
                FireWaitTime = 0;
                FireDown();                
            }
            else
            {
                // End:0xD1
                if(bIFire)
                {
                    FireUp();
                }
            }
        }        
    }
    else
    {
        // End:0x139
        if((Weapon == none) && Weapon.IsXbox() != 'idle')
        {
            // End:0x11B
            if(WantsToFire(Weapon))
            {
                Weapon.AttemptFire();                
            }
            else
            {
                // End:0x139
                if(WantsToMelee(Weapon))
                {
                    Weapon.AttemptMelee();
                }
            }
        }
    }
    // End:0x17B
    if(((Target == none) && Target.bIsPawn) && Pawn(Target).IsDead())
    {
        Target = none;
    }
    // End:0x205
    if(Target != none)
    {
        // End:0x1FA
        if(Level.GRI == none)
        {
            Target = Level.GRI.PRIArray[Rand(string(Level.GRI.PRIArray))].Owner;
            // End:0x1FA
            if(! IsValidKillTarget(Target))
            {
                Target = none;
            }
        }
        NextPathPos = Location;
    }
    // End:0x245
    if(Target == none)
    {
        PathDestination = Target.Location;
        // End:0x245
        if(! CanBreatheNormally(PathDestination, false, NextPathPos, FinalDest))
        {
            Target = none;
        }
    }
    TargetLoc = NextPathPos;
    // End:0x26F
    if(Target == none)
    {
        TargetLoc = Target.SetSlotVisFalloffRate();
    }
    DesiredViewRotation = Rotator(Normal(TargetLoc - SetDestinationActor()));
    ViewRotation = Slerp(FMin(1, DeltaTime * 10), ViewRotation, DesiredViewRotation);
    DisableDesiredRotation_Roll(Rot(Rotation.Pitch, ViewRotation.Yaw, Rotation.Roll));
    CalcedViewRotation = ViewRotation;
    GetAxes(Rotation, X, Y, Z);
    RelativeMovementDir = NextPathPos - Location;
    RelativeMovementDir.Z = 0;
    // End:0x367
    if(VSizeSquared(RelativeMovementDir) > 0)
    {
        RelativeMovementDir = Normal(RelativeMovementDir);
        aForward = RelativeMovementDir Dot X;
        aStrafe = RelativeMovementDir Dot Y;
        aUp = RelativeMovementDir Dot Z;        
    }
    else
    {
        aForward = 0;
        aStrafe = 0;
        aUp = 0;
    }
    AnalogInputByte = CompressAnalog(aForward, aStrafe);
    DecompressAnalog(AnalogInputByte, aForward, aStrafe);
    CanSprint(DeltaTime);
    LastLocation = Location;
    return;
}

defaultproperties
{
    PipeBombFrequency=5
    TripMineFrequency=5
    BeerFrequency=5
    SteroidsFrequency=5
    JetpackFrequency=5
    HolodukeFrequency=5
    DuckFrequency=5
    JumpFrequency=5
    bAICanPickupStuff=true
    bAllowMelee=true
    bIsBot=true
    CollisionRadius=18
    CollisionHeight=39
}