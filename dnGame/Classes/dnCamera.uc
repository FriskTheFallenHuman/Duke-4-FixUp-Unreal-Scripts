/*******************************************************************************
 * dnCamera generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class dnCamera extends dnCamera_NativeBase
    collapsecategories
    dependson(dnCameraBroken)
    dependson(dnControl_CameraViewer);

enum ECameraMounting
{
    CAMERAMOUNT_Wall,
    CAMERAMOUNT_Ceiling
};

enum ECameraMotion
{
    CAMERAMOTION_Pitch,
    CAMERAMOTION_Yaw,
    CAMERAMOTION_Deprecated_1,
    CAMERAMOTION_Deprecated_2,
    CAMERAMOTION_None
};

var(dnCameraEvents) noexport name FirstLookThroughEvent "One-time event for the first time the player looks through the camera.";
var(dnCameraEvents) noexport name LookThroughEvent "Event that is fired every time the player switches to this camera view.";
var(dnCameraEvents) noexport name UnLookThroughEvent "Event that is fired every time the player switches *from* this camera view or otherwise stops looking through it.";
var(dnCameraEvents) name SE_CameraDestroy;
var(dnCameraEvents) name SE_CameraActivate;
var(dnCameraEvents) name SE_CameraDeactivate;
var(dnCameraEvents) name SE_CameraToggleActivate;
var() noexport Rotator rViewConstraints "Maximum angle change around each axis from starting position. (-1 = no constraint)";
var Rotator rViewConstraintsInternal;
var() noexport Rotator rStartingView "Angle of camera (pitch/yaw) relative to angle of stand at start (not in degrees anymore! haha!).";
var() noexport dnCamera.ECameraMotion CameraMotion "How does this camera automatically patrol?";
var() noexport dnCamera.ECameraMounting CameraMounting "Mounting type (camera attached to wall or ceiling)";
var() noexport deprecated name NextCamera "Tag of the next camera in the series.";
var() noexport deprecated name PrevCamera "Tag of the previous camera in the series. (currently unused)";
var() noexport class<dnCameraBroken> classBroken "Broken version of this camera class.";
var() noexport float BaseCameraFOV "FOV to use for RenderTarget.  Modified by current FOV scale.";
var() noexport string CameraFOVStrings[3] "\"4X ZOOM\", etc.";
var() noexport int CameraID "ID number of camera (must be one digit).";
var() noexport string CameraDescription "Description/location string of camera.";
var() noexport bool bAlert "Will the camera look around (within constraints) on its own?";
var bool bArmed;
var() bool bInvulernable;
var() class<TraceDamageType> TraceDamageType;
var bool bLookedThrough;
var() bool bDestroyed;
var bool bFiring;
var() bool bMoving;
var int iZoomMode;
var float fCurrentAngleModifier;
var float fStallTimer;
var int iDamagePerShot;
var Rotator rLastRotation;
var Rotator rServerViewAngles;
var Rotator rTargetDeathBoneRotation;
var float fTimeSinceDeath;
var float fTimeSinceBirth;
var anim name IdleWallAnim;
var anim name IdleCeilingAnim;
var bool bNetTransmitRotation;
var int iNetTransmitTicks;
var int iNetTransmitTicksRemaining;
var float fNetPositionTime;
var DukePlayer Duke;

replication
{
    // Pos:0x000
    reliable if(bNetInitial && int(Role) == int(ROLE_Authority))
        CameraDescription, CameraID, 
        CameraMotion, CameraMounting, 
        NextCamera, PrevCamera, 
        bArmed, rViewConstraints;

    // Pos:0x016
    reliable if(int(Role) == int(ROLE_Authority))
        bFiring, rServerViewAngles;
}

event PreBeginPlay()
{
    GetPointRegion('CameraDestroy', SE_CameraDestroy);
    GetPointRegion('CameraActivate', SE_CameraActivate);
    GetPointRegion('CameraDeactivate', SE_CameraDeactivate);
    GetPointRegion('CameraToggleActivate', SE_CameraToggleActivate);
    super(dnDecoration).PreBeginPlay();
    return;
}

simulated event PostBeginPlay()
{
    super(dnDecoration).PostBeginPlay();
    _InitSelf();
    return;
}

simulated event PostNetInitial()
{
    super(dnDecoration).PostNetInitial();
    _InitSelf();
    return;
}

simulated function _InitSelf()
{
    rViewAngles = rStartingView;
    bNoNativeTick = false;
    bDumbMesh = false;
    // End:0x37
    if(int(CameraMounting) == int(0))
    {
        LoopAnimEx(IdleWallAnim);        
    }
    else
    {
        LoopAnimEx(IdleCeilingAnim);
    }
    GetLastRenderTime();
    bNoNativeTick = true;
    bDumbMesh = true;
    SetScaleModifier();
    SetViewConstraints();
    // End:0xA3
    if((int(Level.NetMode) != int(NM_Standalone)) && int(Role) == int(ROLE_Authority))
    {
        rViewConstraints *= float(256);
        rServerViewAngles = rViewAngles * float(64);
    }
    // End:0xB4
    if(bInvulernable)
    {
        HealthPrefab = 0;
    }
    SetAlertStatus();
    SetViewAngles();
    return;
}

simulated function SetViewConstraints()
{
    // End:0x25
    if(rViewConstraints.Pitch == -1)
    {
        rViewConstraintsInternal.Pitch = 16384;        
    }
    else
    {
        rViewConstraintsInternal.Pitch = rViewConstraints.Pitch;
    }
    // End:0x5F
    if(rViewConstraints.Yaw == -1)
    {
        rViewConstraintsInternal.Yaw = 16384;        
    }
    else
    {
        rViewConstraintsInternal.Yaw = rViewConstraints.Yaw;
    }
    return;
}

simulated function SetAlertStatus()
{
    // End:0x22
    if(int(Level.NetMode) != int(NM_Standalone))
    {
        bAlert = false;
        return;
    }
    // End:0x46
    if(bAlert)
    {
        bNoNativeTick = false;
        bDumbMesh = false;
        Disable('Tick');        
    }
    else
    {
        bNoNativeTick = true;
        bDumbMesh = true;
        GetPropertyText('Tick');
    }
    return;
}

simulated function SetViewAngles()
{
    // End:0x29
    if(int(Level.NetMode) != int(NM_Standalone))
    {
        rViewAngles = rServerViewAngles / float(64);
    }
    return;
}

function dnCamera GetNextCamera()
{
    local dnCamera NextCameraActor;

    // End:0x2A
    if(NameForString(NextCamera, 'None'))
    {
        // End:0x29
        foreach RotateVectorAroundAxis(class'dnCamera', NextCameraActor, NextCamera)
        {
            // End:0x29
            break;            
        }        
    }
    return NextCameraActor;
    return;
}

function dnCamera GetPreviousCamera()
{
    local dnCamera PreviousCameraActor;

    // End:0x2A
    if(NameForString(PrevCamera, 'None'))
    {
        // End:0x29
        foreach RotateVectorAroundAxis(class'dnCamera', PreviousCameraActor, PrevCamera)
        {
            // End:0x29
            break;            
        }        
    }
    return PreviousCameraActor;
    return;
}

simulated event PostNetReceive()
{
    super(Actor).PostNetReceive();
    SetViewAngles();
    SetAlertStatus();
    return;
}

function TriggerFunc_CameraDestroy()
{
    GetStateName('Destruction');
    return;
}

function TriggerFunc_CameraActivate()
{
    bActivated = true;
    return;
}

function TriggerFunc_CameraDeactivate()
{
    bActivated = false;
    return;
}

function TriggerFunc_CameraToggleActivate()
{
    bActivated = ! bActivated;
    return;
}

simulated event bool OnEvalBonesHelper()
{
    local Rotator R;

    R.Pitch = rViewAngles.Pitch;
    MeshInstance.AnimUpdateRate('bone_pitch', R);
    R.Pitch = 0;
    R.Yaw = rViewAngles.Yaw;
    MeshInstance.AnimUpdateRate('bone_yaw', R);
    return true;
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    // End:0x0B
    if(bInvulernable)
    {
        return;
    }
    super(dnDecoration).TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    return;
}

simulated function SetActive(DukePlayer D)
{
    // End:0x12
    if(Duke != D)
    {
        return;
    }
    Duke = D;
    // End:0xB3
    if(D == none)
    {
        // End:0x59
        if(! bLookedThrough)
        {
            // End:0x51
            if(NameForString(FirstLookThroughEvent, 'None'))
            {
                GlobalTrigger(FirstLookThroughEvent,, self);
            }
            bLookedThrough = true;
        }
        // End:0x76
        if(NameForString(LookThroughEvent, 'None'))
        {
            GlobalTrigger(LookThroughEvent,, self);
        }
        ResetZoom();
        SetCurrentZoom();
        AssignAmbientSound();
        bMoving = false;
        bDumbMesh = false;
        bNoNativeTick = false;
        Disable('Tick');
        TickStyle = 3;        
    }
    else
    {
        SetAlertStatus();
        bFiring = false;
        GetAnimGroup(1);
        Spawn('Fire');
        SetAnimFrame(none);
        TickStyle = 2;
        // End:0xF7
        if(NameForString(UnLookThroughEvent, 'None'))
        {
            GlobalTrigger(UnLookThroughEvent,, self);
        }
    }
    return;
}

simulated function RotateBy(out Rotator R)
{
    local Rotator rnull;

    // End:0x23
    if(bDestroyed || ! bActivated)
    {
        R = rnull;
        return;
    }
    // End:0x48
    if(int(Level.NetMode) != int(NM_Standalone))
    {
        R *= 2.2;
    }
    // End:0xE5
    if(CanPitch())
    {
        rViewAngles.Pitch += R.Pitch;
        // End:0xA4
        if(rViewAngles.Pitch > rViewConstraintsInternal.Pitch)
        {
            rViewAngles.Pitch = rViewConstraintsInternal.Pitch;
            R.Pitch = 0;            
        }
        else
        {
            // End:0xE2
            if(rViewAngles.Pitch < - rViewConstraintsInternal.Pitch)
            {
                rViewAngles.Pitch = - rViewConstraintsInternal.Pitch;
                R.Pitch = 0;
            }
        }        
    }
    else
    {
        R.Pitch = 0;
    }
    // End:0x18E
    if(CanYaw())
    {
        rViewAngles.Yaw += R.Yaw;
        // End:0x14D
        if(rViewAngles.Yaw > rViewConstraintsInternal.Yaw)
        {
            rViewAngles.Yaw = rViewConstraintsInternal.Yaw;
            R.Yaw = 0;            
        }
        else
        {
            // End:0x18B
            if(rViewAngles.Yaw < - rViewConstraintsInternal.Yaw)
            {
                rViewAngles.Yaw = - rViewConstraintsInternal.Yaw;
                R.Yaw = 0;
            }
        }        
    }
    else
    {
        R.Yaw = 0;
    }
    R.Roll = 0;
    rLastRotation = R;
    // End:0x1DB
    if((R.Pitch != 0) || R.Yaw != 0)
    {
        bMoving = true;
    }
    return;
}

simulated function AssignAmbientSound()
{
    local Rotator R;

    // End:0x32
    if((Duke == none) && bDestroyed || ! bActivated)
    {
        FindAndPlaySound('dnCamera_Static');        
    }
    else
    {
        // End:0x49
        if(bMoving)
        {
            FindAndPlaySound('dnCamera_Move');            
        }
        else
        {
            SetAnimFrame(none);
        }
    }
    return;
}

function TickNetworking(float fDeltaTime)
{
    // End:0x1A
    if(int(Level.NetMode) == int(NM_Standalone))
    {
        return;
    }
    // End:0x2A
    if(int(Role) != int(ROLE_Authority))
    {
        return;
    }
    // End:0x5E
    if(bNetTransmitRotation)
    {
        // End:0x48
        if(iNetTransmitTicksRemaining > 0)
        {
            -- iNetTransmitTicksRemaining;            
        }
        else
        {
            bNetTransmitRotation = false;
            iNetTransmitTicksRemaining = iNetTransmitTicks;
        }        
    }
    else
    {
        // End:0x93
        if(fTimeSinceBirth > fNetPositionTime)
        {
            bNetTransmitRotation = true;
            J0x75:

            // End:0x93 [Loop If]
            if(fTimeSinceBirth > fNetPositionTime)
            {
                fTimeSinceBirth -= fNetPositionTime;
                // [Loop Continue]
                goto J0x75;
            }
        }
    }
    return;
}

simulated function Tick(float fDeltaTime)
{
    local Rotator R;

    AssignAmbientSound();
    bMoving = false;
    fTimeSinceBirth += fDeltaTime;
    TickNetworking(fDeltaTime);
    // End:0x126
    if((bAlert && ! bDestroyed) && bActivated)
    {
        // End:0x11A
        if(fStallTimer <= 0)
        {
            fStallTimer = 0;
            // End:0xBD
            if(int(CameraMotion) == int(0))
            {
                R.Pitch = int(fDeltaTime * fCurrentAngleModifier);
                RotateBy(R);
                // End:0xBA
                if(Abs(float(rViewAngles.Pitch)) >= float(rViewConstraintsInternal.Pitch))
                {
                    fCurrentAngleModifier *= -1;
                }                
            }
            else
            {
                // End:0x117
                if(int(CameraMotion) == int(1))
                {
                    R.Yaw = int(fDeltaTime * fCurrentAngleModifier);
                    RotateBy(R);
                    // End:0x117
                    if(Abs(float(rViewAngles.Yaw)) >= float(rViewConstraintsInternal.Yaw))
                    {
                        fCurrentAngleModifier *= -1;
                    }
                }
            }            
        }
        else
        {
            fStallTimer -= fDeltaTime;
        }
    }
    // End:0x169
    if((int(Level.NetMode) == int(NM_DedicatedServer)) || int(Level.NetMode) == int(NM_ListenServer))
    {
        rServerViewAngles = rViewAngles * float(64);
    }
    super(Actor).Tick(fDeltaTime);
    return;
}

simulated function SetFiring(bool bNowFiring)
{
    // End:0x0D
    if(! bArmed)
    {
        return;
    }
    // End:0x27
    if(bNowFiring)
    {
        Destroy(0.11, true, 'Fire');        
    }
    else
    {
        Spawn('Fire');
    }
    bFiring = bNowFiring;
    return;
}

simulated function Fire()
{
    local Vector t;

    // End:0x0D
    if(! bArmed)
    {
        return;
    }
    FindAndPlaySound('dnCamera_Fire', 1);
    t = MeshInstance.CreateAnimGroup('bone_barrel', true, false);
    // End:0x6A
    if(int(Role) == int(ROLE_Authority))
    {
        ShouldTouch(t, t + (Vector(rViewAngles + Rotation) * float(10000)), TraceDamageType);
    }
    return;
}

simulated event float GetBaseDamage(Actor Victim, optional Pawn Instigator, optional class<DamageType> DamageType, optional Vector HitDirection, optional Vector HitLocation, optional name BoneName, optional Vector SourceTraceOrigin)
{
    return float(iDamagePerShot);
    return;
}

simulated function ChangeZoom()
{
    // End:0x18
    if(bDestroyed || ! bActivated)
    {
        return;
    }
    ++ iZoomMode;
    // End:0x42
    if(iZoomMode == 3)
    {
        iZoomMode = 0;
        FindAndPlaySound('dnCamera_ZoomOut', 1);        
    }
    else
    {
        FindAndPlaySound('dnCamera_ZoomIn', 1);
    }
    SetCurrentZoom();
    return;
}

simulated event SetCurrentZoom()
{
    // End:0x2B
    if((Duke != none) || dnControl_CameraViewer(Duke.InteractiveDecoration) == none)
    {
        return;
    }
    Duke.GetScaleModifierTarget('FOV', 'DukeCameraSystem', CameraFOVs[iZoomMode % 3]);
    return;
}

simulated function ResetZoom()
{
    iZoomMode = 0;
    return;
}

simulated function bool CanPitch()
{
    // End:0x12
    if(rViewConstraints.Pitch != 0)
    {
        return true;
    }
    return false;
    return;
}

simulated function bool CanYaw()
{
    // End:0x12
    if(rViewConstraints.Yaw != 0)
    {
        return true;
    }
    return false;
    return;
}

simulated function Destroyed()
{
    local dnControl_CameraViewer V;

    // End:0x48
    foreach RotateVectorAroundAxis(class'dnControl_CameraViewer', V)
    {
        // End:0x47
        if(V.User != Duke)
        {
            V.Used(Duke, Duke);
            // End:0x48
            break;
        }        
    }    
    ServerSpawnBroken();
    super(dnDecoration).Destroyed();
    return;
}

function ServerSpawnBroken()
{
    local dnCameraBroken C;
    local dnControl_CameraViewer V;

    C = EmptyTouchClasses(classBroken);
    // End:0x1C
    if(C != none)
    {
        return;
    }
    C.rViewAngles = rViewAngles;
    C.CameraMounting = CameraMounting;
    C.NextCamera = NextCamera;
    C.PrevCamera = PrevCamera;
    C.GetAnimationStart(Tag);
    C.bLookedThrough = bLookedThrough;
    C.iZoomMode = iZoomMode;
    C._InitSelf();
    C.SetActive(Duke);
    SetActive(none);
    // End:0x120
    foreach RotateVectorAroundAxis(class'dnControl_CameraViewer', V)
    {
        // End:0x11F
        if(V.CurrentCamera != self)
        {
            V.FindCamera(C.Tag);
        }        
    }    
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(dnDecoration).RegisterPrecacheComponents(PrecacheIndex);
    // End:0x28
    if(! bInvulernable)
    {
        PrecacheIndex.RegisterMaterialClass(classBroken);
    }
    // End:0x5A
    if(bArmed)
    {
        PrecacheIndex.ResetServer(TraceDamageType);
        PrecacheIndex.InitAnimationControllerEx(VoicePack, 'dnCamera_Fire');
    }
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'dnCamera_Static');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'dnCamera_Move');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'dnCamera_ZoomIn');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'dnCamera_ZoomOut');
    // End:0xDE
    if(int(CameraMounting) == int(0))
    {
        PrecacheIndex.SetChannelEventState(Mesh, IdleWallAnim);        
    }
    else
    {
        PrecacheIndex.SetChannelEventState(Mesh, IdleCeilingAnim);
    }
    return;
}

defaultproperties
{
    CameraMotion=1
    classBroken='dnCameraBroken'
    BaseCameraFOV=65
    CameraFOVStrings[0]="1X ZOOM"
    CameraFOVStrings[1]="4X ZOOM"
    CameraFOVStrings[2]="10X ZOOM"
    CameraID=1
    bAlert=true
    TraceDamageType='BulletDamage'
    fCurrentAngleModifier=1240
    iDamagePerShot=7
    IdleWallAnim=idle_wall
    IdleCeilingAnim=idle_ceiling
    iNetTransmitTicks=3
    fNetPositionTime=0.5
    CameraFOVs[0]=1.22
    CameraFOVs[1]=0.55
    CameraFOVs[2]=0.33
    bActivated=true
    ViewBoneName=bone_lens
    SpawnOnDestroyedSimple(0)='dnParticles.dnSparkFX_BreakingLight_Flash_Down'
    SpawnOnDestroyedSimple(1)='dnParticles.dnExplosion3_SElec_Fire'
    bBlockKarma=true
    bHasEvalBonesHelper=true
    bDumbMesh=false
    bAlwaysRelevant=true
    bForceTagEventRep=true
    bDirectional=true
    bCollideWorld=false
    CollisionRadius=15
    CollisionHeight=12
    Mesh='c_generic.Sec_CameraA'
    SoundVolume=255
    SoundRadius=400
    SoundInnerRadius=200
    TransientSoundVolume=1
    TransientSoundRadius=400
    TransientSoundInnerRadius=200
}