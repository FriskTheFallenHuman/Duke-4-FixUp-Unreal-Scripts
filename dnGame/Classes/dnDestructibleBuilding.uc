/*******************************************************************************
 * dnDestructibleBuilding generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class dnDestructibleBuilding extends RenderActor
    native
    collapsecategories
    dependson(dnDestructibleBuildingPart)
    hidecategories(Actor,Advanced,Animation,Collision,Crushing,Destruction,Display,Filter,Health,HeatVision,IK,Interpolation,Karma,KarmaCollision,KarmaDamage,KarmaEvents,Lighting,Material,Mounting,Network,Networking,RenderActor,Sound,Tick,TickRules,VertexFunction);

const kMinNumDesiredParts = 4;
const kMaxNumParts = 12;
const kAvgSurvivalRate = 0.30;

var() noexport bool bGibCastShadows "If true, gibs will cast shadows after the building has been destroyed.";
var() noexport class<dnDestructibleBuildingDefinition> Definition "Definition to use for part layout.";
var() noexport int RandomSeed "Seed to use for randomness.";
var() noexport Vector Noise "Vector to be used as a variance as random noise for the parts.";
var() noexport float SkewXFromY "Skew factor along the x axis based on y position.";
var() noexport float SkewXFromZ "Skew factor along the x axis based on z position.";
var() noexport float SkewYFromX "Skew factor along the y axis based on x position.";
var() noexport float SkewYFromZ "Skew factor along the y axis based on z position.";
var() noexport float SkewZFromX "Skew factor along the z axis based on x position.";
var() noexport float SkewZFromY "Skew factor along the z axis based on y position.";
var() noexport float PartSurvivalChance "Chance from 0.0 - 1.0 for parts surviving the explosion.";
var() noexport float PartCollisionChance "Chance from 0.0 - 1.0 for parts colliding after the explosion.  If they don't collide, they will go through everything.";
var() noexport bool bEnableExplosiveDestruction "If true, explosions will be considered for destruction of this building.";
var() noexport float ExplosiveDamageRequired "Amount of damage required in one explosion to cause destruction.";
var() noexport bool bEnableVehicularDestruction "If true, vehicles will be considered for destruction of this building.";
var() noexport float VehicleVelocityRequired "Amount of velocity required from 1 vehicle impact to cause destruction.";
var float DamageRadius;
var array<dnDestructibleBuildingPart> Parts;
var transient int EditorRenderDatas;
var dnDestructibleBuildingPart ShellPart;

// Export UdnDestructibleBuilding::execComputeSpawnInfoForPart(FFrame&, void* const)
native final simulated function ComputeSpawnInfoForPart(out SDestructibleBuildingPart Part, out Vector SpawnLocation, out Rotator SpawnRotation);

function PreSpawnPart(out SDestructibleBuildingPart partDef, bool bIsShellPart)
{
    local dnDestructibleBuildingPart Part;
    local Vector SpawnLocation;
    local Rotator SpawnRotation;

    // End:0x22
    if(bIsShellPart)
    {
        SpawnLocation = Location;
        SpawnRotation = Rotation;        
    }
    else
    {
        ComputeSpawnInfoForPart(partDef, SpawnLocation, SpawnRotation);
    }
    Part = EmptyTouchClasses(class'dnDestructibleBuildingPart', self,, SpawnLocation, SpawnRotation,, true);
    // End:0x119
    if(! bIsShellPart)
    {
        // End:0x8F
        if(partDef.OverrideCollisionChance > 0)
        {
            Part.CollisionChance = partDef.OverrideCollisionChance;            
        }
        else
        {
            Part.CollisionChance = PartCollisionChance;
        }
        // End:0xD2
        if(partDef.OverrideDensity > 0)
        {
            Part.Density = partDef.OverrideDensity;
        }
        // End:0xFD
        if(partDef.Mass > 0)
        {
            Part.DisableDesiredLocation(partDef.Mass);
        }
        Part.bDefaultInteractionClass = partDef.bDefaultInteractionClass;
    }
    // End:0x144
    if(partDef.PhysicsMaterial == none)
    {
        Part.PhysicsMaterial = partDef.PhysicsMaterial;
    }
    Part.OwnerBuilding = self;
    Part.GetOverlayEffectAlpha(partDef.StaticMesh);
    // End:0x1B2
    if(! bIsShellPart)
    {
        Part.SetActorColor(partDef.Scale);
        Part.GetZoneLastRenderTime(true);
        Parts[Parts.Add(1)] = Part;        
    }
    else
    {
        Part.ForceMountUpdate(,,, true);
        ShellPart = Part;
    }
    return;
}

simulated event PreBeginPlay()
{
    local int i, j;
    local Vector Center, Extent;
    local Box RenderBounds, PartBounds;
    local array<int> partsLeft, partsMustSpawn, partsCouldSpawn;
    local float fCurSurvivalChance;
    local bool bSurvived;
    local int nCurPartIndex, nCurRandomSeed, nNumPartsCap;

    DrawType = 1;
    Texture = none;
    // End:0x5DF
    if(Definition == none)
    {
        nNumPartsCap = Clamp(int(float(string(Definition.default.Parts)) * 0.3), 4, 12);
        nNumPartsCap = Min(nNumPartsCap, string(Definition.default.Parts));
        i = 0;
        J0x64:

        // End:0x198 [Loop If]
        if(i < string(Definition.default.Parts))
        {
            // End:0x104
            if(Definition.default.Parts[i].StaticMesh != none)
            {
                Warn((("dnDestructibleBuilding definition" @ string(Definition)) @ "has a missing StaticMesh at Part #") $ string(i));
                // [Explicit Continue]
                goto J0x18E;
            }
            // End:0x14B
            if(Definition.default.Parts[i].OverrideSurvivalChance > 0)
            {
                fCurSurvivalChance = Definition.default.Parts[i].OverrideSurvivalChance;                
            }
            else
            {
                fCurSurvivalChance = PartSurvivalChance;
            }
            // End:0x17B
            if(fCurSurvivalChance >= 1)
            {
                partsMustSpawn[partsMustSpawn.Add(1)] = i;
                // [Explicit Continue]
                goto J0x18E;
            }
            partsLeft[partsLeft.Add(1)] = i;
            J0x18E:

            ++ i;
            // [Loop Continue]
            goto J0x64;
        }
        // End:0x34B
        if(string(partsMustSpawn) < nNumPartsCap)
        {
            i = 0;
            J0x1AF:

            // End:0x34B [Loop If]
            if(i < string(partsLeft))
            {
                nCurPartIndex = partsLeft[i];
                // End:0x1DE
                if(nCurPartIndex < 0)
                {
                    // [Explicit Continue]
                    goto J0x341;
                }
                // End:0x225
                if(Definition.default.Parts[nCurPartIndex].OverrideSurvivalChance > 0)
                {
                    fCurSurvivalChance = Definition.default.Parts[nCurPartIndex].OverrideSurvivalChance;                    
                }
                else
                {
                    fCurSurvivalChance = PartSurvivalChance;
                    // End:0x24A
                    if(fCurSurvivalChance == 0.5)
                    {
                        fCurSurvivalChance = 0.3;
                    }
                }
                bSurvived = FRand() <= fCurSurvivalChance;
                // End:0x276
                if(bSurvived)
                {
                    partsCouldSpawn[partsCouldSpawn.Add(1)] = nCurPartIndex;
                }
                nCurRandomSeed = Definition.default.Parts[nCurPartIndex].RandomSeed;
                // End:0x326
                if(nCurRandomSeed > 0)
                {
                    j = i + 1;
                    J0x2AF:

                    // End:0x326 [Loop If]
                    if(j < string(partsLeft))
                    {
                        // End:0x31C
                        if(Definition.default.Parts[partsLeft[j]].RandomSeed == nCurRandomSeed)
                        {
                            // End:0x30B
                            if(bSurvived)
                            {
                                partsCouldSpawn[partsCouldSpawn.Add(1)] = partsLeft[j];
                            }
                            partsLeft[j] = -1;
                        }
                        ++ j;
                        // [Loop Continue]
                        goto J0x2AF;
                    }
                }
                // End:0x341
                if((string(partsMustSpawn) + string(partsCouldSpawn)) >= nNumPartsCap)
                {
                    // [Explicit Break]
                    goto J0x34B;
                }
                J0x341:

                ++ i;
                // [Loop Continue]
                goto J0x1AF;
            }
        }
        J0x34B:

        i = 0;
        J0x352:

        // End:0x38E [Loop If]
        if(i < string(partsMustSpawn))
        {
            PreSpawnPart(Definition.default.Parts[partsMustSpawn[i]], false);
            ++ i;
            // [Loop Continue]
            goto J0x352;
        }
        i = 0;
        J0x395:

        // End:0x3D1 [Loop If]
        if(i < string(partsCouldSpawn))
        {
            PreSpawnPart(Definition.default.Parts[partsCouldSpawn[i]], false);
            ++ i;
            // [Loop Continue]
            goto J0x395;
        }
        PreSpawnPart(Definition.default.ShellPart, true);
        ShellPart.DetachProjector(PartBounds.Min, PartBounds.Max);
        // End:0x453
        if(int(RenderBounds.IsValid) == 0)
        {
            RenderBounds.IsValid = 1;
            RenderBounds.Min = PartBounds.Min;
            RenderBounds.Max = PartBounds.Max;            
        }
        else
        {
            // End:0x495
            if(PartBounds.Min.X < RenderBounds.Min.X)
            {
                RenderBounds.Min.X = PartBounds.Min.X;
            }
            // End:0x4D7
            if(PartBounds.Min.Y < RenderBounds.Min.Y)
            {
                RenderBounds.Min.Y = PartBounds.Min.Y;
            }
            // End:0x519
            if(PartBounds.Min.Z < RenderBounds.Min.Z)
            {
                RenderBounds.Min.Z = PartBounds.Min.Z;
            }
            // End:0x55B
            if(PartBounds.Max.X > RenderBounds.Max.X)
            {
                RenderBounds.Max.X = PartBounds.Max.X;
            }
            // End:0x59D
            if(PartBounds.Max.Y > RenderBounds.Max.Y)
            {
                RenderBounds.Max.Y = PartBounds.Max.Y;
            }
            // End:0x5DF
            if(PartBounds.Max.Z > RenderBounds.Max.Z)
            {
                RenderBounds.Max.Z = PartBounds.Max.Z;
            }
        }
    }
    Extent = 0.5 * (RenderBounds.Max - RenderBounds.Min);
    Center = RenderBounds.Min + Extent;
    IsMountedTo(VSize(Vect(Extent.X, Extent.Y, 0)), Extent.Z);
    DamageRadius = 1.5 * VSize(Extent);
    super.PreBeginPlay();
    return;
}

simulated function bool VerifySelf()
{
    // End:0x0E
    if(string(Parts) <= 0)
    {
        return false;
    }
    return super(Actor).VerifySelf();
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    local Actor Damager;

    // End:0x6C
    if((bEnableExplosiveDestruction && Damage >= ExplosiveDamageRequired) && IsA(DamageType, class'ExplosionDamage'))
    {
        // End:0x46
        if(Instigator == none)
        {
            Damager = Instigator;            
        }
        else
        {
            Damager = self;
        }
        PerformExplosiveDestruction(Damager, Damage, DamageOrigin, DamageDirection, DamageType);
    }
    return;
}

simulated event Trigger(Actor Other, Pawn EventInstigator)
{
    local Actor Damager;

    super(Actor).Trigger(Other, EventInstigator);
    // End:0x2A
    if(EventInstigator == none)
    {
        Damager = EventInstigator;        
    }
    else
    {
        // End:0x44
        if(Other == none)
        {
            Damager = Other;            
        }
        else
        {
            Damager = self;
        }
    }
    PerformExplosiveDestruction(Damager, ExplosiveDamageRequired, Location, -1 * Normal(CreateDesiredLocation()), class'ExplosionDamage');
    return;
}

simulated event bool TakePhysicsImpactDamage(float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, Pawn Instigator, KarmaActor DamageActor)
{
    local Actor Damager;
    local Vector VehicleVelocity;
    local float VehicleVelocitySize;

    // End:0xAF
    if(bEnableVehicularDestruction && DamageActor.bIsVehicle)
    {
        // End:0x38
        if(Instigator == none)
        {
            Damager = Instigator;            
        }
        else
        {
            // End:0x52
            if(DamageActor == none)
            {
                Damager = DamageActor;                
            }
            else
            {
                Damager = self;
            }
        }
        DamageActor.GetConstraintCount(VehicleVelocity);
        VehicleVelocitySize = VSize(VehicleVelocity);
        // End:0xAF
        if(VehicleVelocitySize >= VehicleVelocityRequired)
        {
            PerformExplosiveDestruction(Damager, ExplosiveDamageRequired, Location, -1 * Normal(CreateDesiredLocation()), class'ExplosionDamage');
            return true;
        }
    }
    return false;
    return;
}

final simulated function PerformExplosiveDestruction(Actor DamageInstigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType)
{
    local int i;
    local float Scale;
    local dnFriendFX_Spawners Spawner;
    local HUDEffects Effect;

    // End:0x0E
    if(string(Parts) <= 0)
    {
        return;
    }
    // End:0x4B
    if((Definition == none) && NameForString(Definition.default.DestroyedSoundName, 'None'))
    {
        FindAndPlaySound(Definition.default.DestroyedSoundName);
    }
    i = string(Definition.default.ParticleEffects) - 1;
    J0x64:

    // End:0x1A7 [Loop If]
    if(i >= 0)
    {
        // End:0x93
        if(Definition.default.ParticleEffects[i].SpawnerClass != none)
        {
            // [Explicit Continue]
            goto J0x19D;
        }
        Spawner = FindFriendSpawner(Definition.default.ParticleEffects[i].SpawnerClass);
        // End:0xC8
        if(Spawner != none)
        {
            // [Explicit Continue]
            goto J0x19D;
        }
        Scale = Definition.default.ParticleEffects[i].Scale;
        // End:0x102
        if(Scale <= 0)
        {
            Scale = 1;
        }
        Spawner.SetDesiredRotation(Location + (Definition.default.ParticleEffects[i].LocationOffset >> Rotation));
        Spawner.DisableDesiredRotation_Roll(Definition.default.ParticleEffects[i].RotationOffset >> Rotation);
        Spawner.SystemSizeScale = Spawner.default.SystemSizeScale * Scale;
        Spawner.ExecuteEffect(true);
        J0x19D:

        -- i;
        // [Loop Continue]
        goto J0x64;
    }
    i = string(Definition.default.HUDEffects) - 1;
    J0x1C0:

    // End:0x396 [Loop If]
    if(i >= 0)
    {
        // End:0x1EF
        if(Definition.default.HUDEffects[i].EffectClass != none)
        {
            // [Explicit Continue]
            goto J0x38C;
        }
        Effect = EmptyTouchClasses(Definition.default.HUDEffects[i].EffectClass, self);
        // End:0x222
        if(Effect != none)
        {
            // [Explicit Continue]
            goto J0x38C;
        }
        Scale = Definition.default.HUDEffects[i].Scale;
        // End:0x25C
        if(Scale <= 0)
        {
            Scale = 1;
        }
        Effect.SetDesiredRotation(Location + Definition.default.HUDEffects[i].LocationOffset);
        Effect.ExecuteEffect(Scale);
        Localize((string(self) @ string(Effect)) @ "Executed");
        Localize((string(Location.X) @ string(Location.Y)) @ string(Location.Z));
        Localize((string(Effect.Location.X) @ string(Effect.Location.Y)) @ string(Effect.Location.Z));
        Localize((string(Level.TickHint().Location.X) @ string(Level.TickHint().Location.Y)) @ string(Level.TickHint().Location.Z));
        J0x38C:

        -- i;
        // [Loop Continue]
        goto J0x1C0;
    }
    // End:0x3AF
    if(ShellPart == none)
    {
        ShellPart.RemoveTouchClass();
    }
    i = string(Parts) - 1;
    J0x3BE:

    // End:0x5C4 [Loop If]
    if(i >= 0)
    {
        // End:0x3DE
        if(Parts[i] != none)
        {
            // [Explicit Continue]
            goto J0x5BA;
        }
        // End:0x473
        if(FRand() < Parts[i].CollisionChance)
        {
            // End:0x42B
            if(Parts[i].bDefaultInteractionClass)
            {
                Parts[i].KFindPhysicsAction(0);                
            }
            else
            {
                Parts[i].KFindPhysicsAction(2);
            }
            Parts[i].bEnableImpactSounds = true;
            Parts[i].bEnableImpactEffects = true;            
        }
        else
        {
            Parts[i].LifeSpan = FVar(15, 10);
        }
        Parts[i].TickStyle = 2;
        Parts[i].bIgnoresPhysicsDamage = true;
        Parts[i].bBlockCamera = false;
        Parts[i].bCastStencilShadows = bGibCastShadows;
        Parts[i].bGibActor = true;
        Level.NoteSpawnedGib(Parts[i]);
        Parts[i].ForceMountUpdate(false, false, false, true, false);
        Parts[i].SetRotation(18);
        Parts[i].KGetCollidingActors();
        Parts[i].GetZoneLastRenderTime(false);
        Parts[i].HurtRadiusActivity(DamageInstigator, Damage, DamageOrigin, DamageRadius, -0.25, DamageType, DamageOrigin);
        J0x5BA:

        -- i;
        // [Loop Continue]
        goto J0x3BE;
    }
    Parts.Empty();
    RemoveTouchClass();
    return;
}

simulated function Destroyed()
{
    super.Destroyed();
    GlobalTrigger(Event);
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(Actor).RegisterPrecacheComponents(PrecacheIndex);
    // End:0x38
    if(Definition == none)
    {
        PrecacheIndex.InitAnimationControllerEx(VoicePack, Definition.default.DestroyedSoundName);
    }
    return;
}

defaultproperties
{
    Definition='dnDestructibleBuildingDefinition'
    PartSurvivalChance=0.5
    PartCollisionChance=0.5
    bEnableExplosiveDestruction=true
    ExplosiveDamageRequired=25
    bEnableVehicularDestruction=true
    VehicleVelocityRequired=200
    bTraceUsable=false
    bTraceShootable=false
    bUseCylinderCollision=true
    bCollideActors=true
    TickStyle=0
    VoicePack='SoundConfig.Interactive.VoicePack_Decorations'
}