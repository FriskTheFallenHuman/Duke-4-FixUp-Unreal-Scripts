/*******************************************************************************
 * MP_dnPipeBombProjectile generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MP_dnPipeBombProjectile extends dnGrenade
    collapsecategories
    dependson(PipeBombBeam)
    dependson(PipeBombBeam_Blue);

var class<MP_Detonator> DetonatorNotifyClass;
var float MaximumPipebombPickupVelocity;
var Pawn DetonationController;
var bool bAutoDecalBomb;
var int NumBeeps;
var() float BeepPeriod;
var DukeHUD PlayerHUD;

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        rPipeBombExecuteExplode;

    // Pos:0x00B
    reliable if(int(Role) == int(ROLE_Authority))
        SetDetonationController;
}

noexport simulated delegate SetDetonationController(Pawn C)
{
    local PipeBombBeam bT;
    local PipeBombBeam_Blue BTB;

    DetonationController = C;
    // End:0x9D
    if((((C == none) && C.PlayerReplicationInfo == none) && int(C.PlayerReplicationInfo.Team) == 0) && Level.TickHint().GameReplicationInfo.bTeamGame)
    {
        // End:0x99
        foreach GetNextIntDesc(class'PipeBombBeam', bT)
        {
            bT.RemoveTouchClass();
            // End:0x99
            break;            
        }                
    }
    else
    {
        // End:0xBE
        foreach GetNextIntDesc(class'PipeBombBeam_Blue', BTB)
        {
            BTB.RemoveTouchClass();
            // End:0xBE
            break;            
        }        
    }
    return;
}

simulated function PostBeginPlay()
{
    super(InteractiveActor).PostBeginPlay();
    // End:0x8A
    if((IsMP()) && bDontUseMeqonPhysics)
    {
        SetRotation(2);
        ForceMountUpdate(true, true, true, false, true);
        bCastStencilShadows = false;
        bBounce = true;
        TickStyle = 1;
        bNoNativeTick = false;
        bTickOnlyWhenPhysicsAwake = false;
        bCollisionAssumeValid = false;
        PlayerHUD = DukeHUD(Level.TickHint().MyHUD);
        PlayerHUD.AddActivePipeBomb(self);
    }
    return;
}

simulated event Destroyed()
{
    local MP_Detonator DetonatorRef;

    // End:0x54
    if((DetonationController == none) && DetonatorNotifyClass == none)
    {
        DetonatorRef = MP_Detonator(DetonationController.PhysController_SetDesiredVelocity(DetonatorNotifyClass));
        // End:0x54
        if(DetonatorRef == none)
        {
            DetonatorRef.RemovePipebomb(self);
        }
    }
    // End:0x65
    if(! bExploded)
    {
        SpawnOnDestroyedSimple.Empty();
    }
    DukeMultiPlayer(DetonationController).UpdatePipeBombCount(DetonatorRef);
    PlayerHUD.RemoveActivePipeBomb(self);
    super(dnProjectile).Destroyed();
    return;
}

simulated function InitializeMotion()
{
    return;
}

function ResumeCollision()
{
    KFindPhysicsAction(default.DynamicInteractionClassification);
    return;
}

function SetDelayedExplode(float Delay)
{
    // End:0x18
    if(Delay == 0)
    {
        DelayedExplode();        
    }
    else
    {
        TraceFire(Delay, false, 'DelayedExplode');
    }
    return;
}

function DelayedExplode()
{
    rPipeBombExecuteExplode(Location - (Normal(CreateDesiredLocation()) * 16));
    return;
}

simulated function NonImpactExplode()
{
    rPipeBombExecuteExplode(Location);
    return;
}

noexport simulated delegate rPipeBombExecuteExplode(Vector ExplosionLocation)
{
    ExecuteExplodePipeBomb(ExplosionLocation);
    return;
}

simulated event Bump(Actor Other)
{
    super(Actor).Bump(Other);
    ExecuteProjectileTouchedSomething(Other);
    return;
}

simulated function Explode(Vector HitLocation, optional Vector HitNormal, optional Actor HitActor)
{
    super(Projectile).Explode(HitLocation, HitNormal, HitActor);
    return;
}

simulated function bool EffectIsRelevant(Vector SpawnLocation, optional bool bForceDedicated)
{
    local PlayerPawn P;
    local bool bResult;

    bResult = true;
    P = Level.TickHint();
    // End:0x32
    if(P != none)
    {
        bResult = false;        
    }
    else
    {
        // End:0x89
        if((Vector(P.Rotation) Dot (SpawnLocation - P.Location)) < 0)
        {
            bResult = VSize(P.Location - SpawnLocation) < float(1600);
        }
    }
    return bResult;
    return;
}

simulated function ProjectileTouchedSomething(Actor Other)
{
    local MP_PipeBomb PipeBombRef;
    local MP_Detonator DetonatorRef;
    local Inventory NewInv;
    local PlayerPawn P;

    // End:0x134
    if((((((int(Role) == int(ROLE_Authority)) && Other.bIsPlayerPawn) && VSizeSquared(Velocity) < MaximumPipebombPickupVelocity) && (Level.GameTimeSeconds - SpawnTime) > SafetyTimer) && Instigator != Other) && DrawScale == Instigator.DrawScale)
    {
        P = PlayerPawn(Other);
        NewInv = class'Inventory'.static.AttemptPickup(class'PipeBombAmmo', none, P, 1);
        // End:0x134
        if(NewInv == none)
        {
            DetonatorRef = MP_Detonator(P.PhysController_SetDesiredVelocity(class'MP_Detonator'));
            // End:0x131
            if(((DetonatorRef == none) && MP_Detonator(Instigator.Weapon) == none) && DetonatorRef.ActivePipeBombCount == 1)
            {
                P.BringUpLastWeapon();
            }
            RemoveTouchClass();
        }
    }
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    SetRotation(0);
    NonImpactExplode();
    return;
}

simulated function ExecuteExplodePipeBomb(Vector HitLocation, optional Vector HitNormal, optional Actor HitActor)
{
    // End:0x0B
    if(bExploded)
    {
        return;
    }
    bExploded = true;
    ExplodeEffects(HitNormal, HitActor);
    Explode(HitLocation, HitNormal, HitActor);
    return;
}

function StartTelekinesis(Pawn TKOwner)
{
    super(InteractiveActor).StartTelekinesis(TKOwner);
    // End:0x32
    if(! bPrimedForExplosion)
    {
        ExplosionDelay = 2.5;
        BeepPeriod = 0.5;
        PrimeForDelayedExplosion();
    }
    return;
}

simulated function PrimeForDelayedExplosion()
{
    super.PrimeForDelayedExplosion();
    // End:0x30
    if(BeepPeriod > 0)
    {
        FindAndPlaySound('Beep', 1);
        Destroy(BeepPeriod, true, 'DoBeepSound');
    }
    return;
}

simulated function DoBeepSound()
{
    AvoidRange = default.AvoidRange;
    // End:0x67
    if(float(NumBeeps) < ((ExplosionDelay / BeepPeriod) - float(2)))
    {
        ++ NumBeeps;
        // End:0x5A
        if(float(NumBeeps) < ((ExplosionDelay / BeepPeriod) - float(3)))
        {
            FindAndPlaySound('Beep', 1);            
        }
        else
        {
            FindAndPlaySound('MultiBeep', 1);
        }
    }
    return;
}

simulated event HitWall(Vector HitNormal, Actor HitWall)
{
    local Vector X, Y, Z;
    local Rotator Rot;
    local int diff;
    local float BounceElasticity;

    // End:0x2A
    if((! IsMP() || ! bDontUseMeqonPhysics) || int(Physics) == int(18))
    {
        return;
    }
    // End:0x8C
    if((NumBounces < 0) || (NumBounces > 0) && ++ NumWallHits <= NumBounces)
    {
        // End:0x8C
        if(NameForString(ImpactSoundName, 'None') && VSizeSquared(Velocity) > (ImpactSoundSpeed * ImpactSoundSpeed))
        {
            FindAndPlaySound(ImpactSoundName, 1);
        }
    }
    X = Vector(Rot(0, Rotation.Yaw, 0));
    Z = HitNormal;
    Y = Z Cross X;
    X = Y Cross Z;
    Rot = OrthoRotation(X, Y, Z);
    diff = (Rotation.Pitch - Rot.Pitch) & 65535;
    // End:0x121
    if(diff > 32768)
    {
        diff -= 65535;
    }
    // End:0x14E
    if((diff < -16384) || diff > 16384)
    {
        Rot.Pitch += 32768;
    }
    CreateDesiredRotation(Rot(0, 0, 0));
    Markers_AddLine(Rot.Pitch, 0, 0.2,,,,,,, true);
    BounceElasticity = 0.5;
    Velocity = BounceElasticity * MirrorVectorByNormal(Velocity, HitNormal);
    // End:0x1FE
    if(((HitWall == none) && HitWall.bIsMover) && HitWall.Velocity.Z > 0)
    {
        Velocity.Z = HitWall.Velocity.Z * 2;
    }
    // End:0x226
    if(VSizeSquared(Velocity) < 100)
    {
        Velocity = Vect(0, 0, 0);
    }
    // End:0x291
    if(Velocity == Vect(0, 0, 0))
    {
        ForceMountUpdate(,, false, false);
        bIgnoreInstigatorCollision = false;
        // End:0x27C
        if((HitWall == none) && HitWall.bIsMover)
        {
            MoveActor(HitWall,,, true);
        }
        SetRotation(0);
        ClientProjectileSettled(Location, Rotation);
    }
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(InteractiveActor).RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Beep');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'MultiBeep');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, ImpactSoundName);
    return;
}

defaultproperties
{
    DetonatorNotifyClass='MP_Detonator'
    MaximumPipebombPickupVelocity=720
    bAutoDecalBomb=true
    UpwardsBoost=(X=0,Y=0,Z=140)
    bShowHUDWarning=true
    bExplodeOnDamage=true
    SafetyTimer=0.4
    Speed=750
    MaxSpeed=750
    Damage=125
    DamageRadius=260
    DamageClass='PipeBombDamage'
    NumBounces=-1
    ImpactSoundName=Beep
    ShakeScalar=2.25
    ShakeInfo(0)=(bNoLerp=false,bToggleSign=false,Style=3,Function=0,FalloffActor=none,FalloffDistance=0,ShakeDuration=0.55,ShakeFrequency=0.05,ShakeMagnitude=700,ShakeFullMagnitude=0,ShakeFullMagnitudeTime=0,ShakeName=dnPipeBombProjectile_Shake)
    RumbleInfo(0)=(RumbleName=dnPipeBombProjectile_Rumble,RumbleDuration=0.5,RumbleLeftMagnitude=0.8,RumbleRightMagnitude=0,FalloffActor=none,FalloffDistance=0)
    ExplosionClass='p_Weapons.PipeBomb_Explosion.PipeBomb_Explosion_SpawnerMP'
    UnderwaterExplosionClass='p_Weapons.PipeBomb_Explosion_Underwater.PipeBomb_Explosion_Underwater_Spawner'
    ExplosionLight='dnExplosionLight_RPG'
    ExplosionSoundName=ProjectileExplode
    bDestroyOnVolumeTouch=true
    AvoidRange=200
    MountOnSpawn(0)=(bSkipVerifySelf=false,SpawnClass='PipeBombBeam',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=6.5,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    MountOnSpawn(1)=(bSkipVerifySelf=false,SpawnClass='PipeBombBeam_Blue',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=6.5,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    MountOnSpawn(2)=(bSkipVerifySelf=false,SpawnClass='dnParticles.PipeBombBeam_Corona',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=6.5,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    MountOnSpawn(3)=(bSkipVerifySelf=false,SpawnClass='Weapon_LightEx_Pipebomb',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=6.5,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    HealthCap=1
    bResetOnFellOutOfWorld=true
    bStartEnabled=true
    DynamicInteractionClassification=7
    PhysicsMaterial='dnMaterial.dnPhysicsMaterial_PipeBomb'
    KRestitution=0.5
    KLinearDamping=0.28
    KAngularDamping=0.58
    Density=2
    Physics=2
    bTraceShootable=true
    bBlockActors=false
    bBlockPlayers=false
    bIsPipeBombOrTripMine=true
    bDumbMesh=false
    bNetTemporary=false
    bDontSimulateMotion=true
    bDontUseMeqonPhysics=true
    bIgnoreInstigatorCollision=true
    CollisionRadius=0.3
    CollisionHeight=0.3
    Mass=5
    DrawType=8
    StaticMesh='sm_class_decorations.Weapon_Pickups.PipeBomb_Static'
    LifeSpan=0
    NetPriority=1
    TransientSoundVolume=0.5
    TransientSoundRadius=800
    TransientSoundInnerRadius=400
    VoicePack='SoundConfig.Inventory.VoicePack_PipeBomb'
}