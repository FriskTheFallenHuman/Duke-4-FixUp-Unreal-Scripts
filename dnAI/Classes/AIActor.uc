/*******************************************************************************
 * AIActor generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AIActor extends BaseAI
    abstract
    native
    config
    collapsecategories
    dependson(AITarget)
    dependson(WeaponCfg)
    dependson(AIRelationshipMgr)
    dependson(AIAnimationControllerEx)
    dependson(AIInputDispatcher_Base)
    dependson(ScriptPlayer)
    dependson(Destructible_Armor)
    dependson(PopUpCfg)
    dependson(AIAnimHUD)
    dependson(AIActorFactoryManager)
    dependson(AIActorFactory)
    dependson(dnControl_FinishingMove)
    dependson(ScriptObj)
    dependson(ScriptMethod)
    dependson(ScriptMethod_PlayExplicitAnim)
    dependson(ScriptMethod_PlayTransientExplicitAnim)
    dependson(PointTracker);

const AI_LedgeRagdollK = 4.0f;
const AI_MaxTreeDepth = 50;
const AI_MaxTrailTime = 10.0f;
const AI_MaxAimYaw = 8000;
const AI_MaxAimPitch = 4000;
const AI_AimAccelK = 0.5f;
const AnimX_Mode_Init = 0;
const AnimX_Mode_Anim = 1;
const AnimX_Mode_AnimFacePos = 2;
const AnimX_Mode_AnimFaceActor = 3;
const AnimX_Mode_AnimFaceTarget = 4;
const AnimX_Mode_SyncGoto = 5;
const AnimX_Mode_SyncTurn = 6;
const AnimX_Mode_SyncWait = 7;
const AnimX_Mode_SyncAnim = 8;
const Fall_Mode_StartFall = 0;
const Fall_Mode_Fall = 1;
const Fall_Mode_Land = 2;
const GotoX_NoMaxSteps = -1;
const GotoX_DoorPauseTime = 0.6f;
const GotoX_StuckPercentage = 0.25f;
const GotoX_StuckThresholdPush = 0.5f;
const GotoX_StuckThresholdCollision = 1.0f;
const GotoX_StuckDynamicThreshold = 1.0f;
const Jump_Mode_None = 0;
const Jump_Mode_TakeOff = 1;
const Jump_Mode_Fall = 2;
const Jump_Mode_Land = 3;
const Jump_Mode_Stop = 4;
const JumpAttack_Mode_None = 0;
const JumpAttack_Mode_TakeOff = 1;
const JumpAttack_Mode_Fall = 2;
const JumpAttack_Mode_Attack = 3;
const JumpAttack_Mode_Land = 4;
const PlaceTripMine_Mode_None = 0;
const PlaceTripMine_Mode_Aim = 2;
const PlaceTripMine_Mode_Place = 3;
const PlaceTripMine_Mode_EndAim = 4;
const SelectWeapon_Mode_None = 0;
const SelectWeapon_Mode_Wait = 1;
const SelectWeapon_Mode_Holster = 2;
const SelectWeapon_Mode_Draw = 3;
const SelectWeapon_Mode_QuickSwitch = 4;
const SetAim_Mode_None = 0;
const SetAim_Mode_Wait = 1;
const SetAim_Mode_AimOn = 2;
const SetAim_Mode_AimOff = 3;
const SetFireMode_DefautAbortPeriod = 3.0f;
const SetFireMode_DefautFinishPeriod = 0.25f;
const DefaultWeaponAimDownTime = 0.35;
const DefaultWeaponAimDownTimeFast = 0.02;
const DefaultWeaponAimUpTime = 0.5;
const PreFireInterval = 0.2;
const PostFireInterval = 0.2;
const AimInterval = 0.7;

enum EAIWeaponClearShotType
{
    AIWeaponClearShot_NoCheck,
    AIWeaponClearShot_TargetVisible,
    AIWeaponClearShot_ClearTrace
};

struct STargetSlot
{
    var bool m_bUsed;
    var Actor m_aActor;
};

struct SBoneAim
{
    var() name BoneName;
    var float Yaw;
    var float Pitch;
    var() float Weight;
};

struct SBoneAimConstraints
{
    var int MinViewPitchOffset;
    var int MaxViewPitchOffset;
    var int IgnoreThresholdPitch;
    var int MinViewYawOffset;
    var int MaxViewYawOffset;
    var int IgnoreThresholdYaw;
    var float SmerpOn;
    var float SmerpOff;
    var float Acceleration;
    var float AccelerationReset;
    var float Velocity;
    var float VelocityReset;
};

struct SAimerTargetInfo
{
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var name TargetBoneName;
    var Vector TargetPos;
    var Engine.BaseAI.EAITarget TargetID;
    var float TargetExpiryTime;
    var string TargetInfID;
    var float ThresholdAngle;
    var float TrackRate;
    var bool RemoveIfBeyondConstraints;
    var name UpdatePosFuncName;
};

struct SAimerInfo
{
    var AIActor MyOwner;
    var name NotifyStateFuncName;
    var name NotifyLostFuncName;
    var name NotifyThresholdFuncName;
    var Engine.BaseAI.EAIAim CurrentState;
    var array<SAimerTargetInfo> TargetStack;
    var float AngleToTarget;
    var float DeltaAngleToTarget;
    var bool SolutionClamped;
    var bool UseWeaponAimFromPos;
};

struct SAIAnimController
{
    var Engine.BaseAI.EAIAnimController m_eFallback;
    var class<AIAnimationControllerEx> m_cClass;
    var AIAnimationControllerEx m_oController;
};

struct SAICurAnimController
{
    var Engine.BaseAI.EAIAnimController m_eFallback;
    var class<AIAnimationControllerEx> m_cClass;
    var AIAnimationControllerEx m_oController;
    var Engine.BaseAI.EAIAnimController m_eController;
};

struct SAIMessage
{
    var noexport Engine.BaseAI.EAIMessageType m_eType "Type of message.";
    var noexport Actor m_aFrom "Who the message came from.";
    var noexport Actor m_aSubject "Actor associated with this message.";
    var noexport int m_nData "Miscellaneous data.";
    var noexport float m_fTime "Time this message arrived.";
};

struct SAIHealthTrigger
{
    var() noexport float Health "When I am less than or equal to this health....";
    var() noexport deprecated name Event "I trigger this event...";
};

struct SAIInventoryInfo
{
    var() noexport Engine.BaseAI.EAIMount m_eMountType "To mount or not to mount.  Optional.  If not set, default for item type will be used.";
    var() noexport name m_fnMountBone "Bone this item mounts to.  Optional.  If not set, default for item type will be used.";
    var() noexport Vector m_vMountOffset "Offset from mount bone.  Optional.  If not set, default for item type will be used.";
    var() noexport Rotator m_rMountRotation "Rotation offset from mount bone.  Optional.  If not set, default for item type will be used.";
    var() noexport float m_fDrawScale "DrawScale of the attachment. Less than or equal to 0.0 is treated the same as 1.0";
    var() noexport name m_fnEquippedAnim "Animation to play when equipped.";
};

struct SAIInventorySpawnInfo
{
    var() noexport Engine.BaseAI.EAIInventory m_eInventoryType "Type of inventory to give the AI.";
    var() noexport bool m_bStartActivated "Start with this item activated.";
    var() noexport bool m_bStartEquipped "Start with this item equipped / mounted.";
    var() noexport bool m_bUseable "If TRUE, the AI can actually use this item... if FALSE, he's just holding it for Duke or something.";
    var() noexport SAIInventoryInfo m_Overrides "Options that you can override for an inventory item.";
    var Inventory m_aSpawnedItem;
};

struct SPathCache
{
    var bool Valid;
    var int Count;
    var Vector TargetPos;
    var Actor RefActor;
    var float ClipTolerance;
    var Vector NextPathPos;
    var int FinalDest;
    var Engine.BaseAI.EAIPathResult Result;
};

struct SAIDamageInfo
{
    var bool Valid;
    var Pawn Instigator;
    var float Damage;
    var Engine.Object.EPawnBodyPart Part;
    var class<DamageType> DamageType;
    var Vector pos;
    var Vector Dir;
    var float Time;
};

struct SAIDamageScale
{
    var class<Actor> QualifierClass;
    var float DamageScale;
    var array< class<DamageType> > QualifierDamageTypes;
    var array< class<DamageType> > QualifierNotDamageTypes;
};

struct SWeaponManager
{
    var Engine.BaseAI.EAIWeapManMode Mode;
    var class<Weapon> CurrentWeaponClass;
    var bool HoldFire;
    var float MinRange;
    var float MaxRange;
    var float IdealMinRange;
    var float IdealMaxRange;
    var int ReloadThresh;
    var int MinShots;
    var int RndShots;
    var float MinVolleyInterval;
    var float RndVolleyInterval;
    var Vector StandingFireOffset;
    var Vector CrouchingFireOffset;
    var Vector ProneFireOffset;
    var Vector PipeBombFireOffset;
    var int ShotsFired;
    var int ShotCount;
    var transient float Gate;
    var bool ForceFire;
    var bool NoFire;
    var bool ChargeWeapon;
    var float WeaponChargeTime;
    var transient float ScanGate;
    var transient float RefreshScanGate;
    var Rotator ScanRot;
    var Vector ScanTarget;
    var float ScanTrackRate;
    var float ActionPointDistance;
    var AIActor.EAIWeaponClearShotType ClearShotRequirement;
    var bool MeleeFrozenTargets;
};

struct SGuardInfo
{
    var bool CanGuard;
    var bool IsGuardingActor;
    var bool IsGuardingPos;
    var Actor GuardedActor;
    var Vector GuardedPos;
    var float InnerRange;
    var float OuterRange;
    var float BaseInnerRange;
    var float BaseOuterRange;
    var bool bDontScaleRangeWithDrawScale;
    var bool AlignWith;
    var float AlignmentOffset;
    var float AbortRange;
    var bool MustBeVisible;
    var bool AllowAvoidDanger;
    var bool AllowDodge;
    var bool bStaticGuardHack;
    var bool bAvoidGuardedPlayer;
};

struct PopUpInfo
{
    var() array<PopUpCfg> Entrys;
    var() int PrimaryChoices;
    var() int IdealAngle;
};

struct SPopUpState
{
    var() float DamageTaken;
    var() bool bWaitCompromised;
    var() bool bForceHoldStop;
    var() int ShotsFired;
};

struct SMoveInfo
{
    var Vector Disp;
};

struct STargetEvalInfo
{
    var AIActor MyOwner;
    var transient float EvalGate;
    var float EvalInterval;
    var bool Suspended;
    var bool bSuspendedWithNoTarget;
    var Engine.BaseAI.EAITargetEval Evaluator;
    var bool ForceUpdate;
    var bool MustBePawn;
    var bool MustBeSighted;
    var bool MustBeReachable;
    var bool CanTargetProjectiles;
    var bool CanAvoidTargetableProjectiles;
    var Actor LastTarget;
    var float LastTargetEndTime;
};

struct AITransition
{
    var() name Ident;
    var() Engine.BaseAI.EAICondition Cond;
    var() name Func;
    var() Engine.BaseAI.EAIWindow Win;
    var() Engine.BaseAI.EAICode Code;
    var private int StateTableIndex;
};

struct AITransitionAction
{
    var() AITransition Transition;
    var() Engine.BaseAI.EAICode Code;
    var() name State;
    var() name Node;
};

struct AIState
{
    var() name FSM;
    var() name Ident;
    var() bool FSMSucc;
    var() bool FSMFail;
    var() array<AITransition> Transitions;
    var private int NodeIndex;
};

struct AINode
{
    var() name Ident;
    var private Engine.BaseAI.EAINodeStatus Status;
    var private bool ReportedInvalid;
    var() Engine.BaseAI.EAICondition SucCond;
    var() name SucFunc;
    var() Engine.BaseAI.EAICondition FailCond;
    var() name FailFunc;
    var() Engine.BaseAI.EAIOp Op;
    var private int OpRef;
    var() array<AITransition> SharedTransitions;
    var array<int> StateTable;
    var private int CurStateIndex;
};

struct SAnimX
{
    var name AnimName;
    var bool UseExactAnimName;
    var int RefId;
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var Vector TargetFacePos;
    var Vector TargetSyncPos;
    var AIActor TargetSyncActor;
    var float FaceThreshold;
    var float ExitTime;
    var bool FullAnim;
    var bool Sync;
    var bool SyncActor;
    var name SyncWaitAnimName;
    var bool FinishAlone;
    var bool MustFinish;
    var int Mode;
    var int TurnDir;
    var bool bExitOnLand;
    var bool bSucceedOnFail;
};

struct SMultiAnimInfo
{
    var() int AnimIndex;
    var() float MinTime;
    var() float RndTime;
    var() float Gate;
    var() float MinInterval;
    var() bool RequireLOS;
    var() bool RequireLOSFromWeapon;
    var() bool FaceTarget;
    var() name AnimName;
};

struct SControlX
{
    var class<dnControl> ControlType;
    var dnControl MyControl;
    var name AnimName;
    var float Time;
    var bool IsControlled;
    var bool DieOnTakeDamage;
    var bool AssumeCanFit;
};

struct SFall
{
    var int Mode;
    var float LandingThresh;
    var float HeavyLandingThresh;
    var float StartZ;
    var int RefId;
    var int AnimSet;
    var bool ToggleIK;
};

struct SGotoX
{
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var Vector TargetPos;
    var Actor RefActor;
    var Vector NextPos;
    var int FinalDest;
    var Engine.BaseAI.EAIOffsetType OffsetType;
    var float Range;
    var float Bearing;
    var float Height;
    var float ClipTolerance;
    var Engine.BaseAI.EAIMoveSpeed Speed;
    var float SpeedScale;
    var Engine.BaseAI.EAIFocus Focus;
    var Actor FocusActor;
    var Vector FacePos;
    var int RefId;
    var Engine.BaseAI.EAIGotoXMode Mode;
    var float SideArcTurnSpeedThresh;
    var float StepBackwardsSpeedThresh;
    var float StartAngleSideSector;
    var float StartAngleBackSector;
    var float MoveBackwardsDistThresh;
    var float SideStepDistThresh;
    var int MaxSteps;
    var bool PreVerified;
    var int TurnDir;
    var DoorMoverEx MyDoorEx;
    var bool ForceEval;
    var bool ForceAnim;
    var transient float AnimChangeGate;
    var float StuckTime;
    var transient float Gate;
    var bool bStopToTurn;
    var transient float EvalGate;
    var transient float EvalGateTime;
    var int EvalCount;
    var bool bDisableEvalGate;
    var float ConstraintStrengthOverride;
    var Engine.BaseAI.EAIPathFailMode PathFailMode;
    var bool bWaitingOnDynamicBlocker;
    var float bWaitTime;
    var Vector TargetExtent;
    var bool bDebug;
    var float FlyConstraintStrength;
    var bool bUseAccelerationWhenFlying;
    var bool ExitOnLand;
    var float ExitOnLandHeight;
    var Engine.Object.EBitModifier UseAnimDispDirMod;
};

struct SAIPhysics
{
    var bool bDebug;
    var float AccelRateEx;
    var float SlowAccelRateEx;
    var float AirControlEx;
    var float SlowSpeedScale;
    var float VertAccelRateEx;
    var bool bDisableGroundFinder;
    var float MaxSpeed;
    var float MaxSpeedDamping;
    var float MaxSpeedOtherDir;
    var float MaxSpeedOtherDirDamping;
    var bool bDisablePhysicsConstraints;
};

struct STeleport
{
    var Vector Destination;
    var Rotator DestinationRotation;
    var class<SoftParticleSystem> StartParticleSystem;
    var class<SoftParticleSystem> EndParticleSystem;
    var Weapon_LightEx StartLight;
    var Weapon_LightEx EndLight;
    var name StartSound;
    var name EndSound;
    var ActionPoint EndActionPoint;
    var name StartAnimName;
    var name EndAnimName;
    var MaterialEx StartOverlay;
    var bool bFaceTarget;
    var bool bValid;
    var int Mode;
    var float MinTeleportDist;
    var float MaxTeleportDist;
    var float Delay;
    var bool bCantDie;
    var bool bForceLandOnFinish;
    var bool bForceJetpackOnFinish;
    var bool bSkipStartEffects;
};

struct SRappel
{
    var() name StartAnimName;
    var() name IdleAnimName;
    var() name EndAnimName;
    var() name BoneName;
    var() float GravityScale;
    var bool bOverrideAttachToInfo;
    var Actor AttachToActor;
    var name AttachToBone;
    var class<BeamSystem> BeamSystemClass;
    var BeamSystem MyBeamSystem;
    var int Mode;
};

struct SFreeMove
{
    var Engine.BaseAI.EAIFreeMoveMode Mode;
    var float MinDotToTarget;
    var float MaxDotToTarget;
    var float ExitTime;
    var Vector FreeMoveTarget;
    var float FreeMoveVelocity;
    var float FreeMoveMaxVelocity;
    var float StoppingRate;
    var float StoppingRestitution;
    var Vector startLocation;
};

struct SHaywire
{
    var() bool bAllowHaywire;
    var() float MinTime;
    var() float MaxTime;
    var() Vector LinearAccel;
    var() Vector AngularAccel;
    var() float HaywireStartTime;
    var() float MinTimeToExplode;
    var() float ChanceExplosion;
    var() float HurtRadiusDamage;
    var() float DamageRadius;
    var() float DamageRadiusFallOffStart;
    var() class<dnFriendFX_Spawners> ExplosionClass;
    var() class<LightEx> ExplosionLight;
    var() name ExplosionSoundName;
    var() Vector HitNormal;
};

struct SCharge
{
    var() Vector ChargeDir;
    var() Vector ChargeTarget;
    var() float ChargeStartTime;
    var float CoolDownStartSpeed;
    var() float StartVelocity;
    var() float MaxVelocity;
    var() float ReturnVelocity;
    var() float RampUpTime;
    var() float CoolDownTime;
    var() bool RequireLOS;
    var() Engine.BaseAI.EAIChargeState ChargeState;
    var() float ConstraintStrength;
};

struct STakeOff
{
    var Vector TakeOffVel;
    var float TakeOffIdleTime;
    var float TakeOffIdleTimeRnd;
    var float GravityScale;
    var float IdealTakeOffHeight;
    var Vector IdealTakeOffVel;
    var bool AllowFire;
    var Vector TakeOffTarget;
};

struct SHover
{
    var float MinHoverTime;
    var float RndHoverTime;
};

struct SIdle
{
    var float MinIdleTime;
    var float RndIdleTime;
    var bool bFaceTarget;
    var name AnimName;
};

struct SAIAmbientSoundInfo
{
    var() bool bDebug;
    var() float TargetAquiredMinInterval;
    var() float NoTargetIdleInterval;
    var() float NoTargetIdleRnd;
    var() float BattleIdleInterval;
    var() float BattleIdleRnd;
    var name TargetAquiredSoundName;
    var name TargetLostSoundName;
    var name NoTargetSoundName;
    var name TargetVisibleSoundName;
    var name TargetNotVisibleSoundName;
};

struct SJump
{
    var int Mode;
    var Vector JumpVel;
    var float HeavyLandingThresh;
    var bool AppliedJumpVel;
    var float StartZ;
    var int RefId;
    var int AnimSet;
    var Vector FrameVelocity;
    var bool bDisableIK;
    var bool bRestoreIKPreLand;
    var float ExitTime;
    var Engine.BaseAI.EAIJumpType JumpType;
    var bool FaceTarget;
    var Actor FocusActor;
    var bool AutoPitch;
    var float PitchRate;
    var float PitchRateLand;
    var float MaxPitch;
    var float MaxVelocity;
    var bool bDebug;
    var bool bTakeOffNoLand;
    var float TakeOffIdleTime;
    var float FlyingGravityScale;
    var Vector TargetPos;
    var bool bCheckTargetPos;
    var bool bUseAccelaration;
    var float AccelerationScale;
    var Vector Fudge;
    var bool bSnapToTargetDuringLand;
    var bool bRequireCompleteSnap;
    var bool bSnapActive;
    var bool bLandAnimComplete;
    var float StopLinearDamping;
    var bool bAllowProcFireDuringFall;
};

struct SJumpAttack
{
    var Actor TargetActor;
    var int Mode;
    var int Type;
    var bool AttackOnTakeoff;
    var bool Attacked;
    var bool AttackSuccess;
    var bool AppliedJumpVel;
    var int RefId;
    var Vector FrameVelocity;
    var bool bCanJumpAttackShrunkTarget;
    var float ShrunkTargetHeightScale;
    var float ShrunkTargetDistanceScale;
    var transient float Gate;
    var() float MinInterval;
    var float GroundFinderGate;
    var float GroundFinderInterval;
    var Vector PresetFrameVelocity;
    var Vector DefaultPresetFrameVelocity;
    var Engine.BaseAI.EAIJumpAttackType JumpAttackType;
    var float ParabolaJumpHeight;
    var float ParabolaMinJumpHeight;
    var float ParabolaMaxJumpHeight;
    var float GroundFinderLockout;
    var bool bInstantJump;
    var bool bUsePresetVelocity;
    var bool bCheckClearShot;
    var bool bCheckHasPath;
    var bool bCheckClearPath;
    var bool bDontApplyDirectDamage;
    var bool bDisabled;
};

struct SDodgeInfo
{
    var name AnimName;
    var Vector PhysicsFrameVelocity;
    var Engine.BaseAI.EAIDodgeType DodgeType;
};

struct SStompInfo
{
    var() noexport float StompRadius "The range at which we attempt to stomp. Should be slightly larger than StompDamageRadius";
    var() name AnimName;
    var() name BoneName;
    var() float StompDamageAmount;
    var() float StompDamageRadius;
    var() float StompDamageVel;
    var() float StompDamageLift;
    var() bool bDebug;
    var() noexport float SafeHeight "If we are this many units height than where the stomp happens, we dont take damage";
    var() noexport bool bCanStompShrunk "Can we stomp full sized pawns?";
    var() SViewShakeInfo ShakeInfo;
    var() float ShakeRadius;
    var() class<dnFriendFX_Spawners> ParticleEffectClass;
    var() array<name> AdditionalEffectBones;
    var Vector StompLocation;
    var() bool bDontFaceTarget;
    var() bool bLightRumbleOnDamage;
};

struct SStubToeInfo
{
    var() bool bDebug;
    var() bool bEnabled;
    var() name AnimName;
    var() bool bBerzerkAfterStub;
    var() bool bDropWeapon;
    var() float MinImpactVelocity;
    var() noexport float MinToeStubInterval "How much time must pass between subsequent toe stubs.";
    var float ToeStubGate;
};

struct SMoveUnderground
{
    var Vector DestLocation;
    var Rotator DestRotation;
    var float StartTime;
    var float Duration;
};

struct SPause
{
    var float Time;
    var bool EndOnHeadAim;
    var bool EndOnEyeAim;
};

struct SPlaceTripMine
{
    var Actor TargetActor;
    var int Mode;
    var bool ResumeLookEval;
};

struct SSelectWeapon
{
    var class<Weapon> NewWeaponClass;
    var bool QuickSwitch;
    var int Mode;
    var int RefId;
};

struct SSetAim
{
    var Engine.BaseAI.EAIAim DesiredState;
    var int Mode;
    var float Time;
};

struct SSetFireMode
{
    var bool On;
    var bool Expedite;
    var float AbortTime;
    var float FinishTime;
    var bool Done;
    var bool DontIdle;
};

struct STurnToX
{
    var float ExitTime;
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var Vector TargetPos;
    var float FaceThreshold;
    var int TurnDir;
    var float AnimThreshold;
    var bool PlayTurnAnim;
};

struct SUseXItemInfo
{
    var() name ItemTag;
    var() name InputDipstacherTag;
    var AIInputDispatcher_Base InputDispatcher;
    var dnUsableSomething Item;
};

struct SUseX
{
    var InteractiveActor TargetActor;
    var AIInputDispatcher_Base InputDispatcher;
    var name AttachedEvent;
    var int Attempts;
    var float AttemptInterval;
    var bool Using;
    var bool ForceAttach;
    var int RefId;
    var bool AllowProceduralAim;
    var bool bAttached;
    var bool bDetaching;
};

struct SAnimPreset
{
    var Engine.BaseAI.EAIAnimXType AnimType;
    var name AnimName;
    var bool UseExactAnimName;
    var float ExitTime;
    var Actor TargetActor;
    var Vector TargetPos;
    var float FaceThreshold;
};

struct SGotoPreset
{
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var Vector TargetPos;
    var Actor RefActor;
    var Engine.BaseAI.EAIOffsetType OffsetType;
    var float Range;
    var float Bearing;
    var float Height;
    var float ClipTolerance;
    var Engine.BaseAI.EAIFocus Focus;
    var Actor FocusActor;
    var int MaxSteps;
    var bool bDebug;
};

struct STripMinePreset
{
    var Actor TargetActor;
};

struct STurnToPreset
{
    var Engine.BaseAI.EAITargetType TargetType;
    var Actor TargetActor;
    var Vector TargetPos;
    var float ShouldTurnThresh;
    var float FaceThresh;
};

struct SWeaponPreset
{
    var() class<Weapon> WeaponType;
};

struct SUsePreset
{
    var Actor TargetActor;
    var name InputDispatcherTag;
    var name AttachedEvent;
    var int Attempts;
    var float AttemptInterval;
    var bool ForceAttach;
    var bool AllowProceduralAim;
};

struct SAbortScriptInfo
{
    var SAbortScriptMotive_SeeActor MotiveSeeActor;
    var SAbortScriptMotive_HearSound MotiveHearSound;
    var SAbortScriptMotive_Damaged MotiveDamaged;
    var SAbortScriptMotive_Bumped MotiveBumped;
    var SAbortScriptMotive_Triggered MotiveTriggered;
    var SAbortScriptMotive_Shrunk MotiveShrunk;
    var bool ShouldAbort;
    var int EgoChange;
    var name OtherActorTag;
    var name AbortEvent;
    var noexport bool bUseAbortEventStuck "Set to true and we will use AbortEventStuck when stuck. if false, stuck aborts just fire off AbortEvents like normal";
    var noexport name AbortEventStuck "An event to trigger if I abort because I was stuck. If none we will still fire AbortEvent if stuck";
    var bool ChangeScriptTag;
    var name ChangedScriptTag;
    var bool KeepProp;
    var bool CanFall;
    var noexport bool PlayPainDontAbort "If true we will play pain animations BUT WONT ABORT the script. If false we wont pain. If true we will. Either way we will only abort if MotiveDamage is met";
};

struct SAISquadChannel
{
    var() noexport name ChannelName "Name of channel we are communicating on";
    var() noexport float MaxDistance "Max distance between AI for squad communication to work. 0 = no max distance";
};

struct SDroolInfo
{
    var() float MinSpitTime;
    var() float RndSpitTime;
    var() float SpitOnPainChance;
    var() name Bone;
    var() Vector Location;
    var() Rotator Rotation;
    var() class<dnFriendFX_Spawners> SpawnClass;
};

struct SAIRangeInfo
{
    var() noexport float ActionPointClosestMaxTravelDist "How far are we willing to go when wanting to go to closest action point";
    var() noexport float ActionPointClosestMaxTargetDist "Max distance we are willing to be from target when going to an AP";
    var() noexport float ActionPointClosestJumpableMaxTravelDist "How far are we willing to go when wanting to go to closest action point";
    var() noexport float ActionPointClosestFlyerMaxTravelDist "How far are we willing to go when wanting to go to closest action point";
};

struct SAIShrunkInfo
{
    var() bool bRunFromBiggerEnemies;
    var() float MinSafeDistanceFromBigEnemy;
};

struct SAIPerformanceInfo
{
    var() array<float> TickTime;
    var float TickTimeLastFrame;
    var float PathTimeLastFrame;
    var float ProcAimTimeLastFrame;
    var bool SetLocation;
    var bool ExecuteDecisionTree;
    var int Cycles;
    var float Path_PreStaticPath;
    var float Path_PostStaticPath;
    var float Path_GenerateStaticPath;
    var float Path_FinalizeNextPathPos;
};

struct SDeathImpulseInfo
{
    var bool bDebug;
    var bool bEnabled;
    var Vector ImpulseMag;
    var bool bImpulseRelativeToActorRotation;
};

struct SGotoXHistory
{
    var SGotoX GotoXParms;
    var Vector Location;
    var Rotator Rotation;
    var Engine.BaseAI.EAICode Code;
    var float Timestamp;
};

struct SAIDebugMessage
{
    var string msg;
    var Color C;
    var float TimeExpire;
};

struct SPathingHistory
{
    var Vector Location;
    var Rotator Rotation;
    var Vector Destination;
    var Vector NextPosition;
    var int FinalDest;
    var float Time;
    var Engine.BaseAI.EAIPathResult Result;
    var bool bActorWasInValidArea;
    var SPathInfo PathInfo;
};

struct SScriptFailInfo
{
    var name AIState;
    var Engine.BaseAI.EAIOp AIOP;
    var ScriptMethod ScriptMethod;
    var string ScriptMethodStr;
    var float Timestamp;
};

struct SEyeAimInfo
{
    var name BoneName;
    var Vector Alignment;
    var float MaxAngleOffset;
};

var Vector DisplacementLastFrame;
var Vector LocationLastFrame;
var(AIMesh) array<Mesh> OverrideMeshList;
var(AIMesh) Mesh OverrideMesh;
var array<Color> RandomActorColor;
var name RandomActorColorGroupID;
var bool MountLightEx;
var class<LightEx> MountedLightExClass;
var SMountedActorPrefab MountedLightExMountPrefab;
var() LightEx MountedLightEx;
var array<SPathCache> PathCache;
var bool AllowFrozenExecution;
var SAIDamageInfo DamageInfo;
var(AIDamage) array<SAIDamageScale> DamageScaleInfo;
var private Engine.BaseAI.EAIExecutive Executive;
var private bool ExecutiveSuspended;
var(AIBrain) transient float DecisionTreeGate;
var(AIBrain) float DecisionTreeInterval;
var(AIBrain) array<AINode> Nodes;
var(AIBrain) array<AIState> FSMStates;
var(AIBrain) array<AITransitionAction> TransitionHistory;
var(AIBrain) array<string> StateEndMessages;
var SAISquadChannel SquadChannel;
var Engine.BaseAI.EAIOp CurrentOp;
var private int CurrentOpRef;
var private Engine.BaseAI.EAIOpStatus CurrentOpStatus;
var bool CurrentOpMustFinish;
var bool CurrentOpShouldFinish;
var int CurrentOpMode;
var Engine.Object.EPawnBodyPart WoundedBodyPart;
var Engine.BaseAI.EAIArcSector WoundedBodySector;
var Engine.BaseAI.EAIAnimController PostOpAnimCtrl;
var noexport bool CanSeeTargets "Can see targets?";
var noexport bool CanHearTargets "Can hear targets? (see also bCanHear)";
var noexport float ClearTargetTime "If time since contact with a traget exceeds this threhold, the target is cleared.";
var noexport float TargetVisTestInt "Interval between visibility tests.";
var float SightCounter;
var bool HasWeaponTargetEvaluator;
var STargetEvalInfo WeaponTargetEvalInfo;
var TargetEvaluator WeaponTargetEvaluator;
var float WeaponConeAngle;
var float PlayerHate;
var(AIBehavior) float MinPlayerHate;
var(AIBehavior) float MaxPlayerHate;
var(AIBehavior) float PlayerHateRecoverRate;
var bool HasLookTargetEvaluator;
var STargetEvalInfo LookTargetEvalInfo;
var TargetEvaluator LookTargetEvaluator;
var float LookConeAngle;
var private string BaseLookTargetString;
var private string GlanceLookTargetString;
var float MinGlanceTime;
var float RndGlanceTime;
var float SameGlanceTargetInterval;
var float ChanceTryGlanceAgain;
var float MinGlanceRest;
var float RndGlanceRest;
var array<STargetSlot> TargetActors;
var(AITarget) AITarget PrimaryTarget;
var(AITarget) Actor PrimaryTargetActor;
var(AITarget) AITarget FollowTarget;
var(AITarget) Actor FollowTargetActor;
var(AIDebug) bool DebugDrawLOS;
var(AICache) float CachedLOSDistance;
var(AICache) float CachedWeaponLOSDistance;
var(AICache) float CachedProjectileLOSDistance;
var SAimerInfo WeaponAimerInfo;
var SAimerInfo MuzzleAimerInfo;
var SAimerInfo HeadAimerInfo;
var private Aimer WeaponAimer;
var private Aimer HeadAimer;
var float WeaponTrackRate;
var float HeadTrackRate;
var private float ShootAngleThresh;
var private bool InShootAngleThresh;
var private bool EndStateOnWeaponTargetLost;
var private bool EndStateOnWeaponTargetInThresh;
var private bool EndStateOnLookTargetLost;
var private bool EndStateOnLookTargetInThresh;
var bool bSpecialMeshAccurateLOSChecks;
var(AIWeapons) noexport bool HasWeaponManager "True if this AI needs to handle weapons.";
var(AIWeapons) SWeaponManager WeaponManager;
var class<WeaponCfg> WeaponConfig;
var(AIWeapons) noexport array< class<Weapon> > Weapons "List of weapon to startup with.";
var(AIWeapons) noexport array< class<Weapon> > RandomWeapons "Optional list of weapons.  If non-zero, one will be randomly chosen to be added to the weapons list.";
var(AIWeapons) noexport bool SpawnWithWeaponDrawn "Spawn with a weapon already in hands?";
var(AIWeapons) noexport bool ForceWeaponActive "Consider weapon to always be active?";
var(AIWeapons) noexport class<Weapon> InitialWeapon "Optional weapon to be held on startup.";
var class<Pistol> PistolClass;
var(AIWeapons) noexport float WpnSteadyHorizError "Weapons Horizontal error when stationary (unreal rotator units)";
var(AIWeapons) noexport float WpnSteadyVertError "Weapons Vertical error when stationary (unreal rotator units)";
var(AIWeapons) noexport float WpnMovingHorizError "Weapons Horizontal error when moving (unreal rotator units)";
var(AIWeapons) noexport float WpnMovingVertError "Weapons Vertical error when moving (unreal rotator units)";
var noexport float LeadTimeK "If non-zero, we will lead the target by this ratio (1.0 means intercept, 2.0 would overshoot by the intercept distance, 0.5 would undershoot.)";
var bool ForceDirectShot;
var bool ForceNonDirectShot;
var float AimAtTargetTimeThresh;
var bool CanScan;
var(AIWeapons) float MinWeaponScanTrackRate;
var(AIWeapons) float RndWeaponScanTrackRate;
var(AIWeapons) float LookTrackRateK;
var(AIWeapons) float MinScanInterval;
var(AIWeapons) float RndScanInterval;
var(AIWeapons) float MinScanDuration;
var(AIWeapons) float RndScanDuration;
var(AIWeapons) float MinScanRefreshTime;
var(AIWeapons) float RndScanRefreshTime;
var(AIWeapons) int MinScanPitch;
var(AIWeapons) int MaxScanPitch;
var(AIWeapons) int MinScanYaw;
var(AIWeapons) int MaxScanYaw;
var(AIWeapons) noexport int NumPipeBombs "Set to -ve for an infinite supply.";
var(AIWeapons) noexport float MinPipeBombInterval "Minimum time that must pass between pipebomb attacks.";
var(AIWeapons) class<dnGrenade> PipeBombClass;
var dnGrenade MyPipeBomb;
var Vector PipeBombVel;
var name RightHandPipebombMount;
var name LeftHandPipebombMount;
var int NumPipeBombBeeps;
var(AIPipeBomb) float MinPipeBombTime;
var(AIPipeBomb) float MaxPipeBombTime;
var(AIPipeBomb) float MinHorizDistPipeBomb;
var(AIPipeBomb) float MaxHorizDistPipeBomb;
var(AIPipeBomb) float MinVertDistPipeBomb;
var(AIPipeBomb) float MaxVertDistPipeBomb;
var(AIPipeBomb) float MinPipeBombArcHeight;
var(AIPipeBomb) float MaxPipeBombArcHeight;
var(AIPipeBomb) float PipeBombChance;
var transient float PipeBombGate;
var bool bIgnoreTripMines;
var array<LaserMine> TripMines;
var float MinTargetVisibleTime;
var(AIWeapons) bool bDisableWeaponDrops;
var(AIWeapons) bool bAllowWeaponDropsPlayerNotSameSize;
var SGuardInfo GuardInf;
var() array<PopUpInfo> Popups;
var PopUpCfg PopUp;
var SPopUpState PopUpState;
var bool bNoWeaponChargePopUp;
var private transient float BlindFireGate;
var(AIBehavior) noexport bool UseActionPoints "Does this actor use action points?";
var(AIBehavior) noexport array<name> ActionPointTags "We can only use action points that have this tag";
var noexport float ChanceStayAtActionPoint "DEPRECATED";
var noexport int ActionPointIndex "DEPRECATED";
var noexport int ActionPointDesiredIndex "DEPRECATED";
var array<ActionPoint> ActionPoints;
var array<ActionPoint> ReloadActionPoints;
var ActionPoint ReloadActionPoint;
var ActionPoint NextActionPoint;
var float ActionPointMeleeK;
var ActionPoint ActionPoint;
var Vector ActionPointUserLoc;
var bool PreShrinkUseActionPoints;
var ActionPoint LastActionPoint;
var name LastActionPointGroup;
var(AIUse) noexport bool UseActionFollow "If true, this AI can be *used* to make it follow / stop follow.";
var bool FaceAnims;
var noexport float MinBlinkTime "Minimum time between blinks.";
var noexport float MaxBlinkTime "Maximum time between blinks.";
var noexport int NumEyeSets "How many sets of eyes?";
var anim name EyesClosedAnim;
var noexport array<SEyeAimInfo> EyeAimInfos "A list of eye bones used for aiming.";
var Vector RollForwardInfo;
var Vector RollLeftInfo;
var Vector RollRightInfo;
var float RollTime;
var Engine.BaseAI.EAICloaking Cloaking;
var float CloakValue;
var float CloakRate;
var MaterialEx CloakMaterial;
var bool HasTKShield;
var int TKShieldCollisionRadius;
var int TKShieldCollisionHeight;
var Actor TKShield;
var InteractiveActor TKObj;
var Vector TKObjVel;
var int TKCatchAnim;
var int NumSecondaryTKCatchAnims;
var array<name> TKIgnoreClasses;
var float MaxTKDistance;
var float MinTKDot;
var bool bForceTK;
var InteractiveActor DesiredProp;
var InteractiveActor Prop;
var(AIThrowProp) name ThrowPropTag;
var bool CanAnimHurl;
var float PickupItemRange;
var AIRelationshipMgr RelationshipMgr;
var array<SRelationship> Relations;
var(AIRelationships) noexport array<SRelationship> Relationships "Relationships to other characters.";
var(AIRelationships) noexport array<SRelationship> m_RelationOverrides "How this creature reacts to other classes.";
var bool bUseNormalPhysicsRotation;
var bool UseLatentMovement;
var bool UseTurnAnimRot;
var const float DecelerationDist;
var const float DesiredSpeed;
var float AIBaseMoveSpeed;
var bool ZeroMoveSpeed;
var bool ZeroMoveSpeedEnabled;
var bool bDampenSpeedWhileTurning;
var bool AutoRollWhileTurning;
var float AutoRollRate;
var float AutoUnrollRate;
var bool AutoPitchWhileTurning;
var float AutoPitchRate;
var float AutoUnPitchRate;
var Vector LocalUp;
var Rotator DesiredDir;
var bool DisablePhysics;
var bool bUseAnimDispSpeed;
var bool bUseAnimDispDir;
var bool bUseAnimRotation;
var bool bAnimCutScene;
var bool bApplyAnimCutSceneVelocity;
var Vector AnimCutSceneVelocity;
var bool bUseAcceleration;
var bool SavedUseAnimDispSpeed;
var bool SavedUseAnimDispDir;
var bool SavedUseAnimRotation;
var bool SavedAnimCutScene;
var bool SavedUseAcceleration;
var PointTracker BodyTargetTracker;
var float BodyAlignRate;
var float BodyAlignRateFlying;
var float BodyAlignThresh;
var float BodyAlignScale;
var bool AlignYaw;
var bool AlignPitch;
var float AirSpeedScale;
var float GroundSpeedScale;
var float AnimDispSpeedScale;
var bool bIgnoreZAnimDisp;
var bool bUseWeaponMovementAnims;
var bool bUseWeaponIdle;
var bool bWeaponActiveAnimsActive;
var bool bUseWeaponReadyIdle;
var bool AimAtEye;
var bool bTryBackupPathingOnFailure;
var float NextBackupPathingTime;
var float BackupPathingCooldown;
var Vector AIAdditiveVelocity;
var float InstaGibRandomImpulse;
var SAnimPreset AnimPreset;
var SGotoPreset GotoPreset;
var SJumpPreset JumpPreset;
var STripMinePreset TripMinePreset;
var STurnToPreset TurnToPreset;
var SWeaponPreset WeaponPreset;
var SUsePreset UsePreset;
var(AIBehavior) array<SIdle> IdleInfo;
var(AISound) SAIAmbientSoundInfo AmbientSoundInfo;
var ScriptPlayer ScriptPlayer;
var SAbortScriptInfo AbortScriptInfo;
var(AIScripts) noexport ScriptObj SpawnScript "Script to play when this AI spawns.";
var(AIScripts) noexport name ScriptTag "If this is set the AI will attempt to trigger it when under nomral AI control.  Use this in conjunction with dispatchers and script triggers to play scripts on the AI.";
var(AIScripts) noexport name UsedScriptTag "If this is set the AI will attempt to trigger it when the player uses this actor.";
var float LastScriptLoopTime;
var bool bFailedBecauseStuck;
var(AIEvents) noexport name TargetAquiredEvent "This is fired every time we aquire a valid target.";
var(AIEvents) noexport name TargetClearedEvent "This is fired every time we clear our target.";
var float NextMessageTime;
var array<SAIMessage> MessageQueue;
var(AIAnim) Engine.BaseAI.EAIAnimController InitialAnimController;
var SAIAnimController AnimControllers[10];
var SAICurAnimController AnimCtrl;
var SAnimX AnimXParms;
var SControlX ControlXParms;
var SFall FallParms;
var(AIBehavior) SGotoX GotoXParms;
var(AIBehavior) SFreeMove FreeMoveParms;
var(AIBehavior) SHaywire HaywireParms;
var(AIBehavior) SJump JumpParms;
var(AIBehavior) STakeOff TakeOffParms;
var(AIBehavior) SJumpAttack JumpAttackParms;
var(AIBehavior) SCharge ChargeParms;
var(AIBehavior) SDroolInfo DroolParms;
var(AIBehavior) SHover HoverParms;
var(AIBehavior) SAIRangeInfo RangeParms;
var(AIBehavior) SAIPhysics PhysicsParms;
var(AIBehavior) SAIShrunkInfo ShrunkParms;
var(AIBehavior) array<SMultiAnimInfo> MultiAnimParms;
var() int MultiAnimIndex;
var() int MultiAnimMode;
var SMoveUnderground MoveUndergroundParms;
var SPause PauseParms;
var SPlaceTripMine PlaceTripMineParms;
var SSelectWeapon SelectWeaponParms;
var SSetAim SetAimParms;
var SSetFireMode SetFireModeParms;
var STurnToX TurnToXParms;
var SUseX UseXParms;
var(AIBehavior) STeleport TeleportParms;
var(AIBehavior) SRappel RappelParms;
var(AIBehavior) array<SUseXItemInfo> UseableItems;
var AIActorFactory Factory;
var AIActorFactoryManager FactoryManager;
var name SpawnAnimSeq;
var name SpawnAnim;
var private name InitAnim;
var ScriptTrigger LastScriptTrigger;
var(AIDamage) noexport bool Invulnerable "If true, the AI's health cannot be modified.";
var(AIDeath) noexport bool bPlayDeathSound "If true, AI will play death sound.";
var(AIDeath) noexport float LedgeDistOverride "If > 0, this overrides the default distance that we look for a ledge to fall over when we die.";
var(AIDeath) noexport float SizeLedgeImpulse "Magnitude of the Impulse to give towards the nearest ledge if applicable.  If <= 0 just do normal death impusle.  3000 is a suggested value to try.";
var bool DieOnExitState;
var transient float PainOpGate;
var bool ShowPain;
var bool bHackNoDeathAnim;
var(AIDeath) float DeathAnimChance;
var(AIDeath) float ThrownObjectDeathAnimChance;
var class<dnControl> FinishMeControlType;
var name FinishMeAnimName;
var name FinishMeReviveAnimName;
var float FinishMeTimeout;
var bool FaceDamage;
var bool FaceDeath;
var bool WasExecuted;
var SDeathImpulseInfo DeathImpulseOverride;
var bool bDisableCorpseCleanup;
var bool bFixCorpseRoot;
var(AIDeath) SSoundInfo ExpandPopSound;
var Pawn ExpandInstigator;
var(AIHealth) noexport bool bHealthTriggerMultiple "If true, health triggers can be triggered mutliple times.";
var(AIHealth) noexport array<SAIHealthTrigger> HealthTriggers "List of events to fire off when health reaches certain points.";
var(AIPain) noexport bool bMeleeResetPainOpGate "If true, MeleeDamage will reset pain op timer allowing AI to play another pain animation.";
var(AIPain) noexport float MinPainOpInterval "Minimum time between pain ops.";
var(AIPain) noexport float RndPainOpInterval "Random time interval added to MinPainOpInterval.";
var(AIPain) noexport int MaxConsecutivePainOp "how many consecutive pain ops can we do?";
var(AIPain) noexport float MaxConsecutivePainInterval "after hitting a max pain op, how long before we pain again";
var int ConsecutivePainOp;
var(AIPain) float PainImpulseMagnitude;
var(AIPain) float PainImpulseMinDamage;
var(AIPain) bool bDontUseAIOPPain;
var(AIPain) int PainAnimRefID;
var(AIProcFire) array<SBoneAim> BoneAim;
var(AIProcFire) array<SBoneAim> MuzzleBoneAim;
var(AIProcFire) bool HasBoneAimer;
var(AIProcFire) bool DisableAimGrids;
var(AIProcFire) bool ProceduralMovingFire;
var(AIProcFire) array<name> ProcFireStates;
var(AIProcFire) array<Engine.BaseAI.EAIOp> ProcFireOps;
var(AIProcFire) bool ProcAimingEnabledThisFrame;
var(AIProcFire) bool CanProcFire;
var(AIProcFire) bool CanPopupAim;
var(AIProcFire) float PopUpFireGate;
var(AIProcFire) float ProcFireMaxTimeSinceSeen;
var(AIBehavior) array<SBoneAim> BoneHeadAim;
var(AIBehavior) bool HasBoneHeadAimer;
var(AIBehavior) noexport deprecated Actor HackAimFromRotationActor "Hack that allows us to use another Actor's rotation as our procedural aim base rotation.";
var name WeaponIdle;
var transient float MovingFireGate;
var bool ShouldFire;
var float MinMovingFireInterval;
var float RndMovingFireInterval;
var SBoneAimConstraints MuzzleBoneAimConstraints;
var SBoneAimConstraints WeaponBoneAimConstraints;
var SBoneAimConstraints HeadBoneAimConstraints;
var SBoneAimConstraints BodyBoneAimConstraints;
var SBoneAimConstraints WeaponBoneAimConstraintsOverride;
var bool bWeaponBoneAimConstraintsOverrideEnabled;
var bool BoneAimerOnTarget;
var bool HasWeaponAimer;
var bool HasHeadAimer;
var bool AimBodyAtHeadTarget;
var Vector GoalPos;
var(AITick) noexport bool StartTickDisabled "If TRUE, the creature will start with it's tick disabled and activate when it is rendered.  Leave TRUE for optimal performance.";
var(AIBehavior) noexport Engine.BaseAI.EAIAttackConstraint AttackConstraint "How to constrain the attacks that this creature can perform.";
var(AIBehavior) noexport bool AllowBezerk "Is this creature allowed to go bezerk?";
var(AIBehavior) noexport bool AllowProne "Are we allowed to go prone? Note: not implemented on all creatures";
var noexport float TryGotoAttackTime "If we havent seen the target for this long, attempt to find a new attack position. (NOTE: Only Partial character support)";
var float MaxTravelDist;
var(AIBehavior) float MinIdleTime;
var(AIBehavior) float RndIdleTime;
var float MinAggressiveIdleTime;
var float RndAggressiveIdleTime;
var float MinPauseTime;
var float RndPauseTime;
var float MinStunTime;
var float RndStunTime;
var float MaxTryTurnTime;
var float ShouldTurnThreshold;
var float FaceThreshold;
var bool bNeverPlayerTurnAnim;
var(AIMovement) float WalkSpeedScale;
var(AIMovement) float RunSpeedScale;
var float SideArcTurnSpeedThresh;
var float StepBackwardsSpeedThresh;
var float StartAngleSideSector;
var float StartAngleBackSector;
var float MoveBackwardsDistThresh;
var float SideStepDistThresh;
var float WalkDistThresh;
var float GotoPosRange;
var float GotoPosHeight;
var float GotoPosFlyingRange;
var float GotoPosFlyingHeight;
var float MinDistToGoal;
var float MinMoveAroundDist;
var float RndMoveAroundDist;
var float MinBackOffDist;
var float RndBackOffDist;
var float MinMoveSideDist;
var float RndMoveSideDist;
var float MinSpreadOutTime;
var float RndSpreadOutTime;
var(AIMelee) float MinMeleeRange;
var(AIMelee) float RndMeleeRange;
var(AIMelee) float MinMeleeHeight;
var(AIMelee) float RndMeleeHeight;
var int MaxGotoMeleeSteps;
var bool bForceMelee;
var(AIMelee) float MeleeZone;
var(AIMelee) float MeleeZoneHeight;
var float MinMeleeStrafeRange;
var float RndMeleeStrafeRange;
var int MinMeleeStrafeCycles;
var int RndMeleeStrafeCycles;
var float MeleeAttackRange;
var float MeleeAttackArc;
var bool MeleeFaceTarget;
var(AIMelee) float BiteDamageAmount;
var Vector BiteDamageVel;
var(AIMelee) float ClawDamageAmount;
var Vector ClawDamageVel;
var(AIMelee) float KickDamageAmount;
var Vector KickDamageVel;
var(AIBehavior) array<SStompInfo> StompInfo;
var int StompIndex;
var int ForcedStompIndex;
var(AIBehavior) noexport SStubToeInfo ToeStubInfo "How we get our toes stubbed";
var(AIBehavior) array<SDodgeInfo> DodgeInfo;
var int DodgeIndex;
var transient float DodgeGate;
var float DodgeInterval;
var SViewShakeInfo PlayerShrunkFootstepViewShake;
var bool bPlayerShrunkSpecialFootstep;
var float MinChargeRange;
var float MaxChargeRange;
var float MinChargeHeightDelta;
var float MaxChargeHeightDelta;
var float MinChargeAttackRange;
var float MaxChargeAttackRange;
var int MaxChargeSteps;
var int MinWeaponStrafeCycles;
var int RndWeaponStrafeCycles;
var(AIProjectile) class<dnProjectile> ProjectileClass;
var(AIProjectile) name ProjectileMuzzleName;
var(AIProjectile) float MinProjectileFireInterval;
var(AIProjectile) float RndProjectileFireInterval;
var(AIProjectile) transient float ProjecilteFireGate;
var bool ForceShootProjectile;
var(AIProjectile) bool bShootProjectileRequireLOS;
var(AIProjectile) bool bShootProjectileRequireSemiClearShot;
var(AIProjectile) bool bShootProjectileRequireTargetNotInStrTap;
var(AIProjectile) bool bShootProjectileFaceTarget;
var float MinAirAttackHeight;
var float MaxAirAttackHeight;
var(AIJump) noexport float MinJumpAttackRange "Min range that we can jump attack from";
var(AIJump) noexport float MaxJumpAttackRange "Poorly Named - think max distance from MinJumpAttackRange that we can jump attack";
var(AIJump) noexport float MaxJumpAttackHeight "Max height difference when we can still attempt jump attack.";
var(AIJump) bool bJumpAttackRequireTargetNotInStrTap;
var bool JumpAttackOnTakeOff;
var bool ForceJumpAttack;
var float JumpAttackBearingVariance;
var float JumpAttackHeightDelta;
var(AIFall) bool CanJump;
var(AIFall) bool HasStartFallAnim;
var(AIFall) bool HasTouchedGround;
var Vector JumpVel;
var float StartFallHeight;
var(AIFall) float FallDistThresh;
var(AIFall) float LandingThresh;
var(AIFall) float HeavyLandingThresh;
var(AIBehavior) float ChanceLand;
var(AIBehavior) Engine.Object.EBitModifier ForceStartJetpack;
var bool DoJetPackWobble;
var bool bIsFlying;
var(AIBehavior) float TimeTargetNotVisible;
var bool CanOpenDoors;
var(AIBehavior) bool AvoidDangers;
var bool InDanger;
var Vector DangerPos;
var array<Actor> IgnoredDangerActors;
var float MaxThreatAimAngle;
var float MoveAroundTime;
var float RndMoveAroundTime;
var(AIHaywire) noexport float HaywireChance "Chance of going haywire when shot to death";
var(AIHaywire) noexport float HaywireMinDuration "Min duration of Haywire state";
var(AIHaywire) noexport float HaywireMaxDuration "Max duration of Haywire state";
var(AIHaywire) noexport Vector HaywireLinearAccel "Linear acceleration to apply";
var(AIHaywire) noexport Vector HaywireLinearAccelVar "Variance to the linear acceleration to apply";
var(AIHaywire) noexport Vector HaywireAngularAccel "Angular acceleration to apply";
var(AIHaywire) noexport Vector HaywireAngularAccelVar "Variance to the angular acceleration to apply";
var(AIHaywire) noexport bool bForceHaywire "internal programmer nonsense.";
var(AINav) noexport name PathID "ID of the path used by this AIActor.  AIActors with the same PathID will share the same path.";
var(AINav) noexport class<AIActor> OptionalPathClass "Class of AIActor to optionally create paths for.";
var(AINav) noexport bool bNeverFailOnDynamicPath "Actor will not fail when a dynamic path blocker is blocking his path completely. HE will just keep moving.";
var(AIBehavior) name ActionPointJumpType;
var(AIDialog) float ChanceSayPain;
var(AIDialog) float ChanceSayFireInTheHole;
var(AIDialog) float ChanceSayTakeCover;
var(AIDialog) float ChanceSayLowHealth;
var(AIDialog) float ChanceSayConfirmKill;
var(AIDialog) float ChanceSayReloading;
var(AIDialog) float ChanceSayManDown;
var(AIDialog) float ChanceSayFriendlyFire;
var(AIDialog) float ChanceSayEnemySpotted;
var(AISound) float PainSoundMinInterval;
var(AISound) float PainSoundRndInterval;
var(AISound) bool bDebugAISounds;
var(AISound) noexport bool bDisableSounds "AI wont explicitly play sounds if this is set.";
var transient float PainSoundGate;
var const editconst transient nontrans pointer MyLog;
var(AIDebug) bool bUseMyLog;
var(AIDebug) bool bValidateDecisionTree;
var string ShouldFireStr;
var(AIDebug) noexport bool DebugInfiniteLoop "Enable debugging of infinite loops?";
var float NumTransitions;
var bool bAutoOpenDoors;
var bool bWasInAir;
var float FramesWithoutGroundContact;
var string TreeDescentLog;
var Vector TrailMarkerLoc;
var array<SGotoXHistory> GotoXHistory;
var bool bGotoXTracking;
var array<SPathingHistory> PathingHistory;
var array<SAIDebugMessage> AIDebugMessageQueue;
var array<SScriptFailInfo> ScriptFailHistory;
var float LastMoveSpeed;
var Vector LastMoveDir;
var Vector LastFrameVelocity;
var AIAnimHUD MyAnimHUD;
var float PathingErrors;
var transient float OpenDoorGate;
var Vector PreviousLocation;
var Vector DesiredMovement;
var bool bTrackPhysicsContacts;
var array<Actor> PhysicsContactActors;
var netupdate(NU_AIRotation) int AIRotation;
var Engine.BaseAI.EAIDynamicPathPriority DynamicPathingPriority;
var float DynamicPathingPriorityTieBreaker;
var float GroundConstraintScalerOverride;
var bool bScriptPathingEnabled;
var Engine.BaseAI.EAIDynamicPathPriority ScriptPathingOverride;
var float ScriptPathingTieBreakerOverride;
var bool bSpawnedPhysicsControllerActive;
var float PathSizeOverrideHeight;
var float PathSizeOverrideRadius;
var bool bForcePhysicsCutScene;
var float EvalGateOverride;
var bool bPathRover;
var bool bRestorePhysControllerAfterKeyframe;
var float GameplayCurrentScaleConstraintStrength;
var float GameplayDesiredScaleConstraintStrength;
var bool bAutoStartWeaponTargetEval;
var bool bAutoStartLookTargetEval;
var bool bAutoStartDecisionTree;
var bool bHolsterWeapons;
var bool bOpSuspendedLookTargetEval;
var SAIPerformanceInfo PerfInfo;
var bool bHackAIWantsToFire;
var bool bDontPlayShootAnim;
var int AINoTick;
var bool DumbAI;
var() noexport bool bSpecialStepHeightCollisionEnabled "If true, AI will have special collision in their step height for shrunken vehicle collisions.";
var bool bIsBoss;
var bool bDisableThrowAttack;

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        AIRotation;

    // Pos:0x00B
    reliable if(int(Role) == int(ROLE_Authority))
        AnimXParms, ClientMaybeFadeChannelBlock, 
        ClientSetAnimGridState, ClientSetAnimation, 
        ClientSetAnimationController;
}

simulated event bool CanBreatheNormally()
{
    return ClearLatentAction();
    return;
}

// Export UAIActor::execSetAnimPresets(FFrame&, void* const)
native function SetAnimPresets(Engine.BaseAI.EAIAnimXType AnimType, name AnimName, bool UseExactAnimName, float ExitTime, Actor TargetActor, Vector TargetPos, float FaceThreshold);

// Export UAIActor::execSetTurnToPresets(FFrame&, void* const)
native final function SetTurnToPresets(Engine.BaseAI.EAITargetType TargetType, optional Actor TargetActor, optional Vector TargetPos, optional float ShouldTurnThresh, optional float FaceThresh);

// Export UAIActor::execSetJumpPresets(FFrame&, void* const)
native function SetJumpPresets(Vector JumpVel, float HeavingLandingThresh, optional Actor FaceTargetActor, optional float NewGravityScale, optional float NewJumpTime, optional bool FlyToTarget, optional Vector TargetPos);

// Export UAIActor::execActivateCloaking(FFrame&, void* const)
native function ActivateCloaking(bool On);

// Export UAIActor::execGetCloaking(FFrame&, void* const)
native function Engine.BaseAI.EAICloaking GetCloaking();

// Export UAIActor::execIsCloaked(FFrame&, void* const)
native function bool IsCloaked();

// Export UAIActor::execSetDangerPos(FFrame&, void* const)
native function SetDangerPos(Vector NewDangerPos);

// Export UAIActor::execClearDangerPos(FFrame&, void* const)
native function ClearDangerPos();

// Export UAIActor::execLogMyLog(FFrame&, void* const)
native function LogMyLog(string str);

// Export UAIActor::execBeginMyLog(FFrame&, void* const)
native function BeginMyLog();

// Export UAIActor::execEndMyLog(FFrame&, void* const)
native function EndMyLog();

// Export UAIActor::execWeaponAimerAddTargetActor(FFrame&, void* const)
native function WeaponAimerAddTargetActor(Actor TargetActor, name TargetBoneName, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, optional string id);

// Export UAIActor::execWeaponAimerAddTargetPos(FFrame&, void* const)
native function WeaponAimerAddTargetPos(Vector TargetPos, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, name UpdatePosFuncName, optional string id);

// Export UAIActor::execWeaponAimerAddTargetAITarget(FFrame&, void* const)
native function WeaponAimerAddTargetAITarget(Engine.BaseAI.EAITarget NewTarget, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, optional string id);

// Export UAIActor::execWeaponAimerRemoveTarget(FFrame&, void* const)
native function WeaponAimerRemoveTarget(bool RemoveAll, float BlendTime);

// Export UAIActor::execWeaponAimerRemoveSpecificTarget(FFrame&, void* const)
native function WeaponAimerRemoveSpecificTarget(string id, float BlendTime);

// Export UAIActor::execIsWeaponAimerOn(FFrame&, void* const)
native function bool IsWeaponAimerOn();

// Export UAIActor::execGetWeaponAimerState(FFrame&, void* const)
native function Engine.BaseAI.EAIAim GetWeaponAimerState();

// Export UAIActor::execWeaponAimerGetNumTargets(FFrame&, void* const)
native function int WeaponAimerGetNumTargets();

// Export UAIActor::execWeaponAimerGetTargetString(FFrame&, void* const)
native function string WeaponAimerGetTargetString(int TargetIndex);

// Export UAIActor::execHeadAimerAddTargetActor(FFrame&, void* const)
native function HeadAimerAddTargetActor(Actor TargetActor, name TargetBoneName, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, optional string id);

// Export UAIActor::execHeadAimerAddTargetPos(FFrame&, void* const)
native function HeadAimerAddTargetPos(Vector TargetPos, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, name UpdatePosFuncName, optional string id);

// Export UAIActor::execHeadAimerAddTargetAITarget(FFrame&, void* const)
native function HeadAimerAddTargetAITarget(Engine.BaseAI.EAITarget NewTarget, float TargetLifeTime, float BlendTime, bool ClearStack, float Threshold, float TrackRate, bool RemoveIfBeyondConstraints, optional string id);

// Export UAIActor::execHeadAimerRemoveTarget(FFrame&, void* const)
native function HeadAimerRemoveTarget(bool RemoveAll, float BlendTime);

// Export UAIActor::execHeadAimerRemoveSpecificTarget(FFrame&, void* const)
native function HeadAimerRemoveSpecificTarget(string id, float BlendTime);

// Export UAIActor::execIsHeadAimerOn(FFrame&, void* const)
native function bool IsHeadAimerOn();

// Export UAIActor::execGetHeadAimerState(FFrame&, void* const)
native function Engine.BaseAI.EAIAim GetHeadAimerState();

// Export UAIActor::execHeadAimerGetNumTargets(FFrame&, void* const)
native function int HeadAimerGetNumTargets();

// Export UAIActor::execHeadAimerGetTargetString(FFrame&, void* const)
native function string HeadAimerGetTargetString(int TargetIndex);

// Export UAIActor::execCanGuard(FFrame&, void* const)
native function bool CanGuard();

// Export UAIActor::execIsGuarding(FFrame&, void* const)
native function bool IsGuarding();

// Export UAIActor::execIsGuardingPlayer(FFrame&, void* const)
native function bool IsGuardingPlayer();

// Export UAIActor::execIsGuardingActor(FFrame&, void* const)
native function bool IsGuardingActor(out Actor OutGuardedActor, out float OutInnerRange, out float OutOuterRange);

// Export UAIActor::execIsGuardingPos(FFrame&, void* const)
native function bool IsGuardingPos(out Vector OutGuardedPos, out float OutInnerRange, out float OutOuterRange);

// Export UAIActor::execGuardActor(FFrame&, void* const)
native function bool GuardActor(Actor GuardedActor, float InnerRange, float OuterRange, bool AlignWith, float AlignmentOffset, bool AllowAvoidDanger, bool AllowDodge, optional bool bDontScaleRangeWithDrawScale);

// Export UAIActor::execGuardPos(FFrame&, void* const)
native function bool GuardPos(float InnerRange, float OuterRange, bool AllowAvoidDanger, bool AllowDodge, optional bool bDontScaleRangeWithDrawScale);

// Export UAIActor::execSetAbortGuardThresh(FFrame&, void* const)
native function SetAbortGuardThresh(float Range, bool MustBeVisible);

// Export UAIActor::execClearGuard(FFrame&, void* const)
native function ClearGuard();

// Export UAIActor::execSetPopUp(FFrame&, void* const)
native function SetPopUp(PopUpCfg NewCfg);

// Export UAIActor::execPopUpCompromised(FFrame&, void* const)
native function bool PopUpCompromised();

// Export UAIActor::execSetActionPointIndex(FFrame&, void* const)
native function bool SetActionPointIndex(int NewIndex, int NewDesiredIndex);

// Export UAIActor::execLockActionPoint(FFrame&, void* const)
native function bool LockActionPoint(ActionPoint NewActionPoint, Vector NewActionPointUserLoc);

// Export UAIActor::execAtActionPoint(FFrame&, void* const)
native function bool AtActionPoint();

// Export UAIActor::execCanUseNewActionPoint(FFrame&, void* const)
native function bool CanUseNewActionPoint(ActionPoint NewActionPoint, bool Secondary);

// Export UAIActor::execCanUseActionPoint(FFrame&, void* const)
native function bool CanUseActionPoint(bool Secondary);

// Export UAIActor::execGetActionPointAction(FFrame&, void* const)
native function bool GetActionPointAction(bool Secondary);

// Export UAIActor::execActionPointCompromised(FFrame&, void* const)
native function bool ActionPointCompromised();

// Export UAIActor::execUseActionPoint(FFrame&, void* const)
native function bool UseActionPoint(bool Secondary);

// Export UAIActor::execReleaseActionPoint(FFrame&, void* const)
native function bool ReleaseActionPoint(bool Died);

// Export UAIActor::execHasUseableActionPoint(FFrame&, void* const)
native function bool HasUseableActionPoint();

// Export UAIActor::execSetNewActionPoint(FFrame&, void* const)
native function bool SetNewActionPoint(ActionPoint NewActionPoint);

// Export UAIActor::execSetExecutive(FFrame&, void* const)
native function SetExecutive(Engine.BaseAI.EAIExecutive NewExecutive);

// Export UAIActor::execGetExecutive(FFrame&, void* const)
native function Engine.BaseAI.EAIExecutive GetExecutive();

// Export UAIActor::execInitialiseExecutive(FFrame&, void* const)
native function InitialiseExecutive();

// Export UAIActor::execSuspendExecutive(FFrame&, void* const)
native function SuspendExecutive(bool Suspended);

// Export UAIActor::execIsExecutiveSuspended(FFrame&, void* const)
native function bool IsExecutiveSuspended();

// Export UAIActor::execExecuteExecutive(FFrame&, void* const)
native function ExecuteExecutive();

// Export UAIActor::execForceExecutive(FFrame&, void* const)
native function ForceExecutive();

// Export UAIActor::execPrintExecutive(FFrame&, void* const)
native function PrintExecutive();

// Export UAIActor::execPlayScript(FFrame&, void* const)
native function bool PlayScript(ScriptObj NewScript, bool Push);

// Export UAIActor::execStopScript(FFrame&, void* const)
native function bool StopScript();

// Export UAIActor::execAbortScripts(FFrame&, void* const)
native function AbortScripts();

// Export UAIActor::execAbortScript_SeeActor(FFrame&, void* const)
native function AbortScript_SeeActor(Actor VisibleActor, out int VisibilityChecked, out int IsVisible);

// Export UAIActor::execAbortScript_HearSound(FFrame&, void* const)
native function AbortScript_HearSound(Actor SoundInstigator);

// Export UAIActor::execAbortScript_Damaged(FFrame&, void* const)
native function AbortScript_Damaged(int Damage, Actor DamageInstigator);

// Export UAIActor::execAbortScript_Bumped(FFrame&, void* const)
native function AbortScript_Bumped(Actor BumpedActor);

// Export UAIActor::execAbortScript_Triggered(FFrame&, void* const)
native function AbortScript_Triggered(Actor EventInstigator);

// Export UAIActor::execAbortScript_Shrunk(FFrame&, void* const)
native function AbortScript_Shrunk();

// Export UAIActor::execHeardSound(FFrame&, void* const)
native function HeardSound(Actor NoiseMaker, Vector SoundPos);

// Export UAIActor::execPotentialWeaponTargetSound(FFrame&, void* const)
native function PotentialWeaponTargetSound(Actor NoiseMaker, Vector NoisePos);

// Export UAIActor::execSuspendWeaponTargetEvaluation(FFrame&, void* const)
native function SuspendWeaponTargetEvaluation(bool Suspend);

// Export UAIActor::execPotentialLookTargetSound(FFrame&, void* const)
native function PotentialLookTargetSound(Actor NoiseMaker, Vector NoisePos);

// Export UAIActor::execSuspendLookTargetEvaluation(FFrame&, void* const)
native function SuspendLookTargetEvaluation(bool Suspend);

// Export UAIActor::execForceLookTargetEval(FFrame&, void* const)
native function ForceLookTargetEval();

// Export UAIActor::execSetGoal(FFrame&, void* const)
native function bool SetGoal(Engine.BaseAI.EAIGoalType GoalType, optional bool ReturnTrueIfInRange, optional bool TestCanGotoPos);

// Export UAIActor::execSetGotoPresets(FFrame&, void* const)
native function SetGotoPresets(Engine.BaseAI.EAITargetType TargetType, Actor TargetActor, Vector TargetPos, Actor RefActor, Engine.BaseAI.EAIOffsetType OffsetType, float Range, float Bearing, float Height, float ClipTolerance, Engine.BaseAI.EAIFocus Focus, Actor FocusActor, int MaxSteps, optional bool bDebug);

// Export UAIActor::execCalcTargetsAimAngle(FFrame&, void* const)
native function bool CalcTargetsAimAngle(out float OutAimAngle);

// Export UAIActor::execCalcAimToMeAngle(FFrame&, void* const)
native function bool CalcAimToMeAngle(Actor AimingActor, out float OutAimAngle);

// Export UAIActor::execNative_PreGameInit(FFrame&, void* const)
native final function Native_PreGameInit();

// Export UAIActor::execNative_PreBeginPlay(FFrame&, void* const)
native final function Native_PreBeginPlay();

// Export UAIActor::execNative_PostBeginPlay(FFrame&, void* const)
native final function Native_PostBeginPlay();

// Export UAIActor::execNative_PostLoadMap(FFrame&, void* const)
native final function Native_PostLoadMap();

// Export UAIActor::execNative_PostSpawn(FFrame&, void* const)
native final function Native_PostSpawn();

// Export UAIActor::execIsFacingInYaw(FFrame&, void* const)
native final function bool IsFacingInYaw(Vector vPos);

// Export UAIActor::execIsFacing(FFrame&, void* const)
native final function bool IsFacing(Vector vDirTo, Vector vMyDir);

// Export UAIActor::execMoveToEx(FFrame&, void* const)
native final function MoveToEx(Vector vDest, float fMaxSpeed, float fDesiredSpeedAtDest);

// Export UAIActor::execEnableMovement(FFrame&, void* const)
native final function EnableMovement(bool On);

// Export UAIActor::execGetLatentAction(FFrame&, void* const)
native final function name GetLatentAction();

// Export UAIActor::execSetTarget(FFrame&, void* const)
native final function bool SetTarget(bool AllowClear, Actor NewTarget, optional Vector TargetPos, optional Rotator TargetRotn, optional bool Sighted);

// Export UAIActor::execClearTarget(FFrame&, void* const)
native final function ClearTarget();

// Export UAIActor::execFreeTargetActorSlot(FFrame&, void* const)
native final function FreeTargetActorSlot(int iIndex);

// Export UAIActor::execTargetActor(FFrame&, void* const)
native final function Actor TargetActor(int iIndex);

// Export UAIActor::execSetTargetActorSlot(FFrame&, void* const)
native final function SetTargetActorSlot(int iIndex, Actor aActor);

// Export UAIActor::execGetUnusedTargetActorSlot(FFrame&, void* const)
native final function int GetUnusedTargetActorSlot();

// Export UAIActor::execGetTarget(FFrame&, void* const)
native final function AITarget GetTarget(Engine.BaseAI.EAITarget eTarget);

// Export UAIActor::execGetTargetActor(FFrame&, void* const)
native final function Actor GetTargetActor(Engine.BaseAI.EAITarget eTarget);

// Export UAIActor::execCheckCondition(FFrame&, void* const)
native function Engine.BaseAI.EAICode CheckCondition(Engine.BaseAI.EAICondition Cond);

// Export UAIActor::execFacingActor(FFrame&, void* const)
native function bool FacingActor(Actor TargetActor, float Threshold, out Vector OutFacePos);

// Export UAIActor::execFacingPos(FFrame&, void* const)
native function bool FacingPos(Vector TargetPos, float Threshold);

// Export UAIActor::execPosInAngularThreshold(FFrame&, void* const)
native function bool PosInAngularThreshold(Vector TargetPos, float Threshold);

// Export UAIActor::execActorInHorizRange(FFrame&, void* const)
native function bool ActorInHorizRange(Actor TargetActor, float MaxHorizRange);

// Export UAIActor::execActorInHorizRangeLimits(FFrame&, void* const)
native function bool ActorInHorizRangeLimits(Actor TargetActor, float MinRange, float MaxRange);

// Export UAIActor::execActorInRange(FFrame&, void* const)
native function bool ActorInRange(Actor TargetActor, float MaxHorizRange, float MaxHeight);

// Export UAIActor::execAtActorOffset(FFrame&, void* const)
native function bool AtActorOffset(Actor TargetActor, Engine.BaseAI.EAIOffsetType OffsetType, float HorizRange, float Bearing, float Height);

// Export UAIActor::execPosInHorizProx(FFrame&, void* const)
native function bool PosInHorizProx(Vector TargetPos, float MaxHorizDist);

// Export UAIActor::execPosInAcceptableHorizProx(FFrame&, void* const)
native function bool PosInAcceptableHorizProx(Vector TargetPos, float MaxHorizDist);

// Export UAIActor::execPosInProx(FFrame&, void* const)
native function bool PosInProx(Vector TargetPos, float MaxHorizDist, float MaxHeight);

// Export UAIActor::execPosInAcceptableProx(FFrame&, void* const)
native function bool PosInAcceptableProx(Vector TargetPos, float MaxHorizDist, float MaxHeight);

// Export UAIActor::execCanGotoActor2D(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanGotoActor2D(Actor TargetActor, Actor RefActor, float HorizRange, float ClipTolerance, out Vector OutNextPathPos, out int FinalDest);

// Export UAIActor::execCanGotoActorOffset(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanGotoActorOffset(Actor TargetActor, Actor RefActor, Engine.BaseAI.EAIOffsetType OffsetType, float HorizRange, float Bearing, float Height, float ClipTolerance, out Vector OutNextPathPos, out int FinalDest);

// Export UAIActor::execCanGotoPos2D(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanGotoPos2D(Vector TargetPos, Actor RefActor, float HorizDist, float ClipTolerance, out Vector OutNextPathPos, out int FinalDest);

// Export UAIActor::execCanGotoPos(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanGotoPos(Vector TargetPos, Actor RefActor, float HorizDist, float Height, float ClipTolerance, out Vector OutNextPathPos, out int FinalDest);

// Export UAIActor::execCanTurnToActor(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanTurnToActor(Actor TargetActor, float FaceThresh, out Vector OutFacePos);

// Export UAIActor::execCanTurnToPos(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanTurnToPos(Vector TargetPos, float FaceThresh);

// Export UAIActor::execCalcPerpSpeed(FFrame&, void* const)
native function float CalcPerpSpeed(Vector Velocity);

// Export UAIActor::execCalcWeaponRange(FFrame&, void* const)
native function float CalcWeaponRange(float K);

// Export UAIActor::execCalcMeleeRange(FFrame&, void* const)
native function float CalcMeleeRange(float K);

// Export UAIActor::execCalcMeleeStrafeRange(FFrame&, void* const)
native function float CalcMeleeStrafeRange(float K);

// Export UAIActor::execCalcNumMeleeStrafeCylces(FFrame&, void* const)
native function float CalcNumMeleeStrafeCylces(float K);

// Export UAIActor::execCalcNumWeaponStrafeCycles(FFrame&, void* const)
native function float CalcNumWeaponStrafeCycles(float K);

// Export UAIActor::execCalcJumpRange(FFrame&, void* const)
native function float CalcJumpRange(float K);

// Export UAIActor::execCalcSector(FFrame&, void* const)
native function Engine.BaseAI.EAIArcSector CalcSector(Vector TargetPos, float SideSector, float BackSector);

// Export UAIActor::execCalcRelativeSector(FFrame&, void* const)
native function Engine.BaseAI.EAIArcSector CalcRelativeSector(Vector TargetPos, Vector Fwd, float SideSector, float BackSector);

// Export UAIActor::execCalcRndPos(FFrame&, void* const)
native function CalcRndPos(Actor TargetActor, out Vector OutTargetPos);

// Export UAIActor::execCalcRelOffsetPos(FFrame&, void* const)
native function CalcRelOffsetPos(float Range, float Bearing, out Vector OutTargetPos);

// Export UAIActor::execCalcTargetOffsetPos2D(FFrame&, void* const)
native function CalcTargetOffsetPos2D(Actor TargetActor, float HorizRange, float Heading, out Vector OutTargetPos);

// Export UAIActor::execCalcTargetOffsetPos3D(FFrame&, void* const)
native function CalcTargetOffsetPos3D(Actor TargetActor, float HorizRange, float Heading, float Height, out Vector OutTargetPos);

// Export UAIActor::execCalcTargetRelOffsetPos2D(FFrame&, void* const)
native function CalcTargetRelOffsetPos2D(Actor TargetActor, float HorizRange, float Bearing, out Vector OutTargetPos);

// Export UAIActor::execCalcTargetRelOffsetPos3D(FFrame&, void* const)
native function CalcTargetRelOffsetPos3D(Actor TargetActor, float HorizRange, float Bearing, float Height, out Vector OutTargetPos);

// Export UAIActor::execCalcDirToTargetRelOffsetPos2D(FFrame&, void* const)
native function CalcDirToTargetRelOffsetPos2D(Actor TargetActor, float HorizRange, float Bearing, out Vector OutTargetPos);

// Export UAIActor::execCalcDirToTargetRelOffsetPos3D(FFrame&, void* const)
native function CalcDirToTargetRelOffsetPos3D(Actor TargetActor, float HorizRange, float Bearing, float Height, out Vector OutTargetPos);

// Export UAIActor::execCalcDistForRange(FFrame&, void* const)
native function float CalcDistForRange(Actor TargetActor, float Range);

// Export UAIActor::execCalcRangeForDist(FFrame&, void* const)
native function float CalcRangeForDist(Actor TargetActor, float Dist);

// Export UAIActor::execCalcHorizRangeToActor(FFrame&, void* const)
native function float CalcHorizRangeToActor(Actor TargetActor);

// Export UAIActor::execValidateTargetPos(FFrame&, void* const)
native function Engine.BaseAI.EAICode ValidateTargetPos(Vector TargetPos, float ClipTolerance, out Vector OutClippedDest);

// Export UAIActor::execCalcJumpVelocity(FFrame&, void* const)
native function CalcJumpVelocity(Vector TargetPos, float MaxHeight, out Vector OutVelocity, optional bool Debug, optional float GravityScale, optional out float TimeOut);

// Export UAIActor::execCalcJumpAttackVelocity(FFrame&, void* const)
native function CalcJumpAttackVelocity(Actor TargetActor, out Vector OutJumpVelocity);

// Export UAIActor::execCalcPipeBombVelocity(FFrame&, void* const)
native function bool CalcPipeBombVelocity(Object PipeBombOrClass, Vector TargetPos, float MaxHeight, Engine.Actor.EAIAttitude AttitudeThresh, float FriendlyFireThresh, out Vector OutVelocity, optional bool Debug);

// Export UAIActor::execCalcProjectileVelocity(FFrame&, void* const)
native function bool CalcProjectileVelocity(Actor ProjectileObj, Engine.Object.EPhysics ProjectilePhys, Actor TargetActor, Vector TargetPos, float MinError, float MaxError, float MaxHeight, bool AssumeNoGravity, float NoGravitySpeed, bool CheckClear, Engine.Actor.EAIAttitude AttitudeThresh, float FriendlyFireThresh, bool IgnoreTransparents, out Vector OutVelocity, bool Debug);

// Export UAIActor::execCalcMapRange(FFrame&, void* const)
native function float CalcMapRange(float Value, float Range1Start, float Range1End, float Range2Start, float Range2End);

// Export UAIActor::execCanReloadWeapon(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanReloadWeapon();

// Export UAIActor::execCanSeeActor(FFrame&, void* const)
native function bool CanSeeActor(Actor TargetActor, bool CheckFOV, optional bool Debug);

// Export UAIActor::execClearShot(FFrame&, void* const)
native function bool ClearShot(Actor TargetActor, Vector From, Vector To, Engine.Actor.EAIAttitude AttitudeThresh, float FriendlyFireThresh, optional bool Debug, optional out Vector Extent, optional bool IgnoreTransparent);

// Export UAIActor::execCanSeePosFrom(FFrame&, void* const)
native function bool CanSeePosFrom(Vector From, Vector To, bool IgnoreTransparents, out Actor OutHitActor, out float OutHitTime, optional bool Debug, optional out Vector Extent);

// Export UAIActor::execFloatInLimits(FFrame&, void* const)
native function Engine.BaseAI.EAICode FloatInLimits(float TestFloat, float MinLimit, float MaxLimit);

// Export UAIActor::execVectorInLimits(FFrame&, void* const)
native function Engine.BaseAI.EAICode VectorInLimits(Vector TestVector, float MinHorizLimit, float MaxHorizLimit, float MinVertLimit, float MaxVertLimit);

// Export UAIActor::execFindClosestLedge(FFrame&, void* const)
native function bool FindClosestLedge(out Vector OutLedgePos, float MaxDistToLedge);

// Export UAIActor::execPortalDoorIsClosed(FFrame&, void* const)
native function bool PortalDoorIsClosed(int DestPortal, int TransType, out DoorMoverEx DoorMover);

// Export UAIActor::execForcePosIntoPath(FFrame&, void* const)
native function bool ForcePosIntoPath(Vector TargetPos, float ClipTolerance, out Vector ClippedTargetPos);

// Export UAIActor::execTargetContact(FFrame&, void* const)
native function Engine.BaseAI.EAICode TargetContact(float MaxTimeSinceContact);

// Export UAIActor::execFacingTarget(FFrame&, void* const)
native function Engine.BaseAI.EAICode FacingTarget(float Thresh);

// Export UAIActor::execTargetInHorizRangeLimits(FFrame&, void* const)
native function Engine.BaseAI.EAICode TargetInHorizRangeLimits(float MinRange, float MaxRange);

// Export UAIActor::execGetMaxRangeError(FFrame&, void* const)
native function float GetMaxRangeError();

// Export UAIActor::execGetMaxHeightError(FFrame&, void* const)
native function float GetMaxHeightError();

// Export UAIActor::execAddTrailMarker(FFrame&, void* const)
native function AddTrailMarker();

// Export UAIActor::execNotifyDied(FFrame&, void* const)
native function bool NotifyDied();

// Export UAIActor::execPointIsInWorld(FFrame&, void* const)
native function bool PointIsInWorld(Vector Point, optional Vector Extent);

// Export UAIActor::execGetRealNAVID(FFrame&, void* const)
native function int GetRealNAVID();

// Export UAIActor::execSortHealthTriggers(FFrame&, void* const)
native function SortHealthTriggers();

// Export UAIActor::execIsInAir(FFrame&, void* const)
native function bool IsInAir();

// Export UAIActor::execIsFlying(FFrame&, void* const)
native function bool IsFlying();

// Export UAIActor::execIsFalling(FFrame&, void* const)
native function bool IsFalling();

// Export UAIActor::execShowDebugInfoBubbles(FFrame&, void* const)
native function bool ShowDebugInfoBubbles();

// Export UAIActor::execAIShouldTick(FFrame&, void* const)
native function bool AIShouldTick();

// Export UAIActor::execClearGlobalPathingCache(FFrame&, void* const)
native simulated function ClearGlobalPathingCache();

simulated function NU_AIRotation(int Rot)
{
    ViewRotationInt = Rot;
    return;
}

event ReceiveWeapon(class<Weapon> WeaponClass)
{
    WeaponClass.static.GiveToAI(self);
    return;
}

event bool PawnNeedsSpecialStepHeightCollision()
{
    return bSpecialStepHeightCollisionEnabled;
    return;
}

simulated event EnumerateRawAnimationSequences(out array<SAnimationEnumeration> References)
{
    local int i;

    super(InteractiveActor).EnumerateRawAnimationSequences(References);
    // End:0x31
    if(SpawnScript == none)
    {
        SpawnScript.super(ScriptObj).EnumerateRawAnimationSequences(References, Mesh);
    }
    i = 0;
    J0x38:

    // End:0x78 [Loop If]
    if(i < 10)
    {
        class'AnimationControllerEx'.static.EnumerateRawAnimationSequences(References, AnimControllers[i].m_cClass, Mesh);
        ++ i;
        // [Loop Continue]
        goto J0x38;
    }
    return;
}

static function AIActor StaticSpawnAI(class<AIActor> SpawnClass, AIActorFactory Factory, Actor Owner, name SpawnTag, Vector SpawnLocation, Rotator SpawnRotation, bool bSkipFindSpot)
{
    return Factory.EmptyTouchClasses(SpawnClass, Owner, SpawnTag, SpawnLocation, SpawnRotation,, bSkipFindSpot);
    return;
}

simulated function ModifyAllowQuickTeleports(Engine.Object.EBitModifier bAllowQuickTeleportsModifier)
{
    return;
}

simulated delegate ClientSetAnimation(name AnimName, optional float Rate, optional bool Reset, optional bool UseExactAnimName)
{
    PlayAnim(AnimName, Rate, Reset, UseExactAnimName);
    return;
}

simulated event delegate bool ClientSetAnimGridState(name AnimGridName, float X, optional float Y, optional bool bKeepChannelAlpha)
{
    SetAnimGridState(AnimGridName, X, Y, bKeepChannelAlpha);
    return;
}

simulated delegate ClientSetAnimationController(Engine.BaseAI.EAIAnimController cont)
{
    SetAnimController(cont);
    return;
}

simulated delegate ClientMaybeFadeChannelBlock(name ChannelBlockName, float TargetAlpha, float FadeTime, optional bool bClearAnimsOnFinish)
{
    MaybeFadeChannelBlock(ChannelBlockName, TargetAlpha, FadeTime, bClearAnimsOnFinish);
    return;
}

simulated function NU_AnimXParms(SAnimX newparms)
{
    return;
}

simulated function bool CanDisablePhysicsConstraintsInStateGotoX()
{
    return true;
    return;
}

function StartBloat(float BloatTime)
{
    DeathAnimChance = 0;
    super(Pawn).StartBloat(BloatTime);
    return;
}

// Export UAIActor::execRegisterAIAnimationControllerEntry(FFrame&, void* const)
native final function RegisterAIAnimationControllerEntry(PrecacheIndex PrecacheIndex, name EntryName);

event EnumerateWeaponClasses(PrecacheIndex PrecacheIndex, out array< class<Weapon> > WeaponClasses)
{
    return;
}

event EnumerateUsableAnimationControllers(PrecacheIndex PrecacheIndex, out array<Engine.BaseAI.EAIAnimController> UsableControllers)
{
    return;
}

function ActionPointDestroyed(ActionPoint Point)
{
    local int Index, DesiredIndex;

    super(Actor).ActionPointDestroyed(Point);
    Index = ActionPointIndex;
    DesiredIndex = ActionPointDesiredIndex;
    SetActionPointIndex(-1, -1);
    SetActionPointIndex(Index, DesiredIndex);
    return;
}

event SaveAnimSync()
{
    SavedUseAnimDispSpeed = bUseAnimDispSpeed;
    SavedUseAnimDispDir = bUseAnimDispDir;
    SavedUseAnimRotation = bUseAnimRotation;
    SavedAnimCutScene = bAnimCutScene;
    SavedUseAcceleration = bUseAcceleration;
    return;
}

event SetAnimSync(Engine.Object.EBitModifier UseAnimDispSpeedMod, Engine.Object.EBitModifier UseAnimDispDirMod, Engine.Object.EBitModifier UseAnimRotationMod, Engine.Object.EBitModifier AnimCutSceneMod, Engine.Object.EBitModifier UseAccelerationMod)
{
    bUseAnimDispSpeed = HandleIntModifier(UseAnimDispSpeedMod, bUseAnimDispSpeed);
    bUseAnimDispDir = HandleIntModifier(UseAnimDispDirMod, bUseAnimDispDir);
    bUseAnimRotation = HandleIntModifier(UseAnimRotationMod, bUseAnimRotation);
    bUseAcceleration = HandleIntModifier(UseAccelerationMod, bUseAcceleration);
    SetAnimCutScene(HandleIntModifier(AnimCutSceneMod, bAnimCutScene));
    return;
}

event RestoreSavedAnimSync()
{
    bUseAnimDispSpeed = SavedUseAnimDispSpeed;
    bUseAnimDispDir = SavedUseAnimDispDir;
    bUseAnimRotation = SavedUseAnimRotation;
    bUseAcceleration = SavedUseAcceleration;
    SetAnimCutScene(SavedAnimCutScene);
    return;
}

event RestoreDefaultAnimSync()
{
    bUseAnimDispSpeed = default.bUseAnimDispSpeed;
    bUseAnimDispDir = default.bUseAnimDispDir;
    bUseAnimRotation = default.bUseAnimRotation;
    bUseAcceleration = default.bUseAcceleration;
    SetAnimCutScene(default.bAnimCutScene);
    return;
}

function DumpAnimSync()
{
    return;
}

function SetAnimCutScene(bool NewAnimCutScene)
{
    // End:0x20
    if(NewAnimCutScene && ! bAnimCutScene)
    {
        ChangeCollisionHeightToFull(true);        
    }
    else
    {
        // End:0x3D
        if(! NewAnimCutScene && bAnimCutScene)
        {
            ChangeCollisionHeightToStanding(true);
        }
    }
    bAnimCutScene = NewAnimCutScene;
    return;
}

event RestoreDefaultBodyAlignRate()
{
    // End:0x22
    if(BodyTargetTracker == none)
    {
        BodyTargetTracker.SetMaxRate(DefaultBodyAlignRate());
    }
    return;
}

event float DefaultBodyAlignRate()
{
    // End:0x12
    if(IsFlying())
    {
        return default.BodyAlignRateFlying;        
    }
    else
    {
        return default.BodyAlignRate;
    }
    return;
}

event PreLoadMap()
{
    super(Actor).PreLoadMap();
    return;
}

event PostLoadMap()
{
    Native_PostLoadMap();
    super(Actor).PostLoadMap();
    return;
}

event PreGameInit()
{
    super(Actor).PreGameInit();
    Native_PreGameInit();
    return;
}

event PreBeginPlay()
{
    super(Pawn).PreBeginPlay();
    Native_PreBeginPlay();
    return;
}

simulated event PostBeginPlay()
{
    bSpawnedPhysicsControllerActive = bPhysicsControllerActive;
    // End:0x1A
    if(bSpawnedPhysicsControllerActive)
    {
        FindStairRotation(false);
    }
    super(Pawn).PostBeginPlay();
    Native_PostBeginPlay();
    return;
}

event PlayDefaultSpawnAnim()
{
    Anim_Idle();
    return;
}

event PostSpawn()
{
    // End:0x18
    if(bSpawnedPhysicsControllerActive && bSimplePawnPhysicsCollision)
    {
        FindStairRotation(true);
    }
    Native_PostSpawn();
    bNoDamage = false;
    return;
}

event bool ExtractSpawnAnimSeq(out name OutSequenceName, out int OutLoopSequence, out float OutStartFrame, out float OutSpawnAnimRate)
{
    local int i, Index, NumMethods;
    local ScriptMethod MyMethod;

    // End:0x0E
    if(SpawnScript != none)
    {
        return false;
    }
    NumMethods = string(SpawnScript.Methods);
    i = 0;
    J0x2B:

    // End:0x185 [Loop If]
    if(i < NumMethods)
    {
        MyMethod = SpawnScript.Methods[i];
        // End:0x17B
        if(MyMethod == none)
        {
            // End:0xE5
            if(MyMethod.ClassForName('ScriptMethod_PlayExplicitAnim'))
            {
                OutSequenceName = ScriptMethod_PlayExplicitAnim(MyMethod).SequenceName;
                OutLoopSequence = int(ScriptMethod_PlayExplicitAnim(MyMethod).Loop);
                OutStartFrame = ScriptMethod_PlayExplicitAnim(MyMethod).StartFrame;
                OutSpawnAnimRate = ScriptMethod_PlayExplicitAnim(MyMethod).Rate;
                return true;                
            }
            else
            {
                // End:0x166
                if(MyMethod.ClassForName('ScriptMethod_PlayTransientExplicitAnim'))
                {
                    OutSequenceName = ScriptMethod_PlayTransientExplicitAnim(MyMethod).SequenceName;
                    OutLoopSequence = int(ScriptMethod_PlayTransientExplicitAnim(MyMethod).Loop);
                    OutStartFrame = ScriptMethod_PlayTransientExplicitAnim(MyMethod).StartFrame;
                    OutSpawnAnimRate = ScriptMethod_PlayTransientExplicitAnim(MyMethod).Rate;
                    return true;
                }
            }
            // End:0x17B
            if(MyMethod.Latent)
            {
                return false;
            }
        }
        ++ i;
        // [Loop Continue]
        goto J0x2B;
    }
    return false;
    return;
}

event PreInit()
{
    // End:0x22
    if(string(RandomActorColor) > 0)
    {
        Sleep(RandomActorColorGroupID, RandomActorColor[Rand(string(RandomActorColor))]);
    }
    return;
}

simulated function PostVerifySelf()
{
    // End:0x1C
    if(MountLightEx)
    {
        MountOnSpawn[MountOnSpawn.Add(1)] = MountedLightExMountPrefab;
    }
    super(RenderActor).PostVerifySelf();
    // End:0x36
    foreach GetNextIntDesc(class'LightEx', MountedLightEx)
    {
        // End:0x36
        break;        
    }    
    return;
}

event PostInit()
{
    return;
}

simulated event Destroyed()
{
    // End:0x1D
    if(FactoryManager == none)
    {
        FactoryManager.NotifyDied(self);
    }
    // End:0x3A
    if(Factory == none)
    {
        Factory.NotifyDied(self);
    }
    ClearFactory();
    ReleaseActionPoint(true);
    KillWeaponManager();
    DestroyAnimControllers();
    DestroyShield();
    DestroyTKShield();
    DestroyShootProjectileEffects();
    SetAnimFrame(none);
    // End:0x8C
    if(RappelParms.MyBeamSystem == none)
    {
        RappelParms.MyBeamSystem.RemoveTouchClass();
    }
    // End:0xAF
    if(TeleportParms.StartLight == none)
    {
        TeleportParms.StartLight.RemoveTouchClass();
    }
    // End:0xD2
    if(TeleportParms.EndLight == none)
    {
        TeleportParms.EndLight.RemoveTouchClass();
    }
    super(Pawn).Destroyed();
    return;
}

event ScriptCalcRotation(out Rotator OldRotation, out Rotator NewRotation, float DeltaTime)
{
    return;
}

event FireWeapon()
{
    return;
}

event ProceduralFire()
{
    MovingFireGate = (Level.GameTimeSeconds + MinMovingFireInterval) + (FRand() * RndMovingFireInterval);
    AIActor_Weapon_Fire();
    return;
}

// Export UAIActor::execIsInProcFireState(FFrame&, void* const)
native(1328) function bool IsInProcFireState();

// Export UAIActor::execIsInProcFireOp(FFrame&, void* const)
native(1329) function bool IsInProcFireOp();

function string HUDProceduralFireInfo()
{
    local string str;

    // End:0x38
    if(! ProcAimingEnabledThisFrame)
    {
        str = "ProcAimingEnabledThisFrame = FALSE";        
    }
    else
    {
        // End:0x61
        if(! CanProcFire)
        {
            str = "CanProcFire = FALSE";            
        }
        else
        {
            // End:0x93
            if(! ProceduralMovingFire)
            {
                str = "ProceduralMovingFire = FALSE";                
            }
            else
            {
                // End:0xC2
                if(! BoneAimerOnTarget)
                {
                    str = "BoneAimerOnTarget = FALSE";                    
                }
                else
                {
                    // End:0x129
                    if(! (MovingFireGate <= 0) || Level.GameTimeSeconds > MovingFireGate)
                    {
                        str = "MovingFireGate FAILED. MovingFireGate: " $ string(MovingFireGate);                        
                    }
                    else
                    {
                        // End:0x1FB
                        if(! PrimaryTarget.IsValidTarget() && (PrimaryTarget.GetTimeVisible() > 0) && PrimaryTarget.GetTimeSinceSeen() < ProcFireMaxTimeSinceSeen)
                        {
                            str = (("PrimaryTarget checks Failed Not seen. GetTimeVisible() = " $ string(PrimaryTarget.GetTimeVisible())) @ "GetTimeSinceSeen(): ") $ string(PrimaryTarget.GetTimeSinceSeen());                            
                        }
                        else
                        {
                            // End:0x22D
                            if(ShouldProceduralFire())
                            {
                                str = "ShouldProceduralFire() = TRUE!";                                
                            }
                            else
                            {
                                str = " I DONT FUCKING KNOW!!!";
                            }
                        }
                    }
                }
            }
        }
    }
    return str;
    return;
}

function string HUDPreFireInfo()
{
    local string str;

    // End:0x35
    if(WeaponManager.NoFire)
    {
        str = "WeaponManager.NoFire == true";        
    }
    else
    {
        // End:0xBA
        if(! Level.GameTimeSeconds >= WeaponManager.Gate)
        {
            str = ((("Level.GameTimeSeconds(" $ string(Level.GameTimeSeconds)) $ ") >= WeaponManager.Gate(") $ string(WeaponManager.Gate)) $ ")";            
        }
        else
        {
            // End:0x1F6
            if(! (((WeaponManager.ShotsFired > 0) || PrimaryTargetActor != none) || ! PrimaryTargetActor.bIsPlayerPawn) || PrimaryTarget.GetTimeVisible() >= MinTargetVisibleTime)
            {
                str = (((((((("WeaponManager.ShotsFired: " $ string(WeaponManager.ShotsFired)) @ "PrimaryTargetActor: ") $ string(PrimaryTargetActor)) @ "PrimaryTargetActor.bIsPlayerPawn: ") $ string(PrimaryTargetActor.bIsPlayerPawn)) @ "PrimaryTarget.GetTimeVisible: ") $ string(PrimaryTarget.GetTimeVisible())) @ "MinTargetVisibleTime") $ string(MinTargetVisibleTime);                
            }
            else
            {
                // End:0x27C
                if(! int(TargetInHorizRangeLimits(WeaponManager.MinRange, 999999.9)) == int(0))
                {
                    str = (("TargetInHorizRangeLimits (" $ string(WeaponManager.MinRange)) $ ",999999.9f) == ") $ string(DynamicLoadObject(class'EAICode', int(TargetInHorizRangeLimits(WeaponManager.MinRange, 999999.9))));
                }
            }
        }
    }
    return str;
    return;
}

event UpdateState(float DeltaSecs)
{
    return;
}

event UpdateStateOPNotWorking(float DeltaSecs)
{
    return;
}

event TickState(float Secs)
{
    return;
}

final simulated function dnControl_FinishingMove GetFinishingMoveControl()
{
    local dnControl_FinishingMove FinishMoveControl;

    FinishMoveControl = dnControl_FinishingMove(FindAnyActor(class'dnControl_FinishingMove', 'AIFinishMove'));
    // End:0x43
    if(FinishMoveControl != none)
    {
        FinishMoveControl = EmptyTouchClasses(class'dnControl_FinishingMove',, 'AIFinishMove', Location,, false, true);
    }
    return FinishMoveControl;
    return;
}

final simulated function bool CanPerformFrozenExecution(Pawn TestPawn)
{
    local dnControl_FinishingMove FinishMoveControl;

    // End:0x0D
    if(! AllowFrozenExecution)
    {
        return false;
    }
    // End:0x84
    if((((TestPawn == none) && TestPawn.bIsPlayerPawn) && IsFrozen()) && IsMostlyShrunk() == TestPawn.IsMostlyShrunk())
    {
        FinishMoveControl = GetFinishingMoveControl();
        // End:0x84
        if(FinishMoveControl == none)
        {
            return FinishMoveControl.CanBeUsedBy(TestPawn);
        }
    }
    return false;
    return;
}

simulated function bool CanBeUsedBy(Pawn TestPawn)
{
    // End:0x10
    if(CanPerformFrozenExecution(TestPawn))
    {
        return true;
    }
    return super(InteractiveActor).CanBeUsedBy(TestPawn);
    return;
}

simulated event bool ShouldDrawHUDInfoUsePhrase(Pawn TestPawn)
{
    // End:0x10
    if(CanPerformFrozenExecution(TestPawn))
    {
        return true;
    }
    return super(InteractiveActor).ShouldDrawHUDInfoUsePhrase(TestPawn);
    return;
}

simulated function string GetUsePhrase()
{
    // End:0x27
    if(ControlXParms.MyControl == none)
    {
        return ControlXParms.MyControl.GetUsePhrase();
    }
    // End:0x4B
    if((IsFrozen()) && AllowFrozenExecution)
    {
        return class'dnControl_FinishingMove'.default.UsePhrase;
    }
    // End:0x95
    if(((CanGuard()) && UseActionFollow) && DialogGateOpen())
    {
        // End:0x84
        if(IsGuardingPlayer())
        {
            return "Stop Follow";            
        }
        else
        {
            return "Request Follow";
        }
    }
    return super(InteractiveActor).GetUsePhrase();
    return;
}

event Used(Actor Other, Pawn Instigator)
{
    local dnControl_FinishingMove FinishMoveControl;

    // End:0x4E
    if(CanPerformFrozenExecution(Instigator))
    {
        FinishMoveControl = GetFinishingMoveControl();
        // End:0x4E
        if(FinishMoveControl == none)
        {
            FinishMoveControl.ExecutionVictim = self;
            FinishMoveControl.AttachPawnSuccess(Instigator);
            return;
        }
    }
    // End:0x9C
    if(((CanGuard()) && UseActionFollow) && DialogGateOpen())
    {
        // End:0x7F
        if(IsGuardingPlayer())
        {
            ClearGuard();            
        }
        else
        {
            GuardActor(Other, 160, 320, false, 0, true, true);
        }
    }
    // End:0xB7
    if(NameForString(UsedScriptTag, 'None'))
    {
        GlobalTrigger(UsedScriptTag);
    }
    super(InteractiveActor).Used(Other, Instigator);
    return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
    AbortScript_Triggered(Other);
    super(Actor).Trigger(Other, EventInstigator);
    return;
}

event bool ShouldAbortMovement()
{
    return false;
    return;
}

event PhysicsVolumeChange(PhysicsVolume aNewVolume)
{
    super(Pawn).PhysicsVolumeChange(aNewVolume);
    // End:0x31
    if(aNewVolume.bKillAI)
    {
        Died(,, Location,, class'FallingDamage');
    }
    return;
}

event Bump(Actor Other)
{
    super(Actor).Bump(Other);
    AbortScript_Bumped(Other);
    return;
}

event PhysicsChange(optional Engine.Object.EPhysics PreviousPhysics)
{
    // End:0x2E
    if((int(Physics) == int(2)) || int(Physics) == int(18))
    {
        StartFallHeight = Location.Z;
    }
    return;
}

event HearSound(Actor NoiseMaker, Vector SoundLocation)
{
    HeardSound(NoiseMaker, SoundLocation);
    return;
}

event AnimEndEx(SAnimEndInfo AnimEndInfo)
{
    super(RenderActor).AnimEndEx(AnimEndInfo);
    AnimEarlyEnd(AnimEndInfo);
    return;
}

event AnimEarlyEnd(SAnimEndInfo AnimEndInfo)
{
    AIActor_AnimEnd(AnimEndInfo.Channel, AnimEndInfo.AnimName, AnimEndInfo.RefId);
    return;
}

event BumpedInto(Actor Obstruction, Vector vNormal)
{
    AbortScript_Bumped(Obstruction);
    return;
}

event BumpedBy(Actor Bumper)
{
    AbortScript_Bumped(Bumper);
    return;
}

event NotifyWeaponManagerMode(Engine.BaseAI.EAIWeapManMode NewMode)
{
    return;
}

event GetFaceTargetLocation(out Vector OutLocation)
{
    OutLocation = LineOfSightTo();
    return;
}

event bool UpdateFaceTarget(Vector vDirTo, Vector vCurDir)
{
    return IsFacing(vDirTo, vCurDir);
    return;
}

event bool CanBaseOn(Actor PotentialBase)
{
    // End:0x28
    if((PotentialBase == none) && int(PotentialBase.Physics) == int(18))
    {
        return false;
    }
    return super(Pawn).CanBaseOn(PotentialBase);
    return;
}

event BaseChange()
{
    return;
}

event NotifyTakeOff()
{
    bCanFly = true;
    bIsFlying = true;
    return;
}

event NotifyLand()
{
    bCanFly = false;
    bIsFlying = false;
    return;
}

event NotifyJumpTakeOff()
{
    return;
}

event NotifyJumpLand()
{
    return;
}

event InitMesh()
{
    local int i;

    // End:0x36
    if(OverrideMesh != none)
    {
        i = string(OverrideMeshList);
        // End:0x36
        if(i > 0)
        {
            OverrideMesh = OverrideMeshList[Rand(i)];
        }
    }
    // End:0x4A
    if(OverrideMesh == none)
    {
        GetOverlayEffectAlpha(OverrideMesh);
    }
    return;
}

event InitSkin()
{
    return;
}

event bool PawnAllowPickup(class<Inventory> InvClass)
{
    return false;
    return;
}

event SetHeadAimAnims()
{
    return;
}

event NotifyWeaponAimState(Engine.BaseAI.EAIAim NewState)
{
    NotifyAimState(NewState);
    return;
}

event NotifyHeadAimState(Engine.BaseAI.EAIAim NewState)
{
    return;
}

event NotifyEyeAimState(Engine.BaseAI.EAIAim NewState)
{
    return;
}

event NotifyHeadAnimEnd()
{
    return;
}

event NotifyFaceAnimEnd()
{
    // End:0x17
    if(FaceAnims)
    {
        PlayAnim('Anim_FaceNormal',,, true);
    }
    return;
}

event NotifyWeaponTargetInThreshold(string TargetID)
{
    InShootAngleThresh = true;
    // End:0x3F
    if(EndStateOnWeaponTargetInThresh)
    {
        EndStateOnWeaponTargetInThresh = false;
        EndStateOnWeaponTargetLost = false;
        ExitAIState(2, "WeaponTargetInThresh");
    }
    return;
}

event NotifyWeaponTargetLost(string TargetID)
{
    // End:0x33
    if(EndStateOnWeaponTargetLost)
    {
        EndStateOnWeaponTargetInThresh = false;
        EndStateOnWeaponTargetLost = false;
        ExitAIState(3, "WeaponTargetLost");
    }
    return;
}

event NotifyHeadTargetInThreshold(string TargetID)
{
    // End:0x35
    if(EndStateOnLookTargetInThresh)
    {
        EndStateOnLookTargetInThresh = false;
        EndStateOnLookTargetLost = false;
        ExitAIState(2, "LookTargetInThresh");
    }
    return;
}

event NotifyHeadTargetLost(string TargetID)
{
    // End:0x0D
    if(TargetID != "")
    {
    }
    // End:0x3E
    if(EndStateOnLookTargetLost)
    {
        EndStateOnLookTargetInThresh = false;
        EndStateOnLookTargetLost = false;
        ExitAIState(3, "LookTargetLost");
    }
    return;
}

function HitByEMP(float Duration, optional Pawn Instigator)
{
    super(InteractiveActor).HitByEMP(Duration, Instigator);
    Destroy(Duration, false, 'EndEMP');
    return;
}

function EndEMP()
{
    return;
}

function bool CurrentlyInvincible()
{
    return Invulnerable || super(Pawn).CurrentlyInvincible();
    return;
}

simulated function float GetDamageScaleForPart(Engine.Object.EPawnBodyPart Part, class<DamageType> DamageType, Vector DamageOrigin, Vector DamageDirection)
{
    // End:0x26
    if(bMeleeResetPainOpGate && IsA(DamageType, class'MeleeDamage'))
    {
        PainOpGate = 0;
    }
    // End:0x4C
    if(DamageType != none)
    {
        return class'DamageType'.default.DamageScaleMap[int(Part)];        
    }
    else
    {
        return DamageType.default.DamageScaleMap[int(Part)];
    }
    return;
}

// Export UAIActor::execPassDamageType(FFrame&, void* const)
native function bool PassDamageType(class<DamageType> DamageType, int j, bool NotDamage);

function AIScaleDamage(Pawn Instigator, out float Damage, Engine.Object.EPawnBodyPart Part, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    local int i;
    local class<Pawn> InstigatorClass;

    InstigatorClass = class'Pawn';
    // End:0x2C
    if(Instigator == none)
    {
        InstigatorClass = Instigator.Class;
    }
    // End:0x43
    if(DamageType != none)
    {
        DamageType = class'DamageType';
    }
    i = string(DamageScaleInfo) - 1;
    J0x52:

    // End:0x114 [Loop If]
    if(i >= 0)
    {
        // End:0x10A
        if((((DamageScaleInfo[i].QualifierClass != none) || IsA(InstigatorClass, DamageScaleInfo[i].QualifierClass)) && (string(DamageScaleInfo[i].QualifierDamageTypes) <= 0) || PassDamageType(DamageType, i, false)) && (string(DamageScaleInfo[i].QualifierNotDamageTypes) <= 0) || ! PassDamageType(DamageType, i, true))
        {
            Damage *= DamageScaleInfo[i].DamageScale;
            return;
        }
        -- i;
        // [Loop Continue]
        goto J0x52;
    }
    // End:0x170
    if((Instigator == none) && ! Instigator.bIsPlayerPawn)
    {
        // End:0x164
        if(Instigator.Class != self.Class)
        {
            Damage = 0;
            return;
        }
        Damage *= 0.5;
    }
    return;
}

function CheckHealthEvents(Pawn Instigator, float HealthBefore)
{
    local int i;

    // End:0x82
    if(bHealthTriggerMultiple)
    {
        i = string(HealthTriggers) - 1;
        J0x18:

        // End:0x7F [Loop If]
        if(i >= 0)
        {
            // End:0x75
            if((HealthBefore > HealthTriggers[i].Health) && Health <= HealthTriggers[i].Health)
            {
                GlobalTrigger(HealthTriggers[i].Event, Instigator, self);
            }
            -- i;
            // [Loop Continue]
            goto J0x18;
        }        
    }
    else
    {
        i = string(HealthTriggers) - 1;
        J0x91:

        // End:0xE8 [Loop If]
        if(i >= 0)
        {
            // End:0xDE
            if(Health <= HealthTriggers[i].Health)
            {
                GlobalTrigger(HealthTriggers[i].Event, Instigator, self);
                HealthTriggers.Remove(i, 1);
            }
            -- i;
            // [Loop Continue]
            goto J0x91;
        }
    }
    return;
}

simulated event float FindSoundAndSpeak(name SoundName, optional bool bPlayWithoutBreath)
{
    local float Length;

    // End:0x32
    if(! bDisableSounds && int(FrozenState) == int(0))
    {
        Length = super(Pawn).FindSoundAndSpeak(SoundName, bPlayWithoutBreath);
    }
    // End:0xEA
    if(bDebugAISounds)
    {
        // End:0x9F
        if(bDisableSounds)
        {
            BroadcastLog((("[AI Sound] " $ string(self)) @ " Not playing sound because I am muted. SoundName: ") $ string(SoundName));            
        }
        else
        {
            BroadcastLog((((("[AI Sound] " $ string(self)) @ " Playing Sound: ") $ string(SoundName)) @ "Length=") $ string(Length));
        }
    }
    return Length;
    return;
}

animevent simulated function PlayVoicePackEntry(optional EventInfo AnimEventInfo)
{
    // End:0xAB
    if(bDebugAISounds)
    {
        // End:0x71
        if(bDisableSounds)
        {
            BroadcastLog((("[AI Sound] " $ string(self)) @ " Not playing sound because I am muted. SoundName: ") $ AnimEventInfo.EventString);            
        }
        else
        {
            BroadcastLog((("[AI Sound] " $ string(self)) @ " Playing Sound: ") $ AnimEventInfo.EventString);
        }
    }
    // End:0xB6
    if(bDisableSounds)
    {
        return;
    }
    super(Actor).PlayVoicePackEntry(AnimEventInfo);
    return;
}

function MaybePlayPainSound()
{
    // End:0x4B
    if(PainSoundGate < Level.GameTimeSeconds)
    {
        PainSoundGate = (Level.GameTimeSeconds + PainSoundMinInterval) + (FRand() * PainSoundRndInterval);
        FindSoundAndSpeak('Sound_Pain');
    }
    return;
}

function TookDamage(Pawn Instigator, float Damage, Engine.Object.EPawnBodyPart Part, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    local float HealthBefore;

    HealthBefore = Health;
    // End:0x39
    if(! IsEnemyTo(Instigator) && FRand() < ChanceSayFriendlyFire)
    {
        Level.TryBonusCode(self, 8);
    }
    AIScaleDamage(Instigator, Damage, Part, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    // End:0x114
    if(! DamageInfo.Valid || Damage > DamageInfo.Damage)
    {
        DamageInfo.Valid = true;
        DamageInfo.Instigator = Instigator;
        DamageInfo.Damage = Damage;
        DamageInfo.Part = Part;
        DamageInfo.DamageType = DamageType;
        DamageInfo.pos = DamageOrigin;
        DamageInfo.Dir = DamageDirection;
        DamageInfo.Time = Level.GameTimeSeconds;
    }
    super(Pawn).TookDamage(Instigator, Damage, Part, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    // End:0x1BA
    if(((bDeleteMe || int(CurrentOp) == int(80)) || (int(CurrentOp) == int(23)) && NameForString(IsXbox(), 'ControlX') || ! ControlX_IsControlled()) || (int(CurrentOp) == int(138)) && TeleportParms.bCantDie)
    {
        CheckHealthEvents(Instigator, HealthBefore);
        return;
    }
    AbortScript_Damaged(int(Damage), Instigator);
    CheckHealthEvents(Instigator, HealthBefore);
    // End:0x2D0
    if(Damage > 0)
    {
        // End:0x234
        if(Instigator == none)
        {
            // End:0x214
            if(Instigator.bIsPlayerPawn)
            {
                PlayerHate = MaxPlayerHate;
            }
            NotifyDamage(Instigator, int(Damage), DamageOrigin, DamageDirection, DamageType);
        }
        // End:0x251
        if(PopUp == none)
        {
            PopUpState.DamageTaken += Damage;
        }
        MaybePlayPainSound();
        // End:0x291
        if((bDontUseAIOPPain && int(FrozenState) == int(0)) && Level.GameTimeSeconds > PainOpGate)
        {
            ExecuteNonOPPain();
        }
        // End:0x2D0
        if((Health < (0.2 * HealthCap)) && FRand() < ChanceSayLowHealth)
        {
            ChanceSayLowHealth = 0;
            Level.TryBonusCode(self, 3);
        }
    }
    return;
}

function ExecuteNonOPPain()
{
    local name PainAnimName;

    GetPainAnimName(PainAnimName, PostOpAnimCtrl, DamageInfo.Part, WoundedBodySector);
    MaybeFadeChannelBlock('WeaponIdle', 1, 0.01);
    PlayAnim('Anim_PainRef');
    PlayAnim(PainAnimName);
    PainAnimRefID = AnimCtrl.m_oController.GetLastPrimaryRefId();
    PainOpGate = Level.GameTimeSeconds + MinPainOpInterval;
    return;
}

function bool ShouldUseDieOp(class<DamageType> DamageType)
{
    // End:0x1F
    if(IsA(DamageType, class'RailgunDamage') && ! bExpanding)
    {
        return false;
    }
    // End:0x51
    if(Level.TickHint().bOnSteroids && DamageType.static.ShouldDoSteroidsSpecialFX())
    {
        return false;
    }
    // End:0x7F
    if(IsA(DamageType, class'ThrownObjectImpactDamage') && DeathAnimChance != 0)
    {
        DeathAnimChance = ThrownObjectDeathAnimChance;
        return true;
    }
    return IsA(DamageType, class'BulletDamage') || IsA(DamageType, class'MeleeDamage');
    return;
}

event AIForceDeath()
{
    EnableIKSystem(0);
    DiedActivity();
    return;
}

function DiedActivity(optional Pawn Killer, optional int Damage, optional Vector DamageOrigin, optional Vector DamageDirection, optional class<DamageType> DamageType, optional name HitBoneName)
{
    local AIActor MySyncActor;

    // End:0x2F
    if((IsSyncing(MySyncActor)) && MySyncActor == none)
    {
        MySyncActor.NotifySyncBroken(self, 3);
    }
    AbortScripts();
    ActivateCloaking(false);
    DropTKObj();
    DropProp();
    ThrowPipeBomb();
    GetAnimGroup(5);
    // End:0x8B
    if(bPlayDeathSound && ! bSilentDestroy)
    {
        // End:0x80
        if(WasExecuted)
        {
            FindSoundAndSpeak('Sound_Executed');            
        }
        else
        {
            FindSoundAndSpeak('Sound_Death');
        }
    }
    // End:0xAB
    if((int(CurrentOp) == int(138)) && TeleportParms.bCantDie)
    {
        return;
    }
    ForceEndAllOverlayEffects();
    // End:0xF8
    if(ShouldUseDieOp(DamageType))
    {
        HaywireParms.HitNormal = DamageDirection;
        // End:0xE5
        if(int(ForceDieOp(80)) == int(0))
        {
            return;            
        }
        else
        {
            // End:0xF8
            if(int(ForceDieOp(23)) == int(0))
            {
                return;
            }
        }
    }
    Die(Killer, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName);
    return;
}

event Engine.BaseAI.EAICode ForceDieOp(Engine.BaseAI.EAIOp DieOp)
{
    local Engine.BaseAI.EAICode Code;

    Code = CanUseOp(DieOp);
    // End:0x47
    if(int(Code) == int(0))
    {
        CurrentOpMustFinish = false;
        SuspendExecutive(true);
        SuspendWeaponTargetEvaluation(true);
        SuspendLookTargetEvaluation(true);
        ExecuteOp(DieOp);
    }
    return Code;
    return;
}

event Die(optional Pawn Killer, optional int Damage, optional Vector DamageOrigin, optional Vector DamageDirection, optional class<DamageType> DamageType, optional name HitBoneName)
{
    DiedActivity(Killer, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName);
    return;
}

function BecomeDead()
{
    NotifyDied();
    RemoveTouchClass();
    return;
}

simulated function SpawnCorpse()
{
    // End:0x1B
    if(bDisableCorpseCleanup)
    {
        CorpseType.default.bNoAutoCleanup = true;
    }
    super(Pawn).SpawnCorpse();
    // End:0x3C
    if(bDisableCorpseCleanup)
    {
        CorpseType.default.bNoAutoCleanup = false;
    }
    // End:0xDD
    if(MyCorpse == none)
    {
        // End:0x6A
        if(NumEyeSets > 0)
        {
            MyCorpse.SetGlobalAnimRate(EyesClosedAnim,,,,, 1);
        }
        // End:0x83
        if(bDisableCorpseCleanup)
        {
            MyCorpse.DisableAutoRemoval();
        }
        // End:0xB4
        if(bFixCorpseRoot && ! DelayCorpseRagdoll)
        {
            KarmaEnableConstraint(KarmaSetupConstraint(class'KFixed', MyCorpse, 'Root'));
        }
        // End:0xDD
        if(! bIsBoss)
        {
            MyCorpse.IsMountedTo(CollisionRadius, 10 * DrawScale);
        }
    }
    return;
}

simulated function NotifyInstagib()
{
    // End:0x24
    if(InstaGibRandomImpulse > 0)
    {
        MyCorpse.AddRandomImpulseToSpawnedGibs(InstaGibRandomImpulse);
    }
    return;
}

simulated function ApplyDeathImpulseOverride(KarmaActor ImpulseCorpse, Vector DamageOrigin, name BoneName)
{
    local Vector Impulse;

    // End:0x77
    if(DeathImpulseOverride.bEnabled)
    {
        Impulse = DeathImpulseOverride.ImpulseMag >> Rotation;
        // End:0x58
        if(DeathImpulseOverride.bDebug)
        {
            GetSlotVolume(DamageOrigin, DamageOrigin + Impulse, NewColorBytes(255, 0, 0), 5);
        }
        ImpulseCorpse.ApplyImpulse(Impulse, DamageOrigin, 'Root');
    }
    return;
}

simulated function ApplyDeathImpulseExplosion(KarmaActor ImpulseCorpse, Vector DamageOrigin, name BoneName)
{
    // End:0x25
    if(DeathImpulseOverride.bEnabled)
    {
        ApplyDeathImpulseOverride(ImpulseCorpse, DamageOrigin, BoneName);
        return;
    }
    return;
}

function bool ShouldApplyHurtRadiusToCorpse()
{
    // End:0x10
    if(DeathImpulseOverride.bEnabled)
    {
        return false;
    }
    return super(Pawn).ShouldApplyHurtRadiusToCorpse();
    return;
}

simulated function ApplyDeathImpulse(KarmaActor ImpulseCorpse, int Damage, class<DamageType> DamageClass, Vector DamageOrigin, Vector DamageDir, name BoneName, Pawn DeathInstigator)
{
    local Vector LedgePos, DirToLedge2D, LedgeImpulse;
    local float MaxLedgeDist;

    // End:0x0E
    if(ImpulseCorpse != none)
    {
        return;
    }
    // End:0x33
    if(DeathImpulseOverride.bEnabled)
    {
        ApplyDeathImpulseOverride(ImpulseCorpse, DamageOrigin, BoneName);
        return;
    }
    // End:0x12C
    if(SizeLedgeImpulse > 0)
    {
        // End:0x5F
        if(LedgeDistOverride > 0)
        {
            MaxLedgeDist = LedgeDistOverride;            
        }
        else
        {
            MaxLedgeDist = CollisionHeight * 4;
        }
        // End:0x12C
        if(FindClosestLedge(LedgePos, MaxLedgeDist))
        {
            DirToLedge2D = LedgePos - Location;
            DirToLedge2D.Z = 0;
            DirToLedge2D = Normal(DirToLedge2D);
            LedgeImpulse = (DirToLedge2D * SizeLedgeImpulse) * 0.7;
            LedgeImpulse.Z = SizeLedgeImpulse * 0.3;
            ImpulseCorpse.SetHealth(LedgeImpulse, DamageOrigin, BoneName);
            // End:0x12A
            if(DebugLedges)
            {
                DrawArrow(Location, Normal(LedgeImpulse), SizeLedgeImpulse, 0, 0, 255, 255, 3);
            }
            return;
        }
    }
    super(Pawn).ApplyDeathImpulse(ImpulseCorpse, Damage, DamageClass, DamageOrigin, DamageDir, BoneName, DeathInstigator);
    return;
}

function Killed(Pawn Killer, Pawn Other, class<DamageType> DamageType, int KillingDamage, name KillBoneName)
{
    super(Pawn).Killed(Killer, Other, DamageType, KillingDamage, KillBoneName);
    // End:0x42
    if((Other != self) || Other.bSilentDestroy)
    {
        return;
    }
    // End:0xB5
    if((Killer != self) && FRand() < ChanceSayConfirmKill)
    {
        // End:0xA2
        if((int(Other.ConfirmKillDialog) != int(4)) && FRand() < 0.5)
        {
            Level.TryBonusCode(self, Other.ConfirmKillDialog);            
        }
        else
        {
            Level.TryBonusCode(self, 4);
        }        
    }
    else
    {
        // End:0xEE
        if((int(Other.Team) == int(Team)) && FRand() < ChanceSayManDown)
        {
            Level.TryBonusCode(self, 7);
        }
    }
    return;
}

simulated function bool CanBeSmashedBy(Pawn Stomper)
{
    // End:0x44
    if(Stomper.bIsPlayerPawn && RelationshipMgr.GetAttitudeTowards(self, Stomper, "CanBeSmashedBy") > float(0))
    {
        return false;
    }
    return true;
    return;
}

function PrepareForStomp(Pawn StompInstigator)
{
    Invulnerable = false;
    Destroy(3, false, 'ClearStomper');
    SuspendExecutive(true);
    EndOp(3);
    SetTurnToPresets(2, StompInstigator);
    ExecuteOp(144);
    return;
}

function ClearStomper()
{
    EndOp(3);
    SuspendExecutive(false);
    return;
}

function InstantShrink()
{
    ShrinkPawn(-1, true, true);
    return;
}

function OnStartShrink(optional bool bShrunkByPod)
{
    super(Pawn).OnStartShrink(bShrunkByPod);
    AbortScript_Shrunk();
    // End:0x42
    if(! self.ClassForName('Rat'))
    {
        RelationshipMgr.AddClassRelation(self, class'AIFactionRat', 3, 0.1);
    }
    return;
}

function OnFinishRestoreSize()
{
    super(Pawn).OnFinishRestoreSize();
    // End:0x36
    if(! self.ClassForName('Rat'))
    {
        RelationshipMgr.AddClassRelation(self, class'AIFactionRat', 4, 0.1);
    }
    return;
}

function UpdateShrinkScale(float ShrinkSizeScale)
{
    local int i, j, MaxContracts, MaxPartyParms;
    local bool SkipExtraWork;

    // End:0x17
    if(ShrinkScale == ShrinkSizeScale)
    {
        SkipExtraWork = true;
    }
    super(Pawn).UpdateShrinkScale(ShrinkSizeScale);
    // End:0x2D
    if(SkipExtraWork)
    {
        return;
    }
    SetCurrentWeapon(WeaponManager.CurrentWeaponClass);
    MinHorizDistPipeBomb = default.MinHorizDistPipeBomb * ShrinkSizeScale;
    MaxHorizDistPipeBomb = default.MaxHorizDistPipeBomb * ShrinkSizeScale;
    MinVertDistPipeBomb = default.MinVertDistPipeBomb * ShrinkSizeScale;
    MaxVertDistPipeBomb = default.MaxVertDistPipeBomb * ShrinkSizeScale;
    // End:0xCD
    if(! GuardInf.bDontScaleRangeWithDrawScale)
    {
        GuardInf.InnerRange = GuardInf.BaseInnerRange * ShrinkSizeScale;
        GuardInf.OuterRange = GuardInf.BaseOuterRange * ShrinkSizeScale;
    }
    RollForwardInfo = default.RollForwardInfo * ShrinkSizeScale;
    RollLeftInfo = default.RollLeftInfo * ShrinkSizeScale;
    RollRightInfo = default.RollRightInfo * ShrinkSizeScale;
    SizeLedgeImpulse = default.SizeLedgeImpulse * ShrinkSizeScale;
    MoveBackwardsDistThresh = default.MoveBackwardsDistThresh * ShrinkSizeScale;
    SideStepDistThresh = default.SideStepDistThresh * ShrinkSizeScale;
    WalkDistThresh = default.WalkDistThresh * ShrinkSizeScale;
    GotoPosRange = default.GotoPosRange * ShrinkSizeScale;
    GotoPosHeight = default.GotoPosHeight * ShrinkSizeScale;
    GotoPosFlyingRange = default.GotoPosFlyingRange * ShrinkSizeScale;
    GotoPosFlyingHeight = default.GotoPosFlyingHeight * ShrinkSizeScale;
    MinDistToGoal = default.MinDistToGoal * ShrinkSizeScale;
    MinMoveAroundDist = default.MinMoveAroundDist * ShrinkSizeScale;
    RndMoveAroundDist = default.RndMoveAroundDist * ShrinkSizeScale;
    MinBackOffDist = default.MinBackOffDist * ShrinkSizeScale;
    RndBackOffDist = default.RndBackOffDist * ShrinkSizeScale;
    MinMoveSideDist = default.MinMoveSideDist * ShrinkSizeScale;
    RndMoveSideDist = default.RndMoveSideDist * ShrinkSizeScale;
    MinMeleeRange = default.MinMeleeRange * ShrinkSizeScale;
    RndMeleeRange = default.RndMeleeRange * ShrinkSizeScale;
    MinMeleeHeight = default.MinMeleeHeight * ShrinkSizeScale;
    RndMeleeHeight = default.RndMeleeHeight * ShrinkSizeScale;
    MeleeZone = default.MeleeZone * ShrinkSizeScale;
    MeleeZoneHeight = default.MeleeZoneHeight * ShrinkSizeScale;
    MinMeleeStrafeRange = default.MinMeleeStrafeRange * ShrinkSizeScale;
    RndMeleeStrafeRange = default.RndMeleeStrafeRange * ShrinkSizeScale;
    MeleeAttackRange = default.MeleeAttackRange * ShrinkSizeScale;
    BiteDamageVel = default.BiteDamageVel * ShrinkSizeScale;
    ClawDamageVel = default.ClawDamageVel * ShrinkSizeScale;
    KickDamageVel = default.KickDamageVel * ShrinkSizeScale;
    MinChargeRange = default.MinChargeRange * ShrinkSizeScale;
    MaxChargeRange = default.MaxChargeRange * ShrinkSizeScale;
    MinChargeHeightDelta = default.MinChargeHeightDelta * ShrinkSizeScale;
    MaxChargeHeightDelta = default.MaxChargeHeightDelta * ShrinkSizeScale;
    MinChargeAttackRange = default.MinChargeAttackRange * ShrinkSizeScale;
    MaxChargeAttackRange = default.MaxChargeAttackRange * ShrinkSizeScale;
    MinAirAttackHeight = default.MinAirAttackHeight * ShrinkSizeScale;
    MaxAirAttackHeight = default.MaxAirAttackHeight * ShrinkSizeScale;
    MinJumpAttackRange = default.MinJumpAttackRange * ShrinkSizeScale;
    MaxJumpAttackRange = default.MaxJumpAttackRange * ShrinkSizeScale;
    MaxJumpAttackHeight = default.MaxJumpAttackHeight * ShrinkSizeScale;
    JumpAttackHeightDelta = default.JumpAttackHeightDelta * ShrinkSizeScale;
    JumpVel = default.JumpVel * ShrinkSizeScale;
    FallDistThresh = default.FallDistThresh * ShrinkSizeScale;
    LandingThresh = default.LandingThresh * ShrinkSizeScale;
    HeavyLandingThresh = default.HeavyLandingThresh * ShrinkSizeScale;
    GravityScale = default.GravityScale * ShrinkSizeScale;
    return;
}

event float GetGotoMeleeRange()
{
    // End:0x34
    if((PrimaryTargetActor == none) && PrimaryTargetActor.CollisionRadius < (CollisionRadius * 0.2))
    {
        return 0.01;
    }
    return 0;
    return;
}

animevent simulated function StartCloaking(optional EventInfo AnimEventInfo)
{
    ActivateCloaking(true);
    FindSoundAndSpeak('Sound_Cloak');
    return;
}

animevent simulated function StartDeCloaking(optional EventInfo AnimEventInfo)
{
    ActivateCloaking(false);
    FindSoundAndSpeak('Sound_Cloak');
    return;
}

event NotifyCloakingState(Engine.BaseAI.EAICloaking NewState)
{
    return;
}

event bool CreateTKShield()
{
    // End:0x0D
    if(! HasTKShield)
    {
        return false;
    }
    TKShield = EmptyTouchClasses(class'TeleKinesisShield', self);
    // End:0x2A
    if(TKShield != none)
    {
        return false;
    }
    TKShield.MoveActor(self);
    TKShield.IsMountedTo(float(TKShieldCollisionRadius), float(TKShieldCollisionHeight));
    return true;
    return;
}

function DestroyTKShield()
{
    // End:0x20
    if(TKShield == none)
    {
        TKShield.RemoveTouchClass();
        TKShield = none;
    }
    return;
}

function NotifyOtherTouched(Actor TouchedActor, Actor TouchingActor)
{
    local InteractiveActor InteractiveTouchingActor;

    // End:0xA5
    if(((TKShield == none) && TouchedActor != TKShield) && int(GetExecutive()) == int(2))
    {
        InteractiveTouchingActor = InteractiveActor(TouchingActor);
        // End:0xA5
        if((((InteractiveTouchingActor == none) && InteractiveTouchingActor == TKObj) && InteractiveTouchingActor.Instigator == self) && ! InteractiveTouchingActor.UnderTelekineticControl)
        {
            // End:0xA5
            if(ShouldCatchTKObj(InteractiveTouchingActor))
            {
                PerformCatchTKObj(InteractiveTouchingActor);
            }
        }
    }
    return;
}

animevent simulated function ThrowTKObj(optional EventInfo AnimEventInfo)
{
    // End:0x0E
    if(TKObj != none)
    {
        return;
    }
    DischargeTKObj(TKObjVel, true);
    return;
}

animevent simulated function DropTKObj(optional EventInfo AnimEventInfo)
{
    ReleaseTKObj();
    return;
}

animevent simulated function ReleaseTKObj(optional EventInfo AnimEventInfo)
{
    // End:0x0E
    if(TKObj != none)
    {
        return;
    }
    // End:0x3D
    if(int(TKObj.PostTKPhysics) == int(6))
    {
        DischargeTKObj(Vector(Rotation) * 1000, false);        
    }
    else
    {
        DischargeTKObj(Vect(100, 0, -100), false);
    }
    return;
}

event DropTKObjStraightDown()
{
    // End:0x0E
    if(TKObj != none)
    {
        return;
    }
    DischargeTKObj(Vect(0, 0, 0), false);
    return;
}

event bool ShouldCatchTKObj(InteractiveActor CandidateTKObj, optional bool bCheckLOS)
{
    local Vector DirTo;
    local float DistTo;

    // End:0x25
    if((CandidateTKObj != none) || ! CandidateTKObj.bTelekineticable)
    {
        return false;
    }
    // End:0xF8
    if((((! CurrentOpMustFinish && CandidateTKObj.Owner == self) && CandidateTKObj.CarriedBy != none) && (TKObj != none) || Projectile(CandidateTKObj) == none) && ! IsTKIgnoreClass(CandidateTKObj))
    {
        DirTo = CandidateTKObj.Location - Location;
        DistTo = VSize(DirTo);
        DirTo = DirTo / DistTo;
        // End:0xF8
        if((DistTo < MaxTKDistance) && (DirTo Dot Vector(Rotation)) > MinTKDot)
        {
            return true;
        }
    }
    return false;
    return;
}

function bool IsTKIgnoreClass(InteractiveActor CandidateTKObj)
{
    local int i;

    i = 0;
    J0x07:

    // End:0x3E [Loop If]
    if(i < string(TKIgnoreClasses))
    {
        // End:0x34
        if(CandidateTKObj.ClassForName(TKIgnoreClasses[i]))
        {
            return true;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return false;
    return;
}

event PerformCatchTKObj(InteractiveActor NewTKObj)
{
    // End:0x0E
    if(NewTKObj != none)
    {
        return;
    }
    // End:0x17
    if(DebugTK)
    {
    }
    // End:0x41
    if(TKObj == none)
    {
        // End:0x3B
        if(int(COND_ShouldThrowTKObj()) == int(0))
        {
            ThrowTKObj();            
        }
        else
        {
            ReleaseTKObj();
        }
    }
    // End:0xB1
    if((int(CurrentOp) == int(13)) || int(CurrentOp) == int(141))
    {
        // End:0x8A
        if(NumSecondaryTKCatchAnims > 0)
        {
            ++ TKCatchAnim;
            // End:0x87
            if(TKCatchAnim > NumSecondaryTKCatchAnims)
            {
                TKCatchAnim = 1;
            }            
        }
        else
        {
            TKCatchAnim = 0;
        }
        // End:0xAE
        if(int(GetExecutive()) == int(2))
        {
            SuspendExecutive(true);
            SuspendExecutive(false);
        }        
    }
    else
    {
        TKCatchAnim = 0;
    }
    TKObj = NewTKObj;
    TKObj.StartTelekinesis(self);
    // End:0xF1
    if(int(GetExecutive()) == int(2))
    {
        CurrentOpShouldFinish = false;
        ForceExecutive();
    }
    return;
}

event DischargeTKObj(Vector Vel, bool Constrain)
{
    // End:0x37
    if(DebugTK)
    {
        DrawArrow(TKObj.Location, Normal(Vel), VSize(Vel), 255, 0, 0, 255, 5);
    }
    TKObj.Instigator = self;
    TKObj.TelekineticThrow(Vel, Constrain);
    TKObj = none;
    return;
}

function NotifyTeleKinesisStarted(InteractiveActor TeleKinesisActor)
{
    return;
}

function NotifyTeleKinesisStopped(InteractiveActor TeleKinesisActor)
{
    // End:0x25
    if((TeleKinesisActor == none) && TeleKinesisActor != TKObj)
    {
        TKObj = none;
    }
    return;
}

event DisablePropInteractions(bool Disable)
{
    // End:0x22
    if(DesiredProp == none)
    {
        DesiredProp.ReserveForPickup(Disable);
    }
    // End:0x44
    if(Prop == none)
    {
        Prop.ReserveForPickup(Disable);
    }
    return;
}

event name GetPropName(InteractiveActor MyProp)
{
    // End:0x1B
    if(MyProp.ClassForName('Barrels_Generic'))
    {
        return 'barrel';
    }
    return 'None';
    return;
}

function bool CanDoAnimHurl(InteractiveActor DesiredProp)
{
    // End:0x0D
    if(! CanAnimHurl)
    {
        return false;
    }
    // End:0x1B
    if(DesiredProp != none)
    {
        return false;
    }
    return true;
    return;
}

animevent simulated function PickupProp(optional EventInfo AnimEventInfo)
{
    // End:0x0E
    if(DesiredProp != none)
    {
        return;
    }
    DesiredProp.ForceMountUpdate(,,, false);
    DesiredProp.PickedUp(self);
    Prop = DesiredProp;
    DesiredProp = none;
    SayDialog('Sound_Pickup');
    return;
}

animevent simulated function ThrowProp(optional EventInfo AnimEventInfo)
{
    local Vector ThrowVel;

    // End:0x0E
    if(Prop != none)
    {
        return;
    }
    Prop.ForceMountUpdate(,,, true);
    Prop.TimeWarp = Prop.default.TimeWarp;
    // End:0xC1
    if(((Prop.ThrowForceScaleAI < 0) && ! PrimaryTarget.IsValidTarget()) && CalcProjectileVelocity(Prop, 18, PrimaryTargetActor, PrimaryTarget.GetPos(), 0, 30, 30, false, 800, false, 3, 0, true, ThrowVel, DebugProps))
    {        
    }
    else
    {
        // End:0xF7
        if(! PrimaryTarget.IsValidTarget())
        {
            ThrowVel = Vect(1500, 0, 0) >> Rotation;            
        }
        else
        {
            ThrowVel = Normal(PrimaryTarget.GetPos() - Location) * 1500;
        }
    }
    // End:0x14C
    if(Prop.ThrowForceScaleAI > 0)
    {
        ThrowVel *= Prop.ThrowForceScaleAI;
    }
    SayDialog('Sound_Throw');
    Prop.Thrown(ThrowVel, self);
    Prop = none;
    return;
}

animevent simulated function HurlProp(optional EventInfo AnimEventInfo)
{
    local Vector ThrowVel;

    // End:0x0E
    if(DesiredProp != none)
    {
        return;
    }
    // End:0x93
    if(! PrimaryTarget.IsValidTarget() || ! CalcProjectileVelocity(DesiredProp, 18, PrimaryTargetActor, PrimaryTarget.GetPos(), 0, 30, 40, false, 800, false, 3, 0, true, ThrowVel, DebugProps))
    {
        ThrowVel = Vect(600, 0, 300) >> Rotation;
    }
    DesiredProp.Thrown(ThrowVel, self);
    DesiredProp = none;
    return;
}

event DropProp()
{
    // End:0x6C
    if(Prop == none)
    {
        Prop.TimeWarp = Prop.default.TimeWarp;
        Prop.Thrown(Vect(25, 0, 10) >> Rotation, self);
        Prop.ForceMountUpdate(,,, true);
        Prop = none;
    }
    return;
}

function AIDebug_Toggle(string strWhat)
{
    return;
}

function SetFactory(AIActorFactory NewFactory, AIActorFactoryManager NewManager)
{
    Factory = NewFactory;
    FactoryManager = NewManager;
    return;
}

function ClearFactory()
{
    // End:0x1D
    if(Factory == none)
    {
        Factory.RemoveSpawn(self);
    }
    Factory = none;
    FactoryManager = none;
    return;
}

event SetFactoryActionPointIndex(int NewCurrent, int NewDesired, optional name FactoryTag)
{
    local AIActorFactoryManager MyFactoryMgr;
    local AIActorFactory MyFactory;

    // End:0x57
    if((FactoryManager == none) && (FactoryTag != 'None') || FactoryTag != FactoryManager.Tag)
    {
        FactoryManager.SetActionPointIndex(NewCurrent, NewDesired);        
    }
    else
    {
        // End:0xAE
        if((Factory == none) && (FactoryTag != 'None') || FactoryTag != Factory.Tag)
        {
            Factory.SetActionPointIndex(NewCurrent, NewDesired);            
        }
        else
        {
            // End:0x12C
            if(NameForString(FactoryTag, 'None'))
            {
                // End:0xEE
                foreach RotateVectorAroundAxis(class'AIActorFactoryManager', MyFactoryMgr, FactoryTag)
                {
                    MyFactoryMgr.SetActionPointIndex(NewCurrent, NewDesired);                    
                }                
                // End:0x12C
                if(MyFactoryMgr != none)
                {
                    // End:0x12B
                    foreach RotateVectorAroundAxis(class'AIActorFactory', MyFactory, FactoryTag)
                    {
                        MyFactory.SetActionPointIndex(NewCurrent, NewDesired);                        
                    }                    
                }
            }
        }
    }
    return;
}

event SetFactoryActionPointTags(int NewCurrent, int NewDesired, array<name> NewTags, optional name FactoryTag)
{
    local AIActorFactoryManager MyFactoryMgr;
    local AIActorFactory MyFactory;
    local bool Found;

    Found = false;
    // End:0x6C
    if((FactoryManager == none) && (FactoryTag != 'None') || FactoryTag != FactoryManager.Tag)
    {
        Found = true;
        FactoryManager.SetActionPointTags(NewCurrent, NewDesired, NewTags);        
    }
    else
    {
        // End:0xD0
        if((Factory == none) && (FactoryTag != 'None') || FactoryTag != Factory.Tag)
        {
            Found = true;
            Factory.SetActionPointTags(NewCurrent, NewDesired, NewTags);            
        }
        else
        {
            // End:0x168
            if(NameForString(FactoryTag, 'None'))
            {
                // End:0x11D
                foreach RotateVectorAroundAxis(class'AIActorFactoryManager', MyFactoryMgr, FactoryTag)
                {
                    Found = true;
                    MyFactoryMgr.SetActionPointTags(NewCurrent, NewDesired, NewTags);                    
                }                
                // End:0x168
                if(MyFactoryMgr != none)
                {
                    // End:0x167
                    foreach RotateVectorAroundAxis(class'AIActorFactory', MyFactory, FactoryTag)
                    {
                        Found = true;
                        MyFactory.SetActionPointTags(NewCurrent, NewDesired, NewTags);                        
                    }                    
                }
            }
        }
    }
    // End:0x1EB
    if(! Found)
    {
        BroadcastLog("Warning! Call to SetFactoryActionPointTags with invalid parameters. Did you mean to use SetActionPointTags?" @ string(self));
    }
    return;
}

event bool BlinkingEnabled()
{
    // End:0x1E
    if((NumEyeSets > 0) && MaxBlinkTime > 0)
    {
        return true;
    }
    return false;
    return;
}

event EnableBlinking()
{
    MaxBlinkTime = default.MaxBlinkTime;
    Destroy(RandRange(MinBlinkTime, MaxBlinkTime), false, 'bLink');
    return;
}

event DisableBlinking()
{
    MaxBlinkTime = 0;
    Spawn('bLink');
    return;
}

event bLink()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x2E [Loop If]
    if(i < NumEyeSets)
    {
        Anim_EyesBlink(i + 1);
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    Destroy(RandRange(MinBlinkTime, MaxBlinkTime), false, 'bLink');
    return;
}

event InitDrool()
{
    // End:0x47
    if((DroolParms.MinSpitTime > float(0)) && DroolParms.SpawnClass == none)
    {
        Destroy(DroolParms.MinSpitTime + (FRand() * DroolParms.RndSpitTime), false, 'DroolSpit_Callback');
    }
    return;
}

event DroolSpit()
{
    local Vector baselocation;
    local Rotator BaseRotation;

    // End:0x49
    if(SetScaleModifier() == none)
    {
        baselocation = MeshInstance.CreateAnimGroup(DroolParms.Bone, true);
        BaseRotation = MeshInstance.SwapChannel(DroolParms.Bone, true);        
    }
    else
    {
        baselocation = Location;
        BaseRotation = Rotation;
    }
    ExecuteFriendSpawner(DroolParms.SpawnClass, baselocation + TransformVectorByRot(DroolParms.Location, BaseRotation), DroolParms.Rotation >> BaseRotation, DrawScale / default.DrawScale);
    return;
}

function DroolSpit_Callback()
{
    DroolSpit();
    Destroy(DroolParms.MinSpitTime + (FRand() * DroolParms.RndSpitTime), false, 'DroolSpit_Callback');
    return;
}

simulated event InitializeTargets()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x2C [Loop If]
    if(i < string(TargetActors))
    {
        FreeTargetActorSlot(i);
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    TargetActors.Empty();
    PrimaryTarget = new (Level.XLevel) class'AITarget';
    PrimaryTarget.Initialise(self, ClearTargetTime, TargetVisTestInt, CanSeeTargets, CanHearTargets);
    FollowTarget = new (Level.XLevel) class'AITarget';
    FollowTarget.Initialise(self, ClearTargetTime, TargetVisTestInt, CanSeeTargets, CanHearTargets);
    return;
}

event NotifySetTargetActor()
{
    PrimaryTargetActor = GetTargetActor(0);
    NotifyWeaponManagerNewTarget(PrimaryTargetActor);
    // End:0x30
    if(PrimaryTargetActor == none)
    {
        SquadShareTarget(PrimaryTargetActor);
    }
    return;
}

event NotifyTargetLost()
{
    // End:0x1B
    if(NameForString(TargetClearedEvent, 'None'))
    {
        GlobalTrigger(TargetClearedEvent);
    }
    PrimaryTargetActor = none;
    return;
}

event EvaluateTargets(Engine.BaseAI.EAITargetEval TargetEvaluator)
{
    return;
}

event bool ShouldTargetNoiseMaker(Actor NoiseMaker)
{
    local Pawn NoisyPawn;

    NoisyPawn = Pawn(NoiseMaker);
    // End:0x55
    if(NoisyPawn == none)
    {
        // End:0x55
        if(RelationshipMgr.GetAttitudeTowards(self, NoisyPawn, "ShouldTargetNoiseMaker:0") < float(0))
        {
            return true;
        }
    }
    return false;
    return;
}

function ExecuteAmbientSound()
{
    local float Delay;

    // End:0x10
    if(int(CurrentOp) == int(23))
    {
        return;
    }
    // End:0x34
    if(! Level.AISoundAllowed(1))
    {
        SetExecuteAmbientSoundCallbackTimer(1);
        return;
    }
    // End:0xD3
    if((PrimaryTargetActor != none) || ! PrimaryTarget.IsValidTarget())
    {
        // End:0xA0
        if(AmbientSoundInfo.bDebug)
        {
            BroadcastLog((string(self) @ " Idle Sound: No Target. Playing ") $ string(AmbientSoundInfo.NoTargetSoundName));
        }
        FindSoundAndSpeak(AmbientSoundInfo.NoTargetSoundName);
        SetExecuteAmbientSoundCallbackTimer(AmbientSoundInfo.NoTargetIdleInterval + (FRand() * AmbientSoundInfo.NoTargetIdleRnd));        
    }
    else
    {
        // End:0x171
        if(PrimaryTarget.GetTimeSinceSeen() > 0.25)
        {
            // End:0x13E
            if(AmbientSoundInfo.bDebug)
            {
                BroadcastLog((string(self) @ " Idle Sound: No Visible Target. Playing ") $ string(AmbientSoundInfo.TargetNotVisibleSoundName));
            }
            FindSoundAndSpeak(AmbientSoundInfo.TargetNotVisibleSoundName);
            SetExecuteAmbientSoundCallbackTimer(AmbientSoundInfo.NoTargetIdleInterval + (FRand() * AmbientSoundInfo.NoTargetIdleRnd));            
        }
        else
        {
            // End:0x1BF
            if(AmbientSoundInfo.bDebug)
            {
                BroadcastLog((string(self) @ " Idle Sound: Visible Target. Playing ") $ string(AmbientSoundInfo.TargetVisibleSoundName));
            }
            FindSoundAndSpeak(AmbientSoundInfo.TargetVisibleSoundName);
            SetExecuteAmbientSoundCallbackTimer(AmbientSoundInfo.BattleIdleInterval + (FRand() * AmbientSoundInfo.BattleIdleRnd));
        }
    }
    return;
}

event SetExecuteAmbientSoundCallbackTimer(optional float Delay)
{
    // End:0x1D
    if(Delay > 0)
    {
        Destroy(Delay, false, 'ExecuteAmbientSound');
    }
    return;
}

event NotifyTargetSpotted(float TimeSinceLastScene)
{
    // End:0x94
    if(! Level.AISoundAllowed(0))
    {
        // End:0x92
        if(AmbientSoundInfo.bDebug)
        {
            BroadcastLog((string(self) @ "Target spotted but another AI has alerted this frame. Not playing any sounds.") @ string(Level.GameTimeSeconds));
        }
        return;
    }
    // End:0x132
    if((TimeSinceLastScene <= 0) || TimeSinceLastScene > AmbientSoundInfo.TargetAquiredMinInterval)
    {
        FindSoundAndSpeak(AmbientSoundInfo.TargetAquiredSoundName);
        -- Level.MaxAlertSoundsPerFrame;
        // End:0x12F
        if(AmbientSoundInfo.bDebug)
        {
            BroadcastLog((string(self) @ "target Spotted! - Playing Sound_Alert. ") @ string(Level.GameTimeSeconds));
        }        
    }
    else
    {
        // End:0x1A1
        if(AmbientSoundInfo.bDebug)
        {
            BroadcastLog((string(self) @ "target Spotted - but wasnt lost for long enough. Time inbetween spottings: ") $ string(TimeSinceLastScene));
        }
    }
    return;
}

// Export UAIActor::execShouldProceduralAim(FFrame&, void* const)
native(1330) function bool ShouldProceduralAim();

event bool ShouldProceduralFire()
{
    return ((((((ProcAimingEnabledThisFrame && CanProcFire) && ProceduralMovingFire) && BoneAimerOnTarget) && (MovingFireGate <= 0) || Level.GameTimeSeconds > MovingFireGate) && PrimaryTarget.IsValidTarget()) && (PrimaryTarget.GetTimeVisible() > 0) && PrimaryTarget.GetTimeSinceSeen() < ProcFireMaxTimeSinceSeen) && ! IsCloaked();
    return;
}

event bool ShouldProceduralHeadAim()
{
    local Engine.BaseAI.EAIOp MyOp;

    // End:0x0D
    if(! HasBoneHeadAimer)
    {
        return false;
    }
    MyOp = GetCurrentOp();
    // End:0x9D
    if(((((((int(MyOp) == int(18)) || int(MyOp) == int(104)) || int(MyOp) == int(96)) || int(MyOp) == int(23)) || Health <= float(0)) || bAnimCutScene && int(MyOp) != int(100)) || (IsDoingSyncedAnim()) && int(MyOp) != int(100))
    {
        return false;
    }
    // End:0xD3
    if(((int(MyOp) == int(100)) && PopUp == none) && PopUp.BoneAimerDisabled)
    {
        return false;        
    }
    return true;
    return;
}

event DebugDrawBone(name TrackBone)
{
    local Vector Start;
    local Rotator Rot;

    SetScaleModifier();
    Start = MeshInstance.CreateAnimGroup(TrackBone, true, false);
    Rot = MeshInstance.SwapChannel(TrackBone, true);
    DrawArrow(Start, Vector(Rot), 100, 255, 255, 0, 255, 0.1);
    return;
}

function Vector GetFireAimAtPos()
{
    local Vector EndPos;

    // End:0x24
    if(! AimAtEye)
    {
        EndPos = PrimaryTarget.GetAimPos();        
    }
    else
    {
        EndPos = PrimaryTarget.GetEyePos();
    }
    return EndPos;
    return;
}

simulated function GetMuzzleMountLocation(name MuzzleName, out Vector MuzzlePos, out Rotator MuzzleRot)
{
    FindBlockingActors(MuzzleName, MuzzlePos, MuzzleRot);
    return;
}

simulated function GetFireParms(name MuzzleName, out Vector MuzzlePos, out Vector EndPos, out Vector MuzzleDir, out Vector FireDir, float LeadTime, bool ApplyError)
{
    local Rotator MuzzleRot, FireDirRot;
    local float HorizError, VertError, ShotLen;
    local Vector TargetVel2D;
    local Engine.BaseAI.EAIOp MyOp;

    // End:0x76
    if(((MuzzleName != 'None') && Weapon == none) && IsA(Weapon.Class, class'TripMine'))
    {
        MuzzlePos = Location;
        MuzzleDir = Normal(PlaceTripMineParms.TargetActor.Location - MuzzlePos);
        FireDir = MuzzleDir;        
    }
    else
    {
        // End:0x9E
        if(NameForString(MuzzleName, 'None'))
        {
            GetMuzzleMountLocation(MuzzleName, MuzzlePos, MuzzleRot);            
        }
        else
        {
            // End:0xC7
            if(Weapon == none)
            {
                Weapon.GetCurrentBarrelLocation(MuzzlePos, MuzzleRot);                
            }
            else
            {
                // End:0xEC
                if(NameForString(ProjectileMuzzleName, 'None'))
                {
                    FindBlockingActors(ProjectileMuzzleName, MuzzlePos, MuzzleRot);                    
                }
                else
                {
                    MuzzlePos = GetProjectileFireLocation();
                    MuzzleRot = Rotation;
                }
            }
        }
        MuzzleDir = Vector(MuzzleRot);
        MyOp = GetCurrentOp();
        // End:0x232
        if(! ForceNonDirectShot && (((PrimaryTarget == none) && PrimaryTarget.IsValidTarget()) && (int(MyOp) != int(96)) && int(MyOp) != int(23)) && (((int(MyOp) == int(100)) && PopUp == none) && ! PopUp.bDisableForceDirectShot) || (IsWeaponAimerOn()) || ForceDirectShot)
        {
            EndPos = GetFireAimAtPos();
            // End:0x208
            if(LeadTime != 0)
            {
                TargetVel2D = PrimaryTarget.GetVel();
                TargetVel2D.Z = 0;
                EndPos += (TargetVel2D * LeadTime);
            }
            FireDirRot = Rotator(EndPos - MuzzlePos);
            ShotLen = VSize(EndPos - MuzzlePos);            
        }
        else
        {
            ShotLen = 2000;
            EndPos = MuzzlePos + (MuzzleDir * ShotLen);
            FireDirRot = MuzzleRot;
        }
        // End:0x2C2
        if(ApplyError)
        {
            GetWeaponError(HorizError, VertError);
            FireDirRot += Rot(int(VertError * (FRand() - 0.5)), int(HorizError * (FRand() - 0.5)), 0);
            EndPos = MuzzlePos + (ShotLen * Vector(FireDirRot));
        }
        FireDir = Vector(FireDirRot);
    }
    return;
}

animevent simulated function ForceShoot(optional EventInfo AnimEventInfo)
{
    local float Chance;

    Chance = float(AnimEventInfo.EventString);
    // End:0x45
    if(((Chance <= 0) || Chance >= 1) || FRand() < Chance)
    {
        AIActor_Weapon_Fire();
    }
    return;
}

animevent simulated function ForceShootNoAnim(optional EventInfo AnimEventInfo)
{
    local float Chance;

    Chance = float(AnimEventInfo.EventString);
    // End:0x57
    if(((Chance <= 0) || Chance >= 1) || FRand() < Chance)
    {
        bHackAIWantsToFire = true;
        Weapon.AttemptFire();
    }
    return;
}

animevent simulated function ForceShootNoFireAnim(optional EventInfo AnimEventInfo)
{
    bDontPlayShootAnim = true;
    AIActor_Weapon_Fire();
    return;
}

animevent simulated function ForceShootNoFireAnimNoAim(optional EventInfo AnimEventInfo)
{
    bDontPlayShootAnim = true;
    ForceNonDirectShot = true;
    AIActor_Weapon_Fire();
    return;
}

event GetWeaponError(out float HorizError, out float VertError)
{
    // End:0x23
    if(IsNotFinal('GotoX'))
    {
        HorizError = WpnMovingHorizError;
        VertError = WpnMovingVertError;
        return;
    }
    HorizError = WpnSteadyHorizError;
    VertError = WpnSteadyVertError;
    return;
    return;
}

function Vector GetAimPos()
{
    return Location;
    return;
}

simulated event Vector GetProjectileFireLocation()
{
    // End:0x25
    if(NameForString(ProjectileMuzzleName, 'None'))
    {
        return MeshInstance.CreateAnimGroup(ProjectileMuzzleName, true, false);
    }
    return Location;
    return;
}

simulated event Vector GetWeaponFireLocation()
{
    return Location;
    return;
}

event CreateShootProjectileEffects()
{
    return;
}

event DestroyShootProjectileEffects()
{
    return;
}

function float CalcLeadTime(float Speed)
{
    // End:0x3D
    if((! PrimaryTarget.IsValidTarget() || LeadTimeK == 0) || Speed <= 0)
    {
        return 0;
    }
    return (PrimaryTarget.GetDist() / Speed) * LeadTimeK;
    return;
}

function dnProjectile FireProjectile(name MuzzleName, class<dnProjectile> ProjClass, float LeadTime, bool CheckLOS)
{
    local Vector Start, End, MuzzleDir, FireDir;
    local Rotator ProjRot;
    local dnProjectile Projectile;

    // End:0x9C
    if(! CheckLOS || (PrimaryTargetActor == none) && ClearShot(PrimaryTargetActor, Location, PrimaryTarget.GetPos(), 3, 0, DebugLOSChecks))
    {
        GetFireParms(MuzzleName, Start, End, MuzzleDir, FireDir, LeadTime, true);
        ProjRot = Rotator(FireDir);
        Projectile = EmptyTouchClasses(ProjClass, self,, Start, ProjRot);
        return Projectile;
    }
    return none;
    return;
}

simulated function bool ApplyDamage(class<DamageType> DamageClass, int DamageAmount, Vector DamageVel, int SlashType)
{
    local Actor HitActor;

    // End:0x93
    if(PrimaryTarget.IsValidTarget() && PrimaryTargetActor == none)
    {
        HitActor = DoMeleeDamage(float(DamageAmount), DamageClass, SlashType);
        // End:0x93
        if(HitActor == none)
        {
            // End:0x91
            if((HitActor.bIsPawn && VSizeSquared(DamageVel) > 0) && ! bDisableThrowAttack)
            {
                ThrowAttack(Pawn(HitActor), DamageVel);
            }
            return true;
        }
    }
    return false;
    return;
}

function bool ShouldApplyMeleeDamageToActor(Actor HitActor)
{
    return true;
    return;
}

function Actor DoMeleeDamage(float DamageAmount, class<DamageType> DamageClass, int SlashType, optional float RangeOverride, optional bool IgnorePlayer)
{
    local bool TargetValid;
    local Vector FwdDir, TraceStart, TraceDir, TraceEnd;
    local float TraceLength, HalfCollisionHeight;
    local STraceFlags Flags;
    local STraceHitResult Result;
    local Actor HitActor;
    local class<Material> HitMaterial;
    local KarmaActor CarriedItem;
    local Vector RandomDrop;
    local class<TraceDamageType> TraceDamageType;

    TargetValid = PrimaryTarget.IsValidTarget();
    TraceStart = Location;
    FwdDir = Vector(Rotation);
    HalfCollisionHeight = 0.5 * CollisionHeight;
    TraceStart.Z += HalfCollisionHeight;
    // End:0xA6
    if(TargetValid)
    {
        // End:0x87
        if(PrimaryTargetActor == none)
        {
            TraceDir = Normal(PrimaryTargetActor.Location - TraceStart);            
        }
        else
        {
            TraceDir = Normal(PrimaryTarget.GetAimPos() - TraceStart);
        }
    }
    // End:0xDB
    if(! TargetValid || (FwdDir Dot TraceDir) < (1 - MeleeAttackArc))
    {
        TraceDir = FwdDir;
    }
    // End:0xF8
    if(RangeOverride > 0)
    {
        TraceLength = RangeOverride;        
    }
    else
    {
        TraceLength = MeleeAttackRange + (CollisionRadius * 2);
    }
    TraceLength += HalfCollisionHeight;
    TraceEnd = TraceStart + (TraceDir * TraceLength);
    Flags.bTraceActors = true;
    Flags.bMeshAccurate = false;
    Flags.bShotTrace = true;
    Flags.bTraceTexture = true;
    Flags.bIgnoreAITransparent = true;
    HitActor = AllActors(TraceStart, TraceEnd, Flags, Result);
    // End:0x1A2
    if(HitActor != none)
    {
        return none;
    }
    // End:0x1C2
    if(IgnorePlayer && HitActor.bIsPlayerPawn)
    {
        return none;
    }
    // End:0x1D4
    if(! ShouldApplyMeleeDamageToActor(HitActor))
    {
        return none;
    }
    // End:0x20C
    if((HitActor == none) && Result.Texture != none)
    {
        Result.Texture = HitActor.RadiusActors(0);
    }
    // End:0x29A
    if(Result.Texture == none)
    {
        HitMaterial = Result.Texture.GetMaterial();
        TraceDamageType = class<TraceDamageType>(DamageClass);
        // End:0x25F
        if(TraceDamageType != none)
        {
            TraceDamageType = class'MeleeDamage';
        }
        TraceFireMaterialHit(TraceDamageType, HitActor, Result.Location, Result.Normal, HitMaterial, Result.Texture.TextSize());
    }
    // End:0x2D0
    if(HitActor.bIsPawn && ! HitActor.bIsPlayerPawn)
    {
        DamageAmount *= 10;
    }
    HitActor.TakeDamage(self, DamageAmount, Result.Location, TraceDir, DamageClass,, Location);
    // End:0x3D6
    if((PrimaryTargetActor == none) && PrimaryTargetActor.bIsPawn)
    {
        CarriedItem = Pawn(PrimaryTargetActor).CarriedActor;
        // End:0x3D6
        if(CarriedItem != HitActor)
        {
            Pawn(PrimaryTargetActor).DropCarriedActor(,,,, true);
            RandomDrop = VVar(Vect(1, 0, 0), Vect(0, 4, 0.5));
            RandomDrop = ((1000 * DamageAmount) * RandomDrop) >> PrimaryTargetActor.Rotation;
            CarriedItem.SetHealth(RandomDrop, Result.Location);
        }
    }
    DoExtraMeleeEffects(HitActor, DamageAmount, Result.Location, TraceDir, DamageClass);
    return HitActor;
    return;
}

function DoExtraMeleeEffects(Actor DamagedActor, float DamageAmount, Vector DamageLocation, Vector Direction, Class DamageClass)
{
    return;
}

simulated function bool ThrowAttack(Pawn TargetPawn, Vector ThrowVel)
{
    // End:0x0E
    if(TargetPawn != none)
    {
        return false;
    }
    ThrowVel = ThrowVel >> Rotation;
    ThrowVel = ThrowVel * TargetPawn.DrawScale;
    // End:0x86
    if((int(TargetPawn.Physics) == int(1)) || int(TargetPawn.Physics) == int(4))
    {
        TargetPawn.AddVelocity(ThrowVel);        
    }
    else
    {
        // End:0xB4
        if(int(TargetPawn.Physics) == int(18))
        {
            TargetPawn.GameplayDesiredPhysicsVelocity += ThrowVel;
        }
    }
    return true;
    return;
}

function Vector GetStompOrigin()
{
    return MeshInstance.IsAnyAnimating(StompInfo[StompIndex].BoneName);
    return;
}

event int GetStompIndex()
{
    return Rand(string(StompInfo));
    return;
}

function DoStompDamage()
{
    local SoftParticleSystem HitEffectActor;
    local SStompInfo Info;
    local Vector StompOrigin;
    local int i;

    // End:0x6A
    if((StompIndex < 0) || StompIndex >= string(StompInfo))
    {
        BroadcastLog("AI Warning: Called DoStompDamage with invalid StompIndex. " $ string(StompIndex));
        return;
    }
    Info = StompInfo[StompIndex];
    SetScaleModifier();
    StompOrigin = GetStompOrigin();
    StompInfo[StompIndex].StompLocation = StompOrigin;
    FindSoundAndSpeak('Sound_Stomp');
    // End:0xDC
    if(Info.bDebug)
    {
        GetGlobalVolume(StompOrigin, Info.StompDamageRadius, NewColorBytes(255, 0, 0), 2);
    }
    HurtRadius(Info.StompDamageAmount, StompOrigin, Info.ShakeRadius, Info.ShakeRadius, class'CrushingDamageAI');
    HitEffectActor = FindFriendSpawner(Info.ParticleEffectClass);
    // End:0x184
    if(HitEffectActor == none)
    {
        HitEffectActor.SetDesiredRotation(StompOrigin);
        HitEffectActor.DisableDesiredRotation_Roll(Rotator(Vect(0, 0, 1)));
        // End:0x184
        if(dnFriendFX_Spawners(HitEffectActor) == none)
        {
            dnFriendFX_Spawners(HitEffectActor).ExecuteEffect(true);
        }
    }
    i = 0;
    J0x18B:

    // End:0x227 [Loop If]
    if(i < string(Info.AdditionalEffectBones))
    {
        StompOrigin = MeshInstance.CreateAnimGroup(Info.AdditionalEffectBones[i], true, false);
        HitEffectActor.SetDesiredRotation(StompOrigin);
        HitEffectActor.DisableDesiredRotation_Roll(Rotator(Vect(0, 0, 1)));
        // End:0x21D
        if(dnFriendFX_Spawners(HitEffectActor) == none)
        {
            dnFriendFX_Spawners(HitEffectActor).ExecuteEffect(true);
        }
        ++ i;
        // [Loop Continue]
        goto J0x18B;
    }
    return;
}

simulated function bool CanHurtRadiusOther(Actor Other)
{
    local dnDecoration deco;
    local VehicleBase VehicleOther;
    local VehicleSpaceBase VehicleSpace;
    local Pawn PawnOther;
    local SStompInfo Info;
    local Vector Impulse, Delta2D, Dir;
    local float DeltaZ, DistSq;

    // End:0x6BB
    if(((int(CurrentOp) == int(135)) && StompIndex >= 0) && StompIndex < string(StompInfo))
    {
        Info = StompInfo[StompIndex];
        // End:0x7A
        if(Other.bIsVehicle)
        {
            VehicleOther = VehicleBase(Other);
            PawnOther = VehicleOther.VehicleGetDriver();            
        }
        else
        {
            // End:0x1C0
            if(Other.bIsPawn)
            {
                PawnOther = Pawn(Other);
                VehicleSpace = VehicleSpaceBase(PawnOther.InteractiveDecoration);
                // End:0x171
                if(((VehicleSpace == none) && VehicleSpace.Vehicle == none) && VehicleSpace.Vehicle.VehicleGetDriver() != PawnOther)
                {
                    // End:0x16F
                    if(Info.bDebug)
                    {
                        BroadcastLog(("Stomp: Ignoring" @ string(PawnOther)) @ "because he is the driver of a vehicle which might get hit.");
                    }
                    return false;
                }
                // End:0x1BD
                if((! PawnOther.bIsPlayerPawn && Info.StompDamageAmount > float(0)) && PawnOther.PhysController_SetGroundConstraintDirection())
                {
                    PawnOther.EnableIKSystem(1);
                }                
            }
            else
            {
                // End:0x1E3
                if(Other.bIsdnDecoration)
                {
                    deco = dnDecoration(Other);
                }
            }
        }
        // End:0x54A
        if(PawnOther == none)
        {
            // End:0x223
            if(PawnOther.bIsPlayerPawn)
            {
                PawnOther.ShakeView(StompInfo[StompIndex].ShakeInfo, false);
            }
            DeltaZ = Other.Location.Z - Info.StompLocation.Z;
            Delta2D = (Other.Location - Info.StompLocation) * Vect(1, 1, 0);
            DistSq = VSizeSquared(Delta2D);
            // End:0x2FA
            if(Info.bDebug)
            {
                BroadcastLog("Stomp: Stomping Player Height =" $ string(DeltaZ));
                GetSlotVolume(Other.Location, Info.StompLocation, NewColorBytes(255, 255, 0), 3);
            }
            // End:0x4CF
            if(DistSq < (Info.StompDamageRadius * Info.StompDamageRadius))
            {
                // End:0x44D
                if(((Info.bCanStompShrunk || PawnOther.PhysController_SetGroundConstraintDirection()) || PawnOther.Stompable) && DeltaZ <= Info.SafeHeight)
                {
                    // End:0x3BF
                    if((Info.StompDamageVel > 0) && PawnOther.XBoxIsSignedIn())
                    {
                        Impulse = Vect(Info.StompDamageVel, 0, Info.StompDamageLift);
                        ThrowAttack(PawnOther, Impulse);                        
                    }
                    else
                    {
                        // End:0x40A
                        if(Info.bDebug)
                        {
                            BroadcastLog(string(self) @ "Stomp: Target not on ground - no impulse applied");
                        }
                    }
                    // End:0x448
                    if(PawnOther.bIsPlayerPawn && StompInfo[StompIndex].bLightRumbleOnDamage)
                    {
                        PlayerPawn(PawnOther).LightContactRumble();
                    }
                    return true;                    
                }
                else
                {
                    // End:0x4CC
                    if(Info.bDebug)
                    {
                        BroadcastLog((((string(self) @ "Stomp: Target not shrunk or is above SafeHeight (DeltaZ=") $ string(DeltaZ)) @ "Info.SafeHeight=") $ string(Info.SafeHeight));
                    }
                }                
            }
            else
            {
                // End:0x547
                if(Info.bDebug)
                {
                    BroadcastLog((((string(self) @ "Stomp: not close enough to do damage. Dist: ") $ string(Sqrt(DistSq))) $ " StomDamageRadius: ") $ string(Info.StompDamageRadius));
                }
            }            
        }
        else
        {
            // End:0x6B9
            if(deco == none)
            {
                Delta2D = (deco.Location - Info.StompLocation) * Vect(1, 1, 0);
                DistSq = VSizeSquared(Delta2D);
                // End:0x6B9
                if(DistSq < ((Info.StompDamageRadius * Info.StompDamageRadius) * 4))
                {
                    switch(deco.AIStompedInfo.StompType)
                    {
                        // End:0x5ED
                        case 1:
                            deco.CriticalDamage();
                            // End:0x6B6
                            break;
                        // End:0x6B3
                        case 2:
                            Dir = Normal(deco.Location - Location);
                            Impulse = (Normal(Vect(Info.StompDamageVel, 0, Info.StompDamageLift)) * (deco.AIStompedInfo.ImpulseMag + (FRand() * deco.AIStompedInfo.ImpulseMag))) >> Rotator(Dir);
                            deco.SetHealth(Impulse);
                            deco.SkinMeshOptimization(Vect(FVar(0, 1), FVar(0, 1), FVar(0, 1)));
                            // End:0x6B6
                            break;
                        // End:0xFFFF
                        default:
                            break;
                    }                    
                }
            }
        }
        return false;
    }
    return super(Actor).CanHurtRadiusOther(Other);
    return;
}

simulated function PlayFootstepSound(out SSoundInfo FootstepSound, Vector StepLocation)
{
    local float Mag;

    // End:0xAF
    if(((bPlayerShrunkSpecialFootstep && PrimaryTargetActor == none) && PrimaryTargetActor.bIsPlayerPawn) && int(CheckCondition(94)) == int(0))
    {
        // End:0xA2
        if(PrimaryTarget.GetDist2D() < 500)
        {
            Mag = 525 - PrimaryTarget.GetDist2D();
            PlayerShrunkFootstepViewShake.ShakeMagnitude = int(Mag);
            Pawn(PrimaryTargetActor).ShakeView(PlayerShrunkFootstepViewShake, false);
        }
        FindSoundAndSpeak('Sound_PlayerShrunkFootStep');
        return;
    }
    super(Pawn).PlayFootstepSound(FootstepSound, StepLocation);
    return;
}

function bool ActionPointAllowed()
{
    local int i, NumActionPoints;

    NumActionPoints = string(ActionPoints);
    // End:0x19
    if(NumActionPoints <= 0)
    {
        return true;
    }
    i = 0;
    J0x20:

    // End:0x51 [Loop If]
    if(i < NumActionPoints)
    {
        // End:0x47
        if(ActionPoints[i] != ActionPoint)
        {
            return true;
        }
        ++ i;
        // [Loop Continue]
        goto J0x20;
    }
    return false;
    return;
}

event IgnoreDangerActor(Actor A)
{
    IgnoredDangerActors[IgnoredDangerActors.Add(1)] = A;
    return;
}

animevent simulated function DrawPipeBomb(optional EventInfo AnimEventInfo)
{
    local Engine.BaseAI.EAIOp CurOp;

    // End:0x0D
    if(NumPipeBombs == 0)
    {
        return;
    }
    // End:0x1B
    if(MyPipeBomb == none)
    {
        return;
    }
    CurOp = GetCurrentOp();
    // End:0x47
    if((int(CurOp) != int(139)) && int(CurOp) != int(100))
    {
        return;
    }
    MyPipeBomb = EmptyTouchClasses(PipeBombClass, self);
    // End:0x64
    if(MyPipeBomb != none)
    {
        return;
    }
    assert(MyPipeBomb == none);
    MyPipeBomb.SetRotation(0);
    MyPipeBomb.MountType = 2;
    // End:0xC0
    if(AnimEventInfo.EventString == "right")
    {
        MyPipeBomb.MountMeshItem = RightHandPipebombMount;        
    }
    else
    {
        MyPipeBomb.MountMeshItem = LeftHandPipebombMount;
    }
    MyPipeBomb.MoveActor(self);
    MyPipeBomb.SetMass();
    IgnoreDangerActor(MyPipeBomb);
    // End:0x10D
    if(NumPipeBombs > 0)
    {
        -- NumPipeBombs;
    }
    MyPipeBomb.Velocity = Vect(0, 0, 0);
    // End:0x16C
    if((ChanceSayFireInTheHole >= 1) || (ChanceSayFireInTheHole > 0) && FRand() <= ChanceSayFireInTheHole)
    {
        Level.TryBonusCode(self, 1);
    }
    return;
}

event DropMyPipeBomb()
{
    // End:0x71
    if(MyPipeBomb == none)
    {
        MyPipeBomb.TimeWarp = MyPipeBomb.default.TimeWarp;
        MyPipeBomb.GetGravity();
        MyPipeBomb.DoThrow(MyPipeBomb.Velocity + Vect(0, 0, 100));
        MyPipeBomb = none;
    }
    return;
}

animevent simulated function ThrowPipeBomb(optional EventInfo AnimEventInfo)
{
    // End:0xB5
    if(MyPipeBomb == none)
    {
        PipeBombGate = Level.GameTimeSeconds + MinPipeBombInterval;
        MyPipeBomb.TimeWarp = MyPipeBomb.default.TimeWarp;
        MyPipeBomb.GetGravity();
        MyPipeBomb.KLinearDamping = 0;
        // End:0x99
        if(Health <= float(0))
        {
            MyPipeBomb.DoThrow(Vect(0, 0, 0));            
        }
        else
        {
            MyPipeBomb.DoThrow(PipeBombVel);
        }
        MyPipeBomb = none;
    }
    return;
}

animevent simulated function CalcThrowPipeBomb(optional EventInfo AnimEventInfo)
{
    local Vector TargetPos;
    local float Dist, Height;

    // End:0x0E
    if(MyPipeBomb != none)
    {
        return;
    }
    // End:0x44
    if(! PrimaryTarget.IsValidTarget())
    {
        PipeBombVel = Vect(400, 0, 150) >> Rotation;        
    }
    else
    {
        TargetPos = PrimaryTarget.GetPos();
        // End:0x81
        if(PrimaryTargetActor == none)
        {
            TargetPos.Z += PrimaryTargetActor.CollisionHeight;
        }
        Dist = PrimaryTarget.GetDist2D();
        Height = CalcMapRange(Dist, MinHorizDistPipeBomb, MaxHorizDistPipeBomb, MinPipeBombArcHeight * ShrinkScale, MaxPipeBombArcHeight * ShrinkScale);
        // End:0x13A
        if(! CalcProjectileVelocity(MyPipeBomb, MyPipeBomb.default.Physics, PrimaryTargetActor, TargetPos, 10, 10, Height, false, 800, false, 3, 0, true, PipeBombVel, DebugPipeBombs))
        {
            PipeBombVel = Vect(400, 0, 150) >> Rotation;
        }
    }
    ThrowPipeBomb();
    return;
}

event Engine.BaseAI.EAICode COND_ShouldTryAttackPipeBomb()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x0E
    if(NumPipeBombs == 0)
    {
        return 67;
    }
    // End:0x30
    if((Weapon == none) && DualPistol(Weapon) == none)
    {
        return 76;
    }
    // End:0x41
    if(int(AttackConstraint) == int(1))
    {
        return 73;
    }
    // End:0x67
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 4;
    }
    // End:0x83
    if(Level.GameTimeSeconds < PipeBombGate)
    {
        return 60;
    }
    // End:0x9E
    if(int(PrimaryTargetActor.Physics) != int(1))
    {
        return 68;
    }
    Code = FloatInLimits(PrimaryTarget.GetTimeSinceSeen(), MinPipeBombTime, MaxPipeBombTime);
    // End:0xD8
    if(int(Code) != int(0))
    {
        return Code;
    }
    Code = VectorInLimits(PrimaryTarget.GetDisp(), MinHorizDistPipeBomb, MaxHorizDistPipeBomb, MinVertDistPipeBomb, MaxVertDistPipeBomb);
    // End:0x11C
    if(int(Code) != int(0))
    {
        return Code;
    }
    Code = COND_ShouldAttackPipeBomb();
    // End:0x13C
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x167
    if(FRand() > PipeBombChance)
    {
        PipeBombGate = Level.GameTimeSeconds + MinPipeBombInterval;
        return 25;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAttackPipeBomb()
{
    local Engine.BaseAI.EAICode Code;
    local Vector TargetPos;
    local AIActor TargetAI;

    assert(PipeBombClass == none);
    // End:0x32
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 4;
    }
    // End:0x84
    if(PrimaryTarget.IsAnActor())
    {
        TargetAI = AIActor(PrimaryTarget.GetActor());
        // End:0x84
        if((TargetAI == none) && TargetAI.IsFlying())
        {
            return 20;
        }
    }
    TargetPos = PrimaryTarget.GetPos();
    TargetPos.Z -= PrimaryTargetActor.CollisionHeight;
    // End:0xE4
    if(! CalcPipeBombVelocity(PipeBombClass, TargetPos, 80, 3, 0, PipeBombVel, DebugPipeBombs))
    {
        return 27;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldCatchTKObj()
{
    // End:0x0F
    if(TKObj == none)
    {
        return 0;
    }
    return 71;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldThrowTKObj()
{
    local Vector StartPos, EndPos, MuzzleDir, FireDir;
    local Box objectBox;
    local Vector Center;

    // End:0x24
    if((TKObj != none) || TKObj.bDeleteMe)
    {
        return 71;
    }
    // End:0x4A
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 4;
    }
    GetFireParms('None', StartPos, EndPos, MuzzleDir, FireDir, 0, true);
    // End:0x136
    if(! bForceTK)
    {
        TKObj.bAITransparent = true;
        objectBox = AttachToActor();
        Center = objectBox.Min + ((objectBox.Max - objectBox.Min) / 2);
        // End:0x115
        if(! ClearShot(PrimaryTargetActor, Center, PrimaryTarget.GetEyePos(), 3, 0, false))
        {
            TKObj.bAITransparent = TKObj.default.bAITransparent;
            return 27;
        }
        TKObj.bAITransparent = TKObj.default.bAITransparent;
    }
    bForceTK = false;
    TKObjVel = TKObj.TelekinesisThrowVel * Normal(PrimaryTarget.GetEyePos() - TKObj.Location);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldPickupTKObj()
{
    local int i;
    local InteractiveActor IA, BestTKObj;
    local float BestDistance, Dist;

    BestDistance = MaxTKDistance * MaxTKDistance;
    // End:0x21
    if(TKObj == none)
    {
        return 1;
    }
    i = string(Level.TKObjects) - 1;
    J0x3A:

    // End:0x100 [Loop If]
    if(i >= 0)
    {
        IA = Level.TKObjects[i];
        // End:0x85
        if(IA != none)
        {
            Level.TKObjects.Remove(i, 1);
            // [Explicit Continue]
            goto J0xF6;
        }
        // End:0x9B
        if(IA.UnderTelekineticControl)
        {
            // [Explicit Continue]
            goto J0xF6;
        }
        Dist = VSizeSquared(IA.Location - Location);
        // End:0xF6
        if((Dist < (MaxTKDistance * MaxTKDistance)) && ShouldCatchTKObj(IA, true))
        {
            BestDistance = Dist;
            BestTKObj = IA;
        }
        J0xF6:

        -- i;
        // [Loop Continue]
        goto J0x3A;
    }
    // End:0x11A
    if(BestTKObj == none)
    {
        PerformCatchTKObj(BestTKObj);
        return 0;
    }
    return 71;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAvoidDanger()
{
    // End:0x0E
    if(! InDanger)
    {
        return 69;
    }
    // End:0x34
    if((PopUp == none) && ! PopUp.AvoidDanger)
    {
        return 80;
    }
    // End:0x67
    if((GuardInf.IsGuardingActor || GuardInf.IsGuardingPos) && ! GuardInf.AllowAvoidDanger)
    {
        return 80;
    }
    // End:0x73
    if(IsCloaked())
    {
        return 49;
    }
    // End:0x83
    if(! SetGoal(14))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldNotAvoidTarget()
{
    local Pawn pawnTarget;

    // End:0x0C
    if(HasTripMineAttached())
    {
        return 1;
    }
    // End:0x17
    if(! PhysController_SetGroundConstraintDirection())
    {
        return 0;
    }
    pawnTarget = Pawn(PrimaryTargetActor);
    // End:0x36
    if(pawnTarget != none)
    {
        return 0;
    }
    // End:0x4C
    if(pawnTarget.bFullyShrunk)
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAvoidTarget()
{
    local Pawn pawnTarget;
    local AIActor AIActorTarget;

    // End:0x0C
    if(HasTripMineAttached())
    {
        return 0;
    }
    // End:0x17
    if(! PhysController_SetGroundConstraintDirection())
    {
        return 93;
    }
    // End:0x2A
    if(! ShrunkParms.bRunFromBiggerEnemies)
    {
        return 1;
    }
    pawnTarget = Pawn(PrimaryTargetActor);
    // End:0x49
    if(pawnTarget != none)
    {
        return 4;
    }
    // End:0x5F
    if(pawnTarget.bFullyShrunk)
    {
        return 94;
    }
    AIActorTarget = AIActor(PrimaryTargetActor);
    // End:0x9A
    if((AIActorTarget == none) && AIActorTarget.PathID != 'AIPATH_Small')
    {
        return 1;
    }
    // End:0xCD
    if((GuardInf.IsGuardingActor || GuardInf.IsGuardingPos) && ! GuardInf.AllowAvoidDanger)
    {
        return 80;
    }
    // End:0xDD
    if(! SetGoal(13))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_SafeFromBiggerEnemy()
{
    // End:0x37
    if(PrimaryTarget.IsValidTarget() && PrimaryTarget.GetDist2D() > ShrunkParms.MinSafeDistanceFromBigEnemy)
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_NotSafeFromBigEnemy()
{
    // End:0x12
    if(int(COND_SafeFromBiggerEnemy()) == int(0))
    {
        return 1;
    }
    // End:0x22
    if(! SetGoal(13))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoAvoidGoal()
{
    // End:0x10
    if(! SetGoal(13))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_NeedToMoveToAttack()
{
    // End:0x18
    if(! PrimaryTarget.IsValidTarget())
    {
        return 4;
    }
    // End:0x35
    if(PrimaryTarget.GetTimeSinceSeen() > TryGotoAttackTime)
    {
        return 0;
    }
    // End:0x49
    if(int(CheckCondition(61)) == int(0))
    {
        return 61;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoAttack()
{
    local Engine.BaseAI.EAICode Code;

    Code = COND_NeedToMoveToAttack();
    // End:0x20
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x30
    if(! SetGoal(8))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldMoveSide()
{
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldMoveAround()
{
    // End:0x26
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 4;
    }
    // End:0x42
    if(Level.GameTimeSeconds < MoveAroundTime)
    {
        return 60;
    }
    // End:0x52
    if(! SetGoal(15))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoReload()
{
    local Engine.BaseAI.EAICode Code;

    Code = CheckCondition(40);
    // End:0x22
    if(int(Code) != int(0))
    {
        return Code;
    }
    Code = CanReloadWeapon();
    // End:0x42
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x52
    if(! SetGoal(1))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoSafeReload()
{
    local Engine.BaseAI.EAICode Code;

    Code = CheckCondition(40);
    // End:0x22
    if(int(Code) != int(0))
    {
        return Code;
    }
    Code = CanReloadWeapon();
    // End:0x42
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x52
    if(! SetGoal(6))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_BeginWaitState()
{
    MoveAroundTime = (Level.GameTimeSeconds + default.MoveAroundTime) + (FRand() * RndMoveAroundTime);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoGuardAttack()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x11
    if(GuardInf.bStaticGuardHack)
    {
        return 80;
    }
    // End:0x34
    if(! GuardInf.IsGuardingActor || GuardInf.IsGuardingPos)
    {
        return 63;
    }
    // End:0x4B
    if(GuardInf.OuterRange <= MinDistToGoal)
    {
        return 80;
    }
    Code = CheckCondition(81);
    // End:0x6D
    if(int(Code) != int(0))
    {
        return Code;
    }
    Code = COND_NeedToMoveToAttack();
    // End:0x8D
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x9D
    if(! SetGoal(8))
    {
        return 53;
    }
    return 0;
    return;
}

event bool IsTooCloseToGuardedActor(Vector TestLocation)
{
    local Vector Offset;

    Offset = GuardInf.GuardedActor.Location - TestLocation;
    Offset.Z = 0;
    return VSizeSquared(Offset) <= Square(CollisionRadius + (2 * GuardInf.GuardedActor.CollisionRadius));
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoGuardPos()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x11
    if(GuardInf.bStaticGuardHack)
    {
        return 80;
    }
    // End:0x34
    if(! GuardInf.IsGuardingActor || GuardInf.IsGuardingPos)
    {
        return 63;
    }
    Code = CheckCondition(82);
    // End:0xDB
    if(int(Code) != int(0))
    {
        // End:0xD5
        if(((GuardInf.bAvoidGuardedPlayer && GuardInf.IsGuardingActor) && GuardInf.GuardedActor == none) && GuardInf.GuardedActor.bIsPlayerPawn)
        {
            // End:0xD2
            if(! IsTooCloseToGuardedActor(Location))
            {
                // End:0xCC
                if(GuardInf.bAvoidGuardedPlayer && bNeverFailOnDynamicPath)
                {
                    bNeverFailOnDynamicPath = false;
                }
                return Code;
            }            
        }
        else
        {
            return Code;
        }
    }
    // End:0x109
    if((UseActionPoints && PrimaryTarget.IsValidTarget()) && SetGoal(4))
    {
        return 0;
    }
    // End:0x13C
    if(! SetGoal(19))
    {
        // End:0x139
        if(GuardInf.bAvoidGuardedPlayer && ! bNeverFailOnDynamicPath)
        {
            bNeverFailOnDynamicPath = true;
        }
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAlignWithGuardedActor()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x13
    if(! GuardInf.IsGuardingActor)
    {
        return 63;
    }
    // End:0x24
    if(GuardInf.bStaticGuardHack)
    {
        return 80;
    }
    // End:0x37
    if(! GuardInf.AlignWith)
    {
        return 1;
    }
    Code = CheckCondition(79);
    // End:0x59
    if(int(Code) != int(0))
    {
        return Code;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGuardAttackMelee()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x11
    if(GuardInf.bStaticGuardHack)
    {
        return 80;
    }
    // End:0x22
    if(int(AttackConstraint) == int(2))
    {
        return 72;
    }
    // End:0x64
    if((! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none) || PrimaryTarget.GetTimeSinceContact() >= 0.1)
    {
        return 4;
    }
    Code = CheckCondition(22);
    // End:0x86
    if(int(Code) != int(0))
    {
        return Code;
    }
    return CheckCondition(91);
    return;
}

event Engine.BaseAI.EAICode COND_ShouldMelee()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x11
    if(int(AttackConstraint) == int(1))
    {
        return 0;
    }
    // End:0x1F
    if(! WeaponIsActive())
    {
        return 0;
    }
    // End:0x30
    if(int(AttackConstraint) == int(2))
    {
        return 72;
    }
    Code = CheckCondition(20);
    // End:0x52
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x88
    if((Pawn(PrimaryTargetActor) == none) && VehicleSpaceBase(Pawn(PrimaryTargetActor).InteractiveDecoration) == none)
    {
        return 72;
    }
    Code = CheckCondition(91);
    // End:0xBA
    if(int(Code) == int(0))
    {
        // End:0xB7
        if(ActionPoint == none)
        {
            ReleaseActionPoint(false);
        }
        return 0;
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldEndMelee()
{
    // End:0x11
    if(int(AttackConstraint) == int(2))
    {
        return 0;
    }
    // End:0x22
    if(int(AttackConstraint) == int(1))
    {
        return 73;
    }
    // End:0x41
    if(! WeaponIsActive() && PhysController_SetConstraintGroundType(class'Weapon') != none)
    {
        return 29;
    }
    // End:0x55
    if(int(CheckCondition(21)) == int(0))
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldStepAside()
{
    local Engine.BaseAI.EAICode Code;

    // End:0x24
    if(GuardInf.IsGuardingActor && GuardInf.GuardedActor != self)
    {
        return 80;
    }
    // End:0x56
    if(PrimaryTarget.IsValidTarget() && PrimaryTarget.GetTimeSinceSeen() < 3)
    {
        return 3;
    }
    // End:0x64
    if(! DialogGateOpen())
    {
        return 60;
    }
    Code = CheckCondition(84);
    // End:0x86
    if(int(Code) != int(0))
    {
        return Code;
    }
    // End:0x96
    if(! SetGoal(20))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoSearch()
{
    // End:0x18
    if(! PrimaryTarget.IsValidTarget())
    {
        return 4;
    }
    // End:0x35
    if(PrimaryTarget.GetTimeSinceSeen() < 4.5)
    {
        return 60;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldSeek()
{
    // End:0x18
    if(int(CanUseOp(41)) == int(0))
    {
        return COND_ReleaseActionPoint();
    }
    return 1;
    return;
}

simulated function AnimCallback_AttachedToDecoration()
{
    return;
}

function DetachFromUsableSomething()
{
    return;
}

function bool SetUsableSomethingAnimation(name AnimStateName)
{
    return;
}

simulated function HandQuickAction(name ActionName)
{
    return;
}

simulated function HandQuickAction_AnimEnd()
{
    return;
}

event Input(Engine.Actor.EControlRemapperKeyType KeyType, Engine.BaseAI.EAIInputAction ActionType)
{
    return;
}

function AIActor_AnimEnd(int nChannel, name AnimName, int nRefId)
{
    // End:0x2C
    if(MyAnimHUD == none)
    {
        MyAnimHUD.NotifyAnimEnd(self, nChannel, AnimName, nRefId);
    }
    // End:0x41
    if(PainAnimRefID == nRefId)
    {
        EndNonOPPain();
    }
    return;
}

function EndNonOPPain()
{
    AnimCtrl.m_oController.EmptyAnimChannel('Weapon_Ref');
    return;
}

simulated function Vector GetWeaponAim(out Vector StartPos, out Vector Dir)
{
    local Vector EndPos, MuzzleDir;

    // End:0x34
    if(WeaponIsActive())
    {
        GetFireParms('None', StartPos, EndPos, MuzzleDir, Dir, CalcLeadTime(0), false);
    }
    return;
}

event SetMaterial(Actor SwapActor, MaterialEx NewMaterial)
{
    local int iNumMaterials, iSection;

    iNumMaterials = SwapActor.VisibleCollidingActors();
    iSection = 0;
    J0x1A:

    // End:0x4A [Loop If]
    if(iSection < iNumMaterials)
    {
        SwapActor.VisibleActors(iSection, NewMaterial);
        ++ iSection;
        // [Loop Continue]
        goto J0x1A;
    }
    return;
}

function bool NeedsToPiss()
{
    return true;
    return;
}

function float GetSpeedScale(Engine.BaseAI.EAIMoveSpeed Speed)
{
    switch(Speed)
    {
        // End:0x16
        case 0:
            return 0;
            // End:0x40
            break;
        // End:0x24
        case 1:
            return WalkSpeedScale;
            // End:0x40
            break;
        // End:0x32
        case 2:
            return RunSpeedScale;
            // End:0x40
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0x40
            break;
            break;
    }
    return 0;
    return;
}

function bool CanSeeActorFrom(Vector vFrom, Actor aTarget, float fMaxDist, optional bool bDebug)
{
    local bool bCanSeeActor;
    local Actor aHitActor;
    local Vector vDir, vTo;
    local float fHitTime;

    bCanSeeActor = false;
    vDir = Normal(aTarget.SetSlotVisFalloffRate() - vFrom);
    vTo = vFrom + (vDir * fMaxDist);
    CanSeePosFrom(vFrom, vTo, true, aHitActor, fHitTime, bDebug);
    // End:0x95
    if(((aHitActor == none) && aHitActor != aTarget) || fHitTime > 0.99)
    {
        bCanSeeActor = true;
    }
    return bCanSeeActor;
    return;
}

function DrawLine(Vector Start, Vector End, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    GetSlotVolume(Start, End, MyColor, Time);
    return;
}

function DrawArrow(Vector Start, Vector Dir, float Len, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    IsSoundPlayingOnSlot(Start, Dir, MyColor, Len, Time);
    return;
}

function DrawPoint(Vector pos, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    Markers_ClearAll(pos, MyColor, Time);
    return;
}

function DrawCircle(Vector pos, float Radius, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    GetGlobalVolume(pos, Radius, MyColor, Time);
    return;
}

function DrawDiamond(Vector pos, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    GetVisibilityPoint(pos, MyColor, Time);
    return;
}

function DrawCylinder(Vector pos, float Radius, float Height, int R, int G, int B, int A, float Time)
{
    local Color MyColor;
    local Vector mins, maxs;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    GetSoundDuration(pos, Radius, Height, MyColor, Time);
    return;
}

function DrawText(Vector Start, string Text, int R, int G, int B, int A, float Time)
{
    local Color MyColor;

    MyColor.R = byte(R);
    MyColor.G = byte(G);
    MyColor.B = byte(B);
    MyColor.A = byte(A);
    SetSlotVolume(Start, Text, MyColor, Time);
    return;
}

event bool TakePhysicsImpactDamage(float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, Pawn Instigator, KarmaActor DamageActor)
{
    local Vector Helper;
    local STraceHitResult HitResult;

    Helper = 5 * DamageDirection;
    // End:0x8F
    if(HandleInitialMountParent(self, DamageOrigin - Helper, DamageOrigin + Helper, HitResult) && HitResult.Texture == none)
    {
        TraceFireMaterialHit(class'MeleeDamage', Instigator, HitResult.Location, DamageDirection, HitResult.Texture.GetMaterial(), HitResult.Texture.TextSize());
    }
    return super(Pawn).TakePhysicsImpactDamage(Damage, DamageOrigin, DamageDirection, DamageType, Instigator, DamageActor);
    return;
}

event bool ScriptCanHaywire()
{
    // End:0x12
    if(! HaywireParms.bAllowHaywire)
    {
        return false;
    }
    // End:0x29
    if(IsA(DamageInfo.DamageType, class'MeleeDamage'))
    {
        return false;
    }
    return true;
    return;
}

event bool FindGoal_ScriptCustom(out Vector OutGoalPos)
{
    return true;
    return;
}

function ToggleAILog()
{
    // End:0x1A
    if(bUseMyLog)
    {
        DebugExecutive = false;
        EndMyLog();        
    }
    else
    {
        DebugExecutive = true;
        BeginMyLog();
    }
    return;
}

function JumpToGotoXHistory(int i)
{
    BroadcastLog((((("AI [" $ string(self)) $ "] Jumping To GOTOX History ") $ string(i)) @ "GotoX History Length: ") $ string(string(GotoXHistory)));
    // End:0xA6
    if(string(GotoXHistory) > 0)
    {
        GotoXParms = GotoXHistory[0].GotoXParms;
        MoveToward(GotoXHistory[0].Location);
        DisableDesiredRotation_Roll(GotoXHistory[0].Rotation);
        ExecuteState('GotoX');
    }
    return;
}

function CacheGotoXHistory()
{
    local SGotoXHistory Item;

    Item.GotoXParms = GotoXParms;
    Item.Location = Location;
    Item.Rotation = Rotation;
    Item.Timestamp = Level.GameTimeSeconds;
    GotoXHistory.Insert(0, 1);
    GotoXHistory[0] = Item;
    return;
}

event PrioritizePopups(Engine.BaseAI.EAIPopUpType PopupType)
{
    local array<PopUpCfg> Entrys;

    Entrys = Popups[int(PopupType)].Entrys;
    // End:0x25
    if(ActionPoint != none)
    {
        return;
    }
    switch(PopupType)
    {
        // End:0x32
        case 0:
        // End:0x37
        case 1:
        // End:0x3C
        case 2:
        // End:0x41
        case 3:
        // End:0x327
        case 4:
            // End:0xC0
            if(int(AttackConstraint) != int(4))
            {
                SetPopupPriority(Entrys, class'PopUpCfg_Left', 2);
                SetPopupPriority(Entrys, class'PopUpCfg_Right', 2);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchUp', 2);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchRight', 2);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchLeft', 2);                
            }
            else
            {
                SetPopupPriority(Entrys, class'PopUpCfg_Left', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_Right', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchUp', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchRight', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchLeft', 0);
            }
            // End:0x1A4
            if(PipeBombChance == 0)
            {
                SetPopupPriority(Entrys, class'PopUpCfg_LeftPipeBomb', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_RightPipeBomb', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchUpPipeBomb', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchRightPipeBomb', 0);
                SetPopupPriority(Entrys, class'PopUpCfg_CrouchLeftPipeBomb', 0);                
            }
            else
            {
                // End:0x25D
                if(((FRand() < PipeBombChance) || int(AttackConstraint) == int(4)) || PrimaryTarget.IsValidTarget() && PrimaryTarget.GetTimeSinceSeen() > 3)
                {
                    SetPopupPriority(Entrys, class'PopUpCfg_LeftPipeBomb', 10);
                    SetPopupPriority(Entrys, class'PopUpCfg_RightPipeBomb', 10);
                    SetPopupPriority(Entrys, class'PopUpCfg_CrouchUpPipeBomb', 10);
                    SetPopupPriority(Entrys, class'PopUpCfg_CrouchRightPipeBomb', 10);
                    SetPopupPriority(Entrys, class'PopUpCfg_CrouchLeftPipeBomb', 10);                    
                }
                else
                {
                    // End:0x324
                    if(((DamageInfo.Damage > 0) && (Level.GameTimeSeconds - DamageInfo.Time) < 3.5) && BlindFireGate < Level.GameTimeSeconds)
                    {
                        SetPopupPriority(Entrys, class'PopUpCfg_LeftPipeBomb', 8 + FRand());
                        SetPopupPriority(Entrys, class'PopUpCfg_RightPipeBomb', 8 + FRand());
                        SetPopupPriority(Entrys, class'PopUpCfg_CrouchUpPipeBomb', 8);
                        SetPopupPriority(Entrys, class'PopUpCfg_CrouchRightPipeBomb', 8);
                        SetPopupPriority(Entrys, class'PopUpCfg_CrouchLeftPipeBomb', 8);
                    }
                }
            }
            // End:0x32A
            break;
        // End:0xFFFF
        default:
            break;
    }
    return;
}

final function SetPopupPriority(out array<PopUpCfg> Entrys, class<PopUpCfg> ParentClass, float P)
{
    local int i;

    i = string(Entrys) - 1;
    J0x0F:

    // End:0x60 [Loop If]
    if(i >= 0)
    {
        // End:0x56
        if(IsA(ParentClass, Entrys[i].Class))
        {
            Entrys[i].Priority *= P;
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return;
}

final function ResetPopupPriority(out array<PopUpCfg> Entrys, class<PopUpCfg> ParentClass)
{
    local int i;

    i = string(Entrys) - 1;
    J0x0F:

    // End:0x5F [Loop If]
    if(i >= 0)
    {
        // End:0x55
        if(IsA(ParentClass, Entrys[i].Class))
        {
            Entrys[i].Priority = 1;
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return;
}

event bool ShouldDampenWhileTurning()
{
    return false;
    return;
}

event bool DisableCollisionOnStuck()
{
    return false;
    return;
}

event NotifyPhysicsContact(Actor Actor)
{
    // End:0x1C
    if(bTrackPhysicsContacts)
    {
        PhysicsContactActors[PhysicsContactActors.Add(1)] = Actor;
    }
    return;
}

event ExecuteGotoX()
{
    return;
}

event UpdateBodyTarget()
{
    return;
}

event bool ShouldAlwaysBeDynamicallyPathedAround()
{
    local Engine.BaseAI.EAIOp MyOp;

    MyOp = GetCurrentOp();
    // End:0x1C
    if(int(MyOp) == int(100))
    {
        return true;
    }
    return false;
    return;
}

function SquadShareTarget(Actor PrimaryTargetActor)
{
    local AIActor AI;

    // End:0x2E
    if((SquadChannel.ChannelName != 'None') || SquadChannel.ChannelName != 'None')
    {
        return;
    }
    // End:0x10B
    foreach RotateVectorAroundAxis(class'AIActor', AI)
    {
        // End:0x4E
        if(AI != self)
        {
            continue;            
        }
        // End:0x76
        if(NameForString(AI.SquadChannel.ChannelName, SquadChannel.ChannelName))
        {
            continue;            
        }
        // End:0x94
        if(AI.Faction == Faction)
        {
            continue;            
        }
        // End:0xB5
        if(AI.PrimaryTarget.IsValidTarget())
        {
            continue;            
        }
        // End:0xFF
        if((SquadChannel.MaxDistance > float(0)) && VSizeSquared(AI.Location - Location) > (SquadChannel.MaxDistance * SquadChannel.MaxDistance))
        {
            continue;            
        }
        CallForHelp(AI);        
    }    
    return;
}

function bool CheckGlobalGate(name GateName)
{
    return true;
    return;
}

function bool UpdateGlobalGate(name GateName, optional float IntervalOverride)
{
    return true;
    return;
}

function bool CheckAndUpdateGlobalGate(name GateName, optional float IntervalOverride)
{
    return true;
    return;
}

static function class<AIActor> GetSpawnClass(AIActorFactory Factory)
{
    return default.Class;
    return;
}

animevent function ActorDisableIK()
{
    AIDisableIK();
    return;
}

event AIDisableIK()
{
    local int i;

    i = string(AutoRegisterIKClasses) - 1;
    J0x0F:

    // End:0x33 [Loop If]
    if(i >= 0)
    {
        UpdateMatrix(AutoRegisterIKClasses[i], false);
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    AIDisableInventoryIK();
    return;
}

animevent function ActorEnableIK()
{
    AIEnableIK();
    return;
}

event AIEnableIK()
{
    local int i;

    i = string(AutoRegisterIKClasses) - 1;
    J0x0F:

    // End:0x33 [Loop If]
    if(i >= 0)
    {
        UpdateMatrix(AutoRegisterIKClasses[i], true);
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    AIEnableInventoryIK();
    return;
}

event AIDisableInventoryIK()
{
    // End:0x2B
    if(Weapon == none)
    {
        Weapon.AbandonProjector("weapon_ik_detach");
    }
    return;
}

event AIEnableInventoryIK()
{
    // End:0x2B
    if(Weapon == none)
    {
        Weapon.AbandonProjector("weapon_ik_attach");
    }
    return;
}

event NotifyChargeEnd()
{
    return;
}

event CalculateTakeoffVel()
{
    local float Time;
    local Actor HitActor;
    local STraceHitResult Result;
    local STraceFlags Flags;
    local Vector From, To;

    From = Location;
    To = From + Vect(0, 0, TakeOffParms.IdealTakeOffHeight + CollisionHeight);
    Flags.bTraceActors = true;
    Flags.bMeshAccurate = true;
    Flags.bShotTrace = true;
    AllActors(From, To, Flags, Result);
    TakeOffParms.TakeOffVel = TakeOffParms.IdealTakeOffVel;
    TakeOffParms.TakeOffIdleTimeRnd = -1;
    TakeOffParms.TakeOffIdleTime = -1;
    TakeOffParms.TakeOffTarget = From + ((To - From) * Result.Time);
    return;
}

function bool InAir(float HeightThresh)
{
    local Actor HitActor;
    local STraceHitResult Result;
    local STraceFlags Flags;
    local Vector From, To;

    HeightThresh += CollisionHeight;
    From = Location;
    To = From + Vect(0, 0, -1 * HeightThresh);
    Flags.bTraceActors = true;
    Flags.bMeshAccurate = true;
    Flags.bShotTrace = true;
    AllActors(From, To, Flags, Result);
    // End:0x90
    if(Result.Time < 0.99)
    {
        return false;
    }
    return true;
    return;
}

event bool ShouldPainImpulse()
{
    return true;
    return;
}

event NotifyTeleportStart()
{
    local dnFriendFX_Spawners FriendActor;
    local Vector SpawnLocation;

    // End:0x64
    if(TeleportParms.StartLight == none)
    {
        SpawnLocation = Location;
        // End:0x38
        if(! bLowerByCollision)
        {
            SpawnLocation.Z += CollisionHeight;
        }
        TeleportParms.StartLight.SetDesiredRotation(SpawnLocation);
        TeleportParms.StartLight.Flash();
    }
    // End:0xF6
    if(TeleportParms.StartParticleSystem == none)
    {
        FriendActor = FindFriendSpawner(class<dnFriendFX_Spawners>(TeleportParms.StartParticleSystem));
        // End:0xF6
        if(FriendActor == none)
        {
            SpawnLocation = Location;
            // End:0xC1
            if(bLowerByCollision)
            {
                SpawnLocation.Z -= CollisionHeight;
            }
            FriendActor.SetDesiredRotation(SpawnLocation);
            FriendActor.RemoteRole = ROLE_None;
            FriendActor.ExecuteEffect(true);
        }
    }
    return;
}

event StartTeleportOverlayEffects()
{
    local Destructible_Armor Armor;

    // End:0x35
    if(TeleportParms.StartOverlay == none)
    {
        StartTeleportOverlayEffectsOnActor(self);
        // End:0x34
        foreach GetNextIntDesc(class'Destructible_Armor', Armor)
        {
            StartTeleportOverlayEffectsOnActor(Armor);            
        }        
    }
    return;
}

event StartTeleportOverlayEffectsOnActor(Actor A)
{
    A.bDoOverlayEffect = true;
    // End:0x64
    if(bDoOverlayEffect)
    {
        A.OverlayMaterial = TeleportParms.StartOverlay;
        A.OverlayEffectAlpha = 0;
        A.FadeOverlayEffect(1, 3);
    }
    return;
}

event EndTeleportOverlayEffects()
{
    local Destructible_Armor Armor;

    // End:0x35
    if(TeleportParms.StartOverlay == none)
    {
        EndTeleportOverlayEffectsOnActor(self);
        // End:0x34
        foreach GetNextIntDesc(class'Destructible_Armor', Armor)
        {
            EndTeleportOverlayEffectsOnActor(Armor);            
        }        
    }
    return;
}

event EndTeleportOverlayEffectsOnActor(Actor A)
{
    A.bDoOverlayEffect = true;
    // End:0x4A
    if(bDoOverlayEffect)
    {
        A.OverlayEffectAlpha = 1;
        A.FadeOverlayEffect(0, 1);
    }
    return;
}

event ForceEndAllOverlayEffects()
{
    local Destructible_Armor Armor;

    bDoOverlayEffect = false;
    // End:0x2B
    foreach GetNextIntDesc(class'Destructible_Armor', Armor)
    {
        Armor.bDoOverlayEffect = false;        
    }    
    return;
}

event NotifyTeleportLocationSet()
{
    return;
}

event NotifyTeleportEnd()
{
    local dnFriendFX_Spawners FriendActor;
    local Vector SpawnLocation;

    // End:0x64
    if(TeleportParms.EndLight == none)
    {
        SpawnLocation = Location;
        // End:0x38
        if(! bLowerByCollision)
        {
            SpawnLocation.Z += CollisionHeight;
        }
        TeleportParms.EndLight.SetDesiredRotation(SpawnLocation);
        TeleportParms.EndLight.Flash();
    }
    // End:0xF6
    if(TeleportParms.EndParticleSystem == none)
    {
        FriendActor = FindFriendSpawner(class<dnFriendFX_Spawners>(TeleportParms.EndParticleSystem));
        // End:0xF6
        if(FriendActor == none)
        {
            SpawnLocation = Location;
            // End:0xC1
            if(bLowerByCollision)
            {
                SpawnLocation.Z -= CollisionHeight;
            }
            FriendActor.SetDesiredRotation(SpawnLocation);
            FriendActor.RemoteRole = ROLE_None;
            FriendActor.ExecuteEffect(true);
        }
    }
    return;
}

final function bool ShouldSpawnPickupForWeapon()
{
    // End:0x0B
    if(bDisableWeaponDrops)
    {
        return false;
    }
    // End:0x5E
    if((! bAllowWeaponDropsPlayerNotSameSize && ! bIsPlayerPawn) && Level.TickHint() == none)
    {
        // End:0x5E
        if(IsMostlyShrunk() != Level.TickHint().IsMostlyShrunk())
        {
            return false;
        }
    }
    return true;
    return;
}

event SpawnPickupForWeapon(optional Weapon DropWeapon)
{
    // End:0x72
    if((DropWeapon != none) && Weapon != none)
    {
        // End:0x41
        if(SelectWeaponParms.NewWeaponClass == none)
        {
            Weapon = SearchInventoryForWeapon(SelectWeaponParms.NewWeaponClass);
        }
        // End:0x60
        if(Weapon != none)
        {
            Weapon = Weapon(PhysController_SetConstraintGroundType(class'Weapon'));
        }
        Weapon.SetDesiredRotation(Location);
    }
    // End:0x86
    if(ShouldSpawnPickupForWeapon())
    {
        super(Pawn).SpawnPickupForWeapon(DropWeapon);
    }
    return;
}

simulated function bool ShouldCheckUnshrinkClear()
{
    // End:0x0B
    if(IsFlying())
    {
        return false;
    }
    return true;
    return;
}

function dnFriendFX_Spawners AIExecuteFriendSpawnerBone(class<SoftParticleSystem> ParticleClass, name BoneName)
{
    local dnFriendFX_Spawners FriendActor;
    local Vector SpawnLocation;
    local Rotator SpawnRotation;

    SetScaleModifier();
    SpawnLocation = MeshInstance.CreateAnimGroup(BoneName, true, false);
    SpawnRotation = MeshInstance.SwapChannel(BoneName, true);
    GetSlotVolume(SpawnLocation, SpawnLocation + (Vector(SpawnRotation) * 50), NewColorBytes(255, 255, 0), 3);
    return AIExecuteFriendSpawner(ParticleClass, SpawnLocation, SpawnRotation);
    return;
}

function dnFriendFX_Spawners AIExecuteFriendSpawner(class<SoftParticleSystem> ParticleClass, Vector SpawnLocation, Rotator SpawnRotation)
{
    local dnFriendFX_Spawners FriendActor;

    FriendActor = FindFriendSpawner(class<dnFriendFX_Spawners>(ParticleClass));
    // End:0x69
    if(FriendActor == none)
    {
        FriendActor.SetDesiredRotation(SpawnLocation);
        FriendActor.DisableDesiredRotation_Roll(SpawnRotation);
        FriendActor.RemoteRole = ROLE_None;
        FriendActor.ExecuteEffect(true);
    }
    return FriendActor;
    return;
}

function EnableWeaponAimerConstraintOverride(SBoneAimConstraints NewConstraint)
{
    WeaponBoneAimConstraintsOverride = NewConstraint;
    bWeaponBoneAimConstraintsOverrideEnabled = true;
    return;
}

function DisableWeaponAimerConstraintOverride()
{
    bWeaponBoneAimConstraintsOverrideEnabled = false;
    return;
}

event ExecuteRappelEffects()
{
    // End:0x23
    if(RappelParms.MyBeamSystem == none)
    {
        RappelParms.MyBeamSystem.RemoveTouchClass();
    }
    RappelParms.MyBeamSystem = EmptyTouchClasses(RappelParms.BeamSystemClass, self);
    // End:0x4F
    if(RappelParms.MyBeamSystem != none)
    {
        return;
    }
    RappelParms.MyBeamSystem.AddSegmentActor(RappelParms.AttachToActor, self, 0, RappelParms.AttachToBone, RappelParms.BoneName);
    RappelParms.bOverrideAttachToInfo = false;
    return;
}

event DestroyRappelEffects()
{
    // End:0x23
    if(RappelParms.MyBeamSystem == none)
    {
        RappelParms.MyBeamSystem.RemoveTouchClass();
    }
    return;
}

animevent simulated function EndRappel()
{
    DestroyRappelEffects();
    return;
}

animevent function ForceFall()
{
    bWasInAir = true;
    StartFallHeight = Location.Z + (FallDistThresh * 2);
    // End:0x3F
    if(int(CanUseOp(28)) == int(0))
    {
        ExecuteOp(28);
    }
    return;
}

event InitUsableItems()
{
    local int i;

    i = string(UseableItems) - 1;
    J0x0F:

    // End:0x205 [Loop If]
    if(i >= 0)
    {
        // End:0x49
        foreach RotateVectorAroundAxis(class'dnUsableSomething', UseableItems[i].Item, UseableItems[i].ItemTag)
        {
            // End:0x49
            break;            
        }        
        // End:0x79
        foreach RotateVectorAroundAxis(class'AIInputDispatcher_Base', UseableItems[i].InputDispatcher, UseableItems[i].InputDipstacherTag)
        {
            // End:0x79
            break;            
        }        
        // End:0x1FB
        if((UseableItems[i].InputDispatcher != none) || UseableItems[i].Item != none)
        {
            BroadcastLog(("Warning: AI " $ string(self)) @ "has invalid entry in Usable Items!");
            BroadcastLog((((((("UseableItems[" $ string(i)) $ "].ItemTag=") $ string(UseableItems[i].ItemTag)) @ "UseableItems[") $ string(i)) $ "].Item=") $ string(UseableItems[i].Item));
            BroadcastLog((((((("UseableItems[" $ string(i)) $ "].InputDipstacherTag=") $ string(UseableItems[i].InputDipstacherTag)) @ "UseableItems[") $ string(i)) $ "].InputDispatcher=") $ string(UseableItems[i].InputDispatcher));
            // [Explicit Continue]
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return;
}

event Engine.BaseAI.EAICode COND_ShouldUseX()
{
    local Engine.BaseAI.EAICode Code;
    local int i, BestEntranceIndex;
    local dnUsableSomething Item;
    local Vector TargetPos, FacePos;
    local Rotator TargetRot;

    Code = 1;
    // End:0x28
    if((string(UseableItems) <= 0) || PrimaryTargetActor != none)
    {
        return Code;
    }
    i = 0;
    J0x2F:

    // End:0x159 [Loop If]
    if(i < string(UseableItems))
    {
        Item = UseableItems[i].Item;
        BestEntranceIndex = Item.FindBestEntranceIndex(self);
        Code = CanUseState_UseXExplicit(Item, UseableItems[i].InputDispatcher);
        // End:0x14F
        if(int(Code) == int(0))
        {
            Item.GetUsableExitOffsets(self, BestEntranceIndex, true, TargetPos, TargetRot);
            SetGotoPresets(1, none, TargetPos, none, 0, Item.CollisionRadius, 0, 0, CollisionRadius + 60, 3, PrimaryTargetActor, -1, false);
            Code = CanUseOp(67);
            // End:0x14C
            if(int(Code) == int(0))
            {
                FacePos = TargetPos + (Vector(TargetRot) * 100);
                SetTurnToPresets(1, none, FacePos);
                return Code;                
            }
            // [Explicit Continue]
        }
        ++ i;
        // [Loop Continue]
        goto J0x2F;
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoStomp()
{
    // End:0x27
    if((int(CheckCondition(75)) != int(0)) || int(CheckCondition(85)) == int(0))
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoStompLostTarget()
{
    // End:0x14
    if(int(CheckCondition(75)) == int(0))
    {
        return 1;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAbortGotoStomp()
{
    // End:0x12
    if(int(COND_ShouldGotoStomp()) == int(0))
    {
        return 1;
    }
    return 0;
    return;
}

event int GetIdleExIndex()
{
    return 0;
    return;
}

event LogFailedScript()
{
    local SScriptFailInfo FailInfo;
    local int MethodIndex, NumMethods;

    FailInfo.ScriptMethodStr = ScriptPlayer.GetMethodString(ScriptPlayer.GetMethodIndex() - 1);
    FailInfo.AIOP = CurrentOp;
    FailInfo.AIState = IsXbox();
    FailInfo.Timestamp = Level.GameTimeSeconds;
    ScriptFailHistory[ScriptFailHistory.Add(1)] = FailInfo;
    NumMethods = ScriptPlayer.GetNumMethods();
    return;
}

event SetHiddenSelfAndArmor(bool NewHidden)
{
    local Actor A;
    local int i;

    GetZoneLastRenderTime(NewHidden);
    // End:0x42
    foreach GetNextIntDesc(class'Actor', A)
    {
        // End:0x41
        if(! A.default.bHidden)
        {
            A.GetZoneLastRenderTime(NewHidden);
        }        
    }    
    i = 0;
    J0x4A:

    // End:0xCE [Loop If]
    if(i < string(TripMines))
    {
        // End:0xC4
        if(TripMines[i] == none)
        {
            TripMines[i].GetZoneLastRenderTime(NewHidden);
            // End:0xC4
            if(TripMines[i].LaserBeam == none)
            {
                TripMines[i].LaserBeam.GetZoneLastRenderTime(NewHidden);
            }
        }
        ++ i;
        // [Loop Continue]
        goto J0x4A;
    }
    return;
}

simulated function BecomeFrozen()
{
    super(Pawn).BecomeFrozen();
    WeaponManagerHoldFire(true);
    SuspendExecutive(true);
    return;
}

simulated function BecomeUnfrozen()
{
    super(Pawn).BecomeUnfrozen();
    SuspendExecutive(true);
    SuspendExecutive(false);
    switch(CurrentOp)
    {
        // End:0x21
        case 85:
        // End:0x31
        case 86:
            EndOp(3);
            // End:0x34
            break;
        // End:0xFFFF
        default:
            break;
    }
    return;
}

event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector Position, Vector ImpactVelocity, Vector ImpactNormal)
{
    local Vector LinearVelocity;
    local LaserMine_Thrown MIne;

    super(InteractiveActor).KImpact(SelfBoneName, Other, OtherBoneName, Position, ImpactVelocity, ImpactNormal);
    MIne = LaserMine_Thrown(Other);
    // End:0x8F
    if(((IsFrozen()) && VSize(ImpactVelocity) > 450) && MIne != none)
    {
        bInstaGib = true;
        InstaGibRandomImpulse = 10000;
        Die(none, 0, Position, Vect(0, 0, 0));
    }
    // End:0x20F
    if((((ShowPain && ToeStubInfo.bEnabled) && ToeStubInfo.ToeStubGate < Level.GameTimeSeconds) && ! IsMostlyShrunk()) && Other.VehicleCanStubToes())
    {
        // End:0x113
        if((CurrentOpMustFinish && int(CurrentOp) != int(135)) || Other != none)
        {
            return;
        }
        Other.GetConstraintCount(LinearVelocity);
        // End:0x15F
        if(ToeStubInfo.bDebug)
        {
            BroadcastLog("ToeStub Impact Velocity: " $ string(VSize(LinearVelocity)));
        }
        // End:0x20F
        if(VSize(LinearVelocity) >= ToeStubInfo.MinImpactVelocity)
        {
            SetAnimPresets(0, ToeStubInfo.AnimName, false, -1, Other, Vect(0, 0, 0), 0);
            CanUseOp(6);
            CurrentOpMustFinish = false;
            ExecuteOp(6);
            CurrentOpMustFinish = true;
            SuspendExecutive(true);
            SuspendExecutive(false);
            AnimPreset.UseExactAnimName = false;
            ToeStubInfo.ToeStubGate = Level.GameTimeSeconds + ToeStubInfo.MinToeStubInterval;
            NotifyToeStubStart();
        }
    }
    return;
}

function NotifyToeStubStart()
{
    return;
}

simulated function TripMineAttached(Actor TripMineActor, float AutoDetonateTime)
{
    // End:0x9A
    if((! bIgnoreTripMines && (TripMineActor.DrawScale == TripMineActor.default.DrawScale) || PhysController_SetGroundConstraintDirection()) && int(CurrentOp) != int(23))
    {
        TripMines[TripMines.Add(1)] = LaserMine(TripMineActor);
        // End:0x6D
        if(! bAcceptMines)
        {
            return;
        }
        // End:0x9A
        if(int(GetExecutive()) == int(2))
        {
            CurrentOpMustFinish = false;
            EndOp(3);
            SuspendExecutive(true);
            SuspendExecutive(false);
        }
    }
    return;
}

simulated function TripMineExplode(Actor TripMineActor)
{
    local int i;

    super(Actor).TripMineExplode(TripMineActor);
    i = string(TripMines) - 1;
    J0x1A:

    // End:0x51 [Loop If]
    if(i >= 0)
    {
        // End:0x47
        if(TripMines[i] != TripMineActor)
        {
            TripMines.Remove(i, 1);
        }
        -- i;
        // [Loop Continue]
        goto J0x1A;
    }
    return;
}

// Export UAIActor::execHasTripMineAttached(FFrame&, void* const)
native simulated function bool HasTripMineAttached();

event NotifyArmorLoss(Destructible_Armor Armor)
{
    return;
}

animevent simulated function EnableGravity(optional EventInfo AnimEventInfo)
{
    SetAnimSync(0, 0, 0, 2, 0);
    return;
}

event NotifyMultiAnimStart()
{
    return;
}

event NotifyMultiAnimLoop()
{
    return;
}

event NotifyMultiAnimStop()
{
    return;
}

simulated function bool WantsToFire(Weapon W)
{
    return bHackAIWantsToFire;
    return;
}

function bool ImmuneToDamage()
{
    // End:0x26
    if(bExpanding && Level.GameTimeSeconds > ExpandingStartTime)
    {
        return true;
    }
    return super(Pawn).ImmuneToDamage();
    return;
}

event ExpandingDeath(Pawn DeathInstigator)
{
    local int i;

    // End:0xA0
    if(DeathAnimChance > float(0))
    {
        DeathAnimChance = 1;
        bExpanding = true;
        ExpandInstigator = DeathInstigator;
        ExpandingStartTime = Level.GameTimeSeconds;
        i = string(MountedActorList) - 1;
        J0x4E:

        // End:0xA0 [Loop If]
        if(i >= 0)
        {
            // End:0x96
            if(MountedActorList[i].MountedActor.MountMeshItem != ExpandingBoneName)
            {
                MountedActorList[i].MountedActor.RemoveTouchClass();
            }
            -- i;
            // [Loop Continue]
            goto J0x4E;
        }
    }
    return;
}

event bool IsBezerked()
{
    return false;
    return;
}

event bool IsReturningToBerzerk()
{
    return false;
    return;
}

function RefMyClasses()
{
    local Class bodge;

    bodge = class'Aimer';
    bodge = class'Action_PopUp';
    bodge = class'PopUpCfg_WaitLeft';
    bodge = class'PopUpCfg_WaitRight';
    bodge = class'PopUpCfg_WaitBackLeft';
    bodge = class'PopUpCfg_WaitBackRight';
    bodge = class'PopUpCfg_Left';
    bodge = class'PopUpCfg_LeftPeek';
    bodge = class'PopUpCfg_LeftBlindFire';
    bodge = class'PopUpCfg_LeftPipeBomb';
    bodge = class'PopUpCfg_BackLeft';
    bodge = class'PopUpCfg_BackLeftPeek';
    bodge = class'PopUpCfg_BackLeftBlindFire';
    bodge = class'PopUpCfg_BackLeftPipeBomb';
    bodge = class'PopUpCfg_Right';
    bodge = class'PopUpCfg_RightPeek';
    bodge = class'PopUpCfg_RightBlindFire';
    bodge = class'PopUpCfg_RightPipeBomb';
    bodge = class'PopUpCfg_BackRight';
    bodge = class'PopUpCfg_BackRightPeek';
    bodge = class'PopUpCfg_BackRightBlindFire';
    bodge = class'PopUpCfg_BackRightPipeBomb';
    bodge = class'PopUpCfg_CrouchUp';
    bodge = class'PopUpCfg_CrouchUpPeek';
    bodge = class'PopUpCfg_CrouchUpBlindFire';
    bodge = class'PopUpCfg_CrouchUpPipeBomb';
    bodge = class'PopUpCfg_CrouchBackUp';
    bodge = class'PopUpCfg_CrouchBackUpPeek';
    bodge = class'PopUpCfg_CrouchBackUpBlindFire';
    bodge = class'PopUpCfg_CrouchBackUpPipeBomb';
    bodge = class'PopUpCfg_CrouchLeft';
    bodge = class'PopUpCfg_CrouchLeftPeek';
    bodge = class'PopUpCfg_CrouchLeftBlindFire';
    bodge = class'PopUpCfg_CrouchLeftPipeBomb';
    bodge = class'PopUpCfg_CrouchBackLeft';
    bodge = class'PopUpCfg_CrouchBackLeftPeek';
    bodge = class'PopUpCfg_CrouchBackLeftBlindFire';
    bodge = class'PopUpCfg_CrouchBackLeftPipeBomb';
    bodge = class'PopUpCfg_CrouchRight';
    bodge = class'PopUpCfg_CrouchRightPeek';
    bodge = class'PopUpCfg_CrouchRightBlindFire';
    bodge = class'PopUpCfg_CrouchRightPipeBomb';
    bodge = class'PopUpCfg_CrouchBackRight';
    bodge = class'PopUpCfg_CrouchBackRightPeek';
    bodge = class'PopUpCfg_CrouchBackRightBlindFire';
    bodge = class'PopUpCfg_CrouchBackRightPipeBomb';
    bodge = class'PopUpCfg_CrouchWaitLeft';
    bodge = class'PopUpCfg_CrouchWaitRight';
    bodge = class'PopUpCfg_CrouchWaitBackLeft';
    bodge = class'PopUpCfg_CrouchWaitBackRight';
    bodge = class'PopUpCfg_StandFire';
    bodge = class'PopUpCfg_CrouchFire';
    bodge = class'PopUpCfg_ProneFire';
    bodge = class'PopUpCfg_Vault';
    bodge = class'ScriptObj';
    bodge = class'ScriptTrigger_Roam';
    bodge = class'ScriptMethod_AbortScript';
    bodge = class'ScriptMethod_AlignWithActor';
    bodge = class'ScriptMethod_Bezerk';
    bodge = class'ScriptMethod_Blink';
    bodge = class'ScriptMethod_ClearGuard';
    bodge = class'ScriptMethod_Crouch';
    bodge = class'ScriptMethod_Destroy';
    bodge = class'ScriptMethod_Fall';
    bodge = class'ScriptMethod_FreeMove';
    bodge = class'ScriptMethod_ForceFire';
    bodge = class'ScriptMethod_GotoActor';
    bodge = class'ScriptMethod_GotoActorsPos';
    bodge = class'ScriptMethod_GotoAndHurl';
    bodge = class'ScriptMethod_GotoAndPickup';
    bodge = class'ScriptMethod_GotoAndPlaceTripMine';
    bodge = class'ScriptMethod_GotoAndUseItem';
    bodge = class'ScriptMethod_GotoPos';
    bodge = class'ScriptMethod_GuardActor';
    bodge = class'ScriptMethod_GuardPos';
    bodge = class'ScriptMethod_HealthChange';
    bodge = class'ScriptMethod_HoldFire';
    bodge = class'ScriptMethod_Hurl';
    bodge = class'ScriptMethod_IK';
    bodge = class'ScriptMethod_Idle';
    bodge = class'ScriptMethod_Jump';
    bodge = class'ScriptMethod_JumpToActorsPos';
    bodge = class'ScriptMethod_Land';
    bodge = class'ScriptMethod_Melee';
    bodge = class'ScriptMethod_OverrideAnim';
    bodge = class'ScriptMethod_OverrideAnim_Clear';
    bodge = class'ScriptMethod_Pause';
    bodge = class'ScriptMethod_Pickup';
    bodge = class'ScriptMethod_PlaceTripMine';
    bodge = class'ScriptMethod_PlayAmbientSound';
    bodge = class'ScriptMethod_PlayAnim';
    bodge = class'ScriptMethod_PlayExplicitAnim';
    bodge = class'ScriptMethod_PlayScript';
    bodge = class'ScriptMethod_PlaySound';
    bodge = class'ScriptMethod_PlayTransientAnim';
    bodge = class'ScriptMethod_PlayTransientExplicitAnim';
    bodge = class'ScriptMethod_PopUp';
    bodge = class'ScriptMethod_PopUpExplicit';
    bodge = class'ScriptMethod_Print';
    bodge = class'ScriptMethod_Prone';
    bodge = class'ScriptMethod_ResumeFire';
    bodge = class'ScriptMethod_SelectWeapon';
    bodge = class'ScriptMethod_SetAbortable';
    bodge = class'ScriptMethod_SetActionPointTags';
    bodge = class'ScriptMethod_SetActionPointIndex';
    bodge = class'ScriptMethod_SetAttackConstraint';
    bodge = class'ScriptMethod_SetBodyTarget';
    bodge = class'ScriptMethod_SetCollision';
    bodge = class'ScriptMethod_SetDamageReactions';
    bodge = class'ScriptMethod_SetDeathAnim';
    bodge = class'ScriptMethod_SetEnemyMustBeSighted';
    bodge = class'ScriptMethod_SetEvent';
    bodge = class'ScriptMethod_SetEyeTarget';
    bodge = class'ScriptMethod_SetFaction';
    bodge = class'ScriptMethod_SetFactoryActionPointIndex';
    bodge = class'ScriptMethod_SetFactoryActionPointTags';
    bodge = class'ScriptMethod_SetHeadTarget';
    bodge = class'ScriptMethod_SetJetPackWobble';
    bodge = class'ScriptMethod_SetLookTarget';
    bodge = class'ScriptMethod_SetSoundState';
    bodge = class'ScriptMethod_SetScriptTag';
    bodge = class'ScriptMethod_SetTarget';
    bodge = class'ScriptMethod_SetUsedScriptTag';
    bodge = class'ScriptMethod_SpawnAttachment';
    bodge = class'ScriptMethod_Speak';
    bodge = class'ScriptMethod_StandCombat';
    bodge = class'ScriptMethod_StandPassive';
    bodge = class'ScriptMethod_SuspendLookTargetEval';
    bodge = class'ScriptMethod_SuspendWeaponTargetEval';
    bodge = class'ScriptMethod_TakeOff';
    bodge = class'ScriptMethod_TeleportToActor';
    bodge = class'ScriptMethod_TeleportToPos';
    bodge = class'ScriptMethod_Throw';
    bodge = class'ScriptMethod_ThrowPipeBomb';
    bodge = class'ScriptMethod_TKCatch';
    bodge = class'ScriptMethod_TKThrow';
    bodge = class'ScriptMethod_Trigger';
    bodge = class'ScriptMethod_TurnToActor';
    bodge = class'ScriptMethod_TurnToPos';
    bodge = class'ScriptMethod_UseItem';
    bodge = class'ScriptMethod_X_TEST_Op';
    bodge = class'ScriptMethod_DropProp';
    return;
}

animevent simulated function leftfootstick(optional EventInfo AnimEventInfo)
{
    return;
}

animevent simulated function leftunstick(optional EventInfo AnimEventInfo)
{
    return;
}

animevent simulated function rightfootstick(optional EventInfo AnimEventInfo)
{
    return;
}

animevent simulated function rightunstick(optional EventInfo AnimEventInfo)
{
    return;
}

function InitializeActionPoints()
{
    local ActionPoint ap;

    // End:0xCA01
    foreach RotateVectorAroundAxis(class'ActionPoint', ap)
    {
        new (ReloadActionPoints[ReloadActionPoints.Add(1)] = ap) return;
        @NULL
    }
}

event Engine.BaseAI.EAICode COND_ForcedActionPoints()
{
    // End:0x0E
    if(! UseActionPoints)
    {
        return 96;
    }
    // End:0x28
    if((string(ActionPoints) > 0) && HasUseableActionPoint())
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_NoForcedActionPoints()
{
    // End:0x29
    if((! UseActionPoints || string(ActionPoints) <= 0) || ! HasUseableActionPoint())
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldUseActionPoint()
{
    local bool Secondary;

    // End:0x0E
    if(! UseActionPoints)
    {
        return 96;
    }
    // End:0x1D
    if(ActionPoint != none)
    {
        return 97;
    }
    // End:0x36
    if(ActionPoint.User == self)
    {
        return 97;
    }
    Secondary = ActionPointIndex < ActionPointDesiredIndex;
    // End:0x70
    if(! CanUseActionPoint(Secondary) || ! GetActionPointAction(Secondary))
    {
        return 101;
    }
    // End:0x7E
    if(! AtActionPoint())
    {
        return 99;
    }
    // End:0x92
    if(! UseActionPoint(Secondary))
    {
        return 100;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoActionPoint()
{
    local bool Secondary;
    local Vector NextPathPos;
    local int FinalDest;
    local Engine.BaseAI.EAICode Code;

    // End:0x0E
    if(! UseActionPoints)
    {
        return 96;
    }
    // End:0x24
    if(int(AnimCtrl.m_eController) == int(3))
    {
        return 34;
    }
    // End:0x3A
    if(int(AnimCtrl.m_eController) == int(8))
    {
        return 51;
    }
    // End:0x4E
    if(int(CheckCondition(20)) == int(0))
    {
        return 18;
    }
    // End:0x5F
    if(! SetGoal(4, true))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoActionPointFlyer()
{
    // End:0x0E
    if(! UseActionPoints)
    {
        return 96;
    }
    // End:0x1F
    if(! SetGoal(3, true))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldMeleeActionPoint()
{
    local Engine.BaseAI.EAICode Code;

    ActionPointMeleeK = default.ActionPointMeleeK;
    // End:0x4D
    if((! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none) || PrimaryTarget.GetTimeSinceContact() >= 0.1)
    {
        return 4;
    }
    return COND_ShouldMelee();
    return;
}

event OverridePopoutHoldTime(out float HoldTime)
{
    return;
}

event ActionPoint ChooseBestNeighborAP(out array<SActionPointNeighborInfo> APNInfoList, optional bool bCheckCompromised, optional float MinDotToAp, optional bool NoClearPathRequired, optional bool NoClearPathAllowed, optional bool GetJumpInfo, optional out SJumpPreset JumpPreset)
{
    local ActionPoint ap;
    local int i;
    local float NewGravityScale;

    i = string(APNInfoList) - 1;
    J0x0F:

    // End:0x167 [Loop If]
    if(i >= 0)
    {
        ap = APNInfoList[i].ActionPoint;
        // End:0x4B
        if(ap != none)
        {
            APNInfoList.Remove(i, 1);
            // [Explicit Continue]
            goto J0x15D;
        }
        // End:0x88
        if(((ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x15D;
        }
        // End:0xB6
        if((MinDotToAp != 0) && MinDotToAp > APNInfoList[i].DotToAP)
        {
            // [Explicit Continue]
            goto J0x15D;
        }
        // End:0xDC
        if(! NoClearPathRequired && APNInfoList[i].MaxPathID < 0)
        {
            // [Explicit Continue]
            goto J0x15D;
        }
        // End:0x15D
        if(CanUseNewActionPoint(ap, false))
        {
            // End:0x12F
            if(bCheckCompromised && PrimaryTarget.IsValidTarget())
            {
                // End:0x12F
                if(ap.IsCompletelyCompromised(PrimaryTarget.GetPos()))
                {
                    // [Explicit Continue]
                    goto J0x15D;
                }
            }
            // End:0x157
            if(GetJumpInfo && ! GetAPJumpInfo(APNInfoList[i], JumpPreset))
            {
                return none;
            }
            return ap;
        }
        J0x15D:

        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return none;
    return;
}

event ActionPoint ChooseBestAPClosestTarget()
{
    local ActionPoint ap;
    local int i;
    local float NewGravityScale, BestDist, Dist;
    local ActionPoint BestAP;
    local array<SActionPointNeighborInfo> APNInfoList;

    APNInfoList = ActionPoint.WalkToActionPoints;
    i = 0;
    J0x1C:

    // End:0x63 [Loop If]
    if(i < string(ActionPoint.AdvanceActionPoints))
    {
        APNInfoList[APNInfoList.Add(1)] = ActionPoint.AdvanceActionPoints[i];
        ++ i;
        // [Loop Continue]
        goto J0x1C;
    }
    BestDist = 1E+10;
    i = string(APNInfoList) - 1;
    J0x7D:

    // End:0x176 [Loop If]
    if(i >= 0)
    {
        ap = APNInfoList[i].ActionPoint;
        // End:0xB9
        if(ap != none)
        {
            APNInfoList.Remove(i, 1);
            // [Explicit Continue]
            goto J0x16C;
        }
        // End:0xF6
        if(((ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x16C;
        }
        // End:0x10F
        if(APNInfoList[i].MaxPathID < 0)
        {
            // [Explicit Continue]
            goto J0x16C;
        }
        // End:0x16C
        if(CanUseNewActionPoint(ap, false))
        {
            Dist = VSize(PrimaryTarget.GetPos() - ap.Location);
            // End:0x16C
            if(Dist < BestDist)
            {
                BestAP = ap;
                BestDist = Dist;
            }
        }
        J0x16C:

        -- i;
        // [Loop Continue]
        goto J0x7D;
    }
    return BestAP;
    return;
}

event Engine.BaseAI.EAICode COND_AvailableActionPoint()
{
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldAdvanceAP()
{
    local ActionPoint NewActionPoint;

    // End:0x0F
    if(ActionPoint != none)
    {
        return 1;
    }
    NewActionPoint = ChooseBestNeighborAP(ActionPoint.AdvanceActionPoints, true);
    // End:0x3A
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldRetreatAP()
{
    local ActionPoint NewActionPoint;

    // End:0x0F
    if(ActionPoint != none)
    {
        return 1;
    }
    NewActionPoint = ChooseBestNeighborAP(ActionPoint.RetreatActionPoints);
    // End:0x39
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldFlankAP()
{
    local ActionPoint NewActionPoint;

    // End:0x0F
    if(ActionPoint != none)
    {
        return 1;
    }
    NewActionPoint = ChooseBestNeighborAP(ActionPoint.FlankActionPoints, true);
    // End:0x3A
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldLateralAP()
{
    local ActionPoint NewActionPoint;

    // End:0x0F
    if(ActionPoint != none)
    {
        return 1;
    }
    NewActionPoint = ChooseBestNeighborAP(ActionPoint.LateralActionPoints);
    // End:0x39
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ActionPointCompletelyCompromised()
{
    local float DotApToTarget;

    // End:0x0F
    if(ActionPoint != none)
    {
        return 0;
    }
    // End:0x27
    if(! PrimaryTarget.IsValidTarget())
    {
        return 4;
    }
    // End:0x54
    if(ActionPoint.IsCompletelyCompromised(PrimaryTarget.GetPos()))
    {
        ReleaseActionPoint(false);
        return 0;
    }
    // End:0x9A
    if((ActionPoint.ShrunkActionPoint && ! PhysController_SetGroundConstraintDirection()) || ! ActionPoint.ShrunkActionPoint && PhysController_SetGroundConstraintDirection())
    {
        ReleaseActionPoint(false);
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ReleaseActionPoint()
{
    // End:0x13
    if(ActionPoint == none)
    {
        ReleaseActionPoint(false);
    }
    ActionPoint = none;
    PopUp = none;
    // End:0x3D
    if(NextActionPoint == none)
    {
        NextActionPoint.UnlockActionPoint();
    }
    // End:0x63
    if(TeleportParms.EndActionPoint == none)
    {
        TeleportParms.EndActionPoint.UnlockActionPoint();
    }
    TeleportParms.EndActionPoint = none;
    NextActionPoint = none;
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldVaultAP()
{
    // End:0x3D
    if(((ActionPoint != none) || ! ActionPoint.bCanVault) || string(Popups[int(17)].Entrys) <= 0)
    {
        return 4;
    }
    NextActionPoint = ChooseBestNeighborAP(ActionPoint.AdvanceActionPoints, true, 0.75);
    // End:0x8B
    if(NextActionPoint != none)
    {
        NextActionPoint = ChooseBestNeighborAP(ActionPoint.VaultToActionPoints, true, 0.75);
    }
    // End:0x9A
    if(NextActionPoint != none)
    {
        return 1;
    }
    NextActionPoint.LockActionPoint(self);
    PopUp = Popups[int(17)].Entrys[0];
    PopUpState.DamageTaken = 0;
    PopUpState.ShotsFired = 0;
    return 0;
    return;
}

function bool EvalNextJumpAP(out SActionPointNeighborInfo APInfo, float BestDistance, bool NoClearPathAllowed)
{
    local ActionPoint ap;
    local float Dist;

    ap = APInfo.ActionPoint;
    // End:0x5A
    if((((ap != none) || ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
    {
        return false;
    }
    // End:0x77
    if(NoClearPathAllowed && APInfo.MaxPathID >= 0)
    {
        return false;
    }
    Dist = VSize(PrimaryTarget.GetPos() - ap.Location);
    // End:0xB1
    if(Dist > BestDistance)
    {
        return false;
    }
    // End:0xC2
    if(CanUseNewActionPoint(ap, false))
    {
        return true;
    }
    return false;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoJumpAP()
{
    // End:0x11
    if(! SetGoal(5, true))
    {
        return 53;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldJumpToNextAPNoTarget()
{
    local ActionPoint NewActionPoint;
    local Vector NewJumpVel;
    local float NewGravityScale, JumpTime;

    // End:0x26
    if((ActionPoint != none) || ! ActionPoint.bJumpPoint)
    {
        return 4;
    }
    // End:0x88
    if(NewActionPoint != none)
    {
        NewActionPoint = ChooseBestNeighborAP(ActionPoint.AdvanceActionPoints,,, true, true, true, JumpPreset);
        // End:0x88
        if(NewActionPoint != none)
        {
            NewActionPoint = ChooseBestNeighborAP(ActionPoint.RetreatActionPoints,,, true, true, true, JumpPreset);
        }
    }
    // End:0x97
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    SetTurnToPresets(2, NewActionPoint);
    return 0;
    return;
}

function bool GetAPJumpInfo(out SActionPointNeighborInfo APInfo, out SJumpPreset JumpPreset)
{
    local int i;

    i = 0;
    J0x07:

    // End:0x63 [Loop If]
    if(i < string(APInfo.JumpToInfo))
    {
        // End:0x59
        if(APInfo.JumpToInfo[i].JumpType != ActionPointJumpType)
        {
            JumpPreset = APInfo.JumpToInfo[i].JumpPreset;
            return true;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return false;
    return;
}

function bool GetDefaultJumpInfo(ActionPoint ap, out SJumpPreset JumpPreset)
{
    // End:0x1F
    if(GetDefaultJumpInfoHelper(ap.AdvanceActionPoints, JumpPreset))
    {
        return true;
    }
    // End:0x3E
    if(GetDefaultJumpInfoHelper(ap.RetreatActionPoints, JumpPreset))
    {
        return true;
    }
    // End:0x5D
    if(GetDefaultJumpInfoHelper(ap.LateralActionPoints, JumpPreset))
    {
        return true;
    }
    return false;
    return;
}

function bool GetDefaultJumpInfoHelper(out array<SActionPointNeighborInfo> Neighbors, out SJumpPreset JumpPreset)
{
    local int i;

    i = string(Neighbors) - 1;
    J0x0F:

    // End:0x3F [Loop If]
    if(i >= 0)
    {
        // End:0x35
        if(GetAPJumpInfo(Neighbors[i], JumpPreset))
        {
            return true;
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return false;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldJumpToNextAP()
{
    local int i, j;
    local float BestDistToTarget, OutTime;
    local ActionPoint NewActionPoint;
    local SActionPointNeighborInfo NewAPInfo;
    local Vector temp;
    local bool NoClearPathAllowed;

    // End:0x3D
    if((! PrimaryTarget.IsValidTarget() || ActionPoint != none) || ! ActionPoint.bJumpPoint)
    {
        return 4;
    }
    // End:0x5A
    if(! ActionPoint.bFlyer)
    {
        NoClearPathAllowed = true;
    }
    BestDistToTarget = VSize(PrimaryTarget.GetPos() - Location);
    i = string(ActionPoint.AdvanceActionPoints) - 1;
    j = string(ActionPoint.RetreatActionPoints) - 1;
    J0xAB:

    // End:0x1D3 [Loop If]
    if((i >= 0) || j >= 0)
    {
        // End:0x144
        if(((i >= 0) && EvalNextJumpAP(ActionPoint.AdvanceActionPoints[i], BestDistToTarget, NoClearPathAllowed)) && GetAPJumpInfo(ActionPoint.AdvanceActionPoints[i], JumpPreset))
        {
            NewActionPoint = ActionPoint.AdvanceActionPoints[i].ActionPoint;
            // [Explicit Break]
            goto J0x1D3;            
        }
        else
        {
            // End:0x1C2
            if(((j >= 0) && EvalNextJumpAP(ActionPoint.RetreatActionPoints[j], BestDistToTarget, NoClearPathAllowed)) && GetAPJumpInfo(ActionPoint.RetreatActionPoints[j], JumpPreset))
            {
                NewActionPoint = ActionPoint.RetreatActionPoints[j].ActionPoint;
                // [Explicit Break]
                goto J0x1D3;
            }
        }
        -- i;
        -- j;
        // [Loop Continue]
        goto J0xAB;
    }
    J0x1D3:

    // End:0x2C5
    if(NewActionPoint != none)
    {
        // End:0x265
        if(ActionPoint.IsCompletelyCompromised(PrimaryTarget.GetPos()))
        {
            NewActionPoint = ChooseBestNeighborAP(ActionPoint.RetreatActionPoints,,, true, NoClearPathAllowed, true, JumpPreset);
            // End:0x262
            if(NewActionPoint != none)
            {
                NewActionPoint = ChooseBestNeighborAP(ActionPoint.AdvanceActionPoints,,, true, NoClearPathAllowed, true, JumpPreset);
            }            
        }
        else
        {
            NewActionPoint = ChooseBestNeighborAP(ActionPoint.AdvanceActionPoints,,, true, NoClearPathAllowed, true, JumpPreset);
            // End:0x2C5
            if(NewActionPoint != none)
            {
                NewActionPoint = ChooseBestNeighborAP(ActionPoint.RetreatActionPoints,,, true, NoClearPathAllowed, true, JumpPreset);
            }
        }
    }
    // End:0x2D4
    if(NewActionPoint != none)
    {
        return 1;
    }
    // End:0x379
    if(! ActorInRange(ActionPoint, CollisionRadius, CollisionHeight / 2))
    {
        GravityScale = 1;
        // End:0x379
        if(GetDefaultJumpInfo(ActionPoint, JumpPreset))
        {
            CalcJumpVelocity(NewActionPoint.Location, 100, JumpPreset.JumpVel, false, JumpPreset.GravityScale, JumpPreset.JumpTime);
            JumpPreset.TargetPos = NewActionPoint.Location;
            JumpPreset.JumpTime = -1;            
        }
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldFlyToNextAP()
{
    local int i;
    local float BestDistToTarget, Dist, OutTime;
    local ActionPoint NewActionPoint, ap, BackupAP;
    local SActionPointNeighborInfo NewAPInfo;

    // End:0x3D
    if((! PrimaryTarget.IsValidTarget() || ActionPoint != none) || ! ActionPoint.bFlyer)
    {
        return 4;
    }
    BestDistToTarget = VSizeSquared(PrimaryTarget.GetPos() - Location);
    i = string(ActionPoint.WalkToActionPoints) - 1;
    J0x75:

    // End:0x197 [Loop If]
    if(i >= 0)
    {
        ap = ActionPoint.WalkToActionPoints[i].ActionPoint;
        // End:0xEB
        if((((ap != none) || ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x18D;
        }
        // End:0x125
        if(! ClearShot(PrimaryTargetActor, ap.Location, PrimaryTarget.GetAimPos(), 3, 0, false))
        {
            // [Explicit Continue]
            goto J0x18D;
        }
        // End:0x13C
        if(BackupAP != none)
        {
            BackupAP = ap;
        }
        Dist = VSizeSquared(PrimaryTarget.GetPos() - ap.Location);
        // End:0x18D
        if(Dist < BestDistToTarget)
        {
            BestDistToTarget = Dist;
            NewActionPoint = ap;
            // [Explicit Break]
            goto J0x197;
        }
        J0x18D:

        -- i;
        // [Loop Continue]
        goto J0x75;
    }
    J0x197:

    // End:0x1AE
    if(NewActionPoint != none)
    {
        NewActionPoint = BackupAP;
    }
    // End:0x1C8
    if(NewActionPoint == none)
    {
        SetNewActionPoint(NewActionPoint);
        return 0;
    }
    return 53;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoToNextAPCheckLOS()
{
    local int i;
    local float BestDistToTarget, Dist, OutTime;
    local ActionPoint NewActionPoint, ap, BackupAP;
    local SActionPointNeighborInfo NewAPInfo;

    // End:0x26
    if(! PrimaryTarget.IsValidTarget() || ActionPoint != none)
    {
        return 4;
    }
    BestDistToTarget = VSizeSquared(PrimaryTarget.GetPos() - Location);
    i = string(ActionPoint.WalkToActionPoints) - 1;
    J0x5E:

    // End:0x180 [Loop If]
    if(i >= 0)
    {
        ap = ActionPoint.WalkToActionPoints[i].ActionPoint;
        // End:0xD4
        if((((ap != none) || ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x176;
        }
        // End:0x10E
        if(! ClearShot(PrimaryTargetActor, ap.Location, PrimaryTarget.GetAimPos(), 3, 0, false))
        {
            // [Explicit Continue]
            goto J0x176;
        }
        // End:0x125
        if(BackupAP != none)
        {
            BackupAP = ap;
        }
        Dist = VSizeSquared(PrimaryTarget.GetPos() - ap.Location);
        // End:0x176
        if(Dist < BestDistToTarget)
        {
            BestDistToTarget = Dist;
            NewActionPoint = ap;
            // [Explicit Break]
            goto J0x180;
        }
        J0x176:

        -- i;
        // [Loop Continue]
        goto J0x5E;
    }
    J0x180:

    // End:0x197
    if(NewActionPoint != none)
    {
        NewActionPoint = BackupAP;
    }
    // End:0x1B1
    if(NewActionPoint == none)
    {
        SetNewActionPoint(NewActionPoint);
        return 0;
    }
    return 53;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldWalkToNextAP()
{
    local ActionPoint NewActionPoint;

    // End:0x3E
    if(((ActionPoint != none) || ! ActionPoint.bJumpPoint) || string(ActionPoint.WalkToActionPoints) <= 0)
    {
        return 4;
    }
    NewActionPoint = ChooseBestNeighborAP(ActionPoint.WalkToActionPoints);
    // End:0x68
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldWalkToNextAPClosestTarget()
{
    local ActionPoint NewActionPoint;

    // End:0x7B
    if(((((PrimaryTarget != none) || ! PrimaryTarget.IsValidTarget()) || ActionPoint != none) || ! ActionPoint.bJumpPoint) || (string(ActionPoint.WalkToActionPoints) <= 0) && string(ActionPoint.AdvanceActionPoints) <= 0)
    {
        return 4;
    }
    NewActionPoint = ChooseBestAPClosestTarget();
    // End:0x96
    if(NewActionPoint != none)
    {
        return 1;
    }
    SetNewActionPoint(NewActionPoint);
    return 0;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldJumpToFlyAP()
{
    local ActionPoint_Flyer ap, BestAP;
    local float BestDistSq, DistSq;

    BestDistSq = 3000 * 3000;
    // End:0x8F
    foreach RotateVectorAroundAxis(class'ActionPoint_Flyer', ap)
    {
        // End:0x4B
        if((ap != ActionPoint) || ap.bLocked)
        {
            continue;            
        }
        DistSq = VSizeSquared(ap.Location - Location);
        // End:0x8E
        if(BestDistSq > DistSq)
        {
            BestDistSq = DistSq;
            BestAP = ap;
        }        
    }    
    // End:0xF3
    if(BestAP == none)
    {
        SetNewActionPoint(BestAP);
        CalcJumpVelocity(BestAP.Location, 150, TakeOffParms.TakeOffVel, true, TakeOffParms.GravityScale, TakeOffParms.TakeOffIdleTime);
        TakeOffParms.TakeOffIdleTimeRnd = 0;
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldGotoJumpOrNormalAP()
{
    // End:0x14
    if(int(CheckCondition(56)) == int(0))
    {
        return 51;
    }
    // End:0x26
    if(int(COND_ShouldGotoJumpAP()) == int(0))
    {
        return 0;
    }
    // End:0x38
    if(int(COND_ShouldGotoActionPoint()) == int(0))
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_HasJumpAP()
{
    // End:0x24
    if((ActionPoint == none) && ActionPoint.bJumpPoint)
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_HasNormalAP()
{
    // End:0x0F
    if(ActionPoint == none)
    {
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldJumpToAirAP()
{
    local int i;
    local ActionPoint NewActionPoint, ap;
    local SActionPointNeighborInfo APInfo;

    // End:0x55
    if(((! PrimaryTarget.IsValidTarget() || ActionPoint != none) || ! ActionPoint.bJumpPoint) || string(ActionPoint.FlyToActionPoints) <= 0)
    {
        return 4;
    }
    i = string(ActionPoint.FlyToActionPoints) - 1;
    J0x6E:

    // End:0x13F [Loop If]
    if(i >= 0)
    {
        APInfo = ActionPoint.FlyToActionPoints[i];
        ap = APInfo.ActionPoint;
        // End:0x107
        if((((ap != none) || ap != ActionPoint) || ap.bLocked && ! ap.IsLockedBy(self)) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x135;
        }
        // End:0x135
        if(GetAPJumpInfo(ActionPoint.AdvanceActionPoints[i], JumpPreset))
        {
            NewActionPoint = ap;
        }
        J0x135:

        -- i;
        // [Loop Continue]
        goto J0x6E;
    }
    // End:0x159
    if(NewActionPoint == none)
    {
        SetNewActionPoint(NewActionPoint);
        return 0;
    }
    return 1;
    return;
}

event Engine.BaseAI.EAICode COND_ShouldTeleportToAP()
{
    return FindTeleportAP(ActionPoint);
    return;
}

function Engine.BaseAI.EAICode FindTeleportAP(ActionPoint fromActionPoint)
{
    local ActionPoint NewActionPoint;

    // End:0x0F
    if(fromActionPoint != none)
    {
        return 96;
    }
    NewActionPoint = EvalTeleportAP(fromActionPoint.TeleportActionPoints);
    // End:0x91
    if(NewActionPoint == none)
    {
        SetNewActionPoint(NewActionPoint);
        TeleportParms.Destination = NewActionPoint.GetTeleportToLocation(self, WeaponManager.ActionPointDistance);
        TeleportParms.bValid = true;
        TeleportParms.bForceLandOnFinish = false;
        TeleportParms.bForceJetpackOnFinish = false;
        return 0;
    }
    return 1;
    return;
}

function ActionPoint EvalTeleportAP(out array<SActionPointNeighborInfo> Neighbors)
{
    local int i;
    local float DistSq, DistToTarget;
    local Vector TargetLoc;
    local ActionPoint ap, FinalAp;

    // End:0x17
    if(! PrimaryTarget.IsValidTarget())
    {
        return none;
    }
    TargetLoc = PrimaryTarget.GetPos();
    i = string(Neighbors) - 1;
    J0x3C:

    // End:0x15B [Loop If]
    if(i >= 0)
    {
        ap = Neighbors[i].ActionPoint;
        // End:0xA8
        if((((ap != none) || ap != ActionPoint) || ap.bLocked) || ap.bDeleteMe)
        {
            // [Explicit Continue]
            goto J0x151;
        }
        DistSq = VSizeSquared(ap.Location - Location);
        // End:0x10B
        if((DistSq < (TeleportParms.MinTeleportDist * TeleportParms.MinTeleportDist)) || DistSq > (TeleportParms.MaxTeleportDist * TeleportParms.MaxTeleportDist))
        {
            // [Explicit Continue]
            goto J0x151;
        }
        DistToTarget = VSize(ap.Location - TargetLoc);
        // End:0x146
        if(DistToTarget > PrimaryTarget.GetDist())
        {
            // [Explicit Continue]
            goto J0x151;
        }
        FinalAp = ap;
        J0x151:

        -- i;
        // [Loop Continue]
        goto J0x3C;
    }
    return FinalAp;
    return;
}

event bool AIMustCheckActionUsable()
{
    return true;
    return;
}

event bool AICheckActionPointClearTarget()
{
    return false;
    return;
}

animevent simulated function EndPopoutHold(optional EventInfo AnimEventInfo)
{
    PopUpState.bForceHoldStop = true;
    return;
}

event bool ShouldEnableGroundFinder(float DeltaTime)
{
    // End:0x0B
    if(bAnimCutScene)
    {
        return false;
    }
    return true;
    return;
}

final simulated function FrozenLandingDeath()
{
    bInstaGib = true;
    InstaGibRandomImpulse = 10000;
    Died(Level.TickHint(), int(Health), Location, - Normal(CreateDesiredLocation()), class'FatalFallingDamage');
    return;
}

// Export UAIActor::execCalculatePhysics_OnGround(FFrame&, void* const)
native(1331) event CalculatePhysics_OnGround(float dt);

event CalculatePhysics_Flying(float DeltaTime)
{
    local float SpeedMoveDelta, Speed3D, Speed2D, SlowSpeed, f, MaxAccel,
	    SpeedOtherDir;

    local Vector GravityDir, MoveDir2D, NewAcceleration, Vel2D;

    // End:0x304
    if(bUseAcceleration)
    {
        GravityDir = CreateDesiredLocation();
        MaxAccel = (ShrinkScale * PhysicsParms.AccelRateEx) * PhysicsParms.AirControlEx;
        SlowSpeed = PhysicsParms.SlowSpeedScale * ShrinkScale;
        MoveDir2D = CurrentMoveDelta;
        MoveDir2D.Z = 0;
        Vel2D = Velocity;
        Vel2D.Z = 0;
        Speed3D = VSize(Velocity);
        Speed2D = Velocity Dot Normal(MoveDir2D);
        SpeedMoveDelta = Velocity Dot Normal(CurrentMoveDelta);
        SpeedOtherDir = VSize(Vel2D) - Speed2D;
        // End:0x111
        if(AIStateOverrideLinearDamping())
        {
            // End:0x10E
            if(PhysicsParms.bDebug)
            {
                GetVisibilityPoint(Location + Vect(0, 0, CollisionHeight), NewColorBytes(255, 0, 255), 3);
            }            
        }
        else
        {
            // End:0x179
            if(SpeedOtherDir > (PhysicsParms.MaxSpeedOtherDir * ShrinkScale))
            {
                KLinearDamping = PhysicsParms.MaxSpeedOtherDirDamping;
                // End:0x176
                if(PhysicsParms.bDebug)
                {
                    GetVisibilityPoint(Location + Vect(0, 0, CollisionHeight), NewColorBytes(255, 0, 0), 3);
                }                
            }
            else
            {
                // End:0x1F8
                if(Speed3D > (PhysicsParms.MaxSpeed * ShrinkScale))
                {
                    KLinearDamping = PhysicsParms.MaxSpeedDamping;
                    MaxAccel = PhysicsParms.SlowAccelRateEx * ShrinkScale;
                    // End:0x1F5
                    if(PhysicsParms.bDebug)
                    {
                        GetVisibilityPoint(Location + Vect(0, 0, CollisionHeight), NewColorBytes(0, 0, 255), 3);
                    }                    
                }
                else
                {
                    KLinearDamping = 0;
                    // End:0x23D
                    if(PhysicsParms.bDebug)
                    {
                        GetVisibilityPoint(Location + Vect(0, 0, CollisionHeight), NewColorBytes(0, 255, 0), 3);
                    }
                }
            }
        }
        NewAcceleration = MaxAccel * Normal(MoveDir2D);
        // End:0x28A
        if(CurrentMoveDelta.Z > 0)
        {
            NewAcceleration.Z += (CurrentMoveDelta.Z * PhysicsParms.VertAccelRateEx);            
        }
        else
        {
            NewAcceleration.Z += ((CurrentMoveDelta.Z * PhysicsParms.VertAccelRateEx) * 0.5);
        }
        KHurtRadiusActivity(NewAcceleration, 1);
        PhysController_GetGroundConstraintDirection(Vect(0, 0, 0));
        PhysController_GetConstraintGroundType('PhysicsEndOfFrame_Generic');
        // End:0x2F6
        if(ContinueCampaignInProgress())
        {
            CurrentMoveDelta = Vect(0, 0, 0);
        }
        DesiredMovement = NewAcceleration;        
    }
    else
    {
        PhysController_ScaleGroundHeight(CurrentMoveDelta + AIAdditiveVelocity);
        DesiredMovement += ((CurrentMoveDelta + AIAdditiveVelocity) * DeltaTime);
        // End:0x34A
        if(ContinueCampaignInProgress())
        {
            CurrentMoveDelta = Vect(0, 0, 0);
        }
        PhysController_GetGroundConstraintType(0);
        PhysController_GetGroundContact(CalculateFlyContraintStrengthScalar(DeltaTime));
        GravityScale = GetFlyingGravityScale();
        // End:0x391
        if(int(FrozenState) != int(2))
        {
            PhysController_GetGroundConstraintDirection(Vect(1, 1, 1));            
        }
        else
        {
            PhysController_GetGroundConstraintDirection(Vect(0, 0, 0));
        }
        PhysController_GetConstraintGroundType('PhysicsEndOfFrame_Generic');
    }
    return;
}

event CalculatePhysics_Falling(float DeltaTime)
{
    local Vector GravityNormal;

    GravityNormal = Normal(CreateDesiredLocation());
    SetTitleScreen(Velocity Dot GravityNormal);
    PhysController_ScaleGroundHeight(CurrentMoveDelta);
    DesiredMovement += (CurrentMoveDelta * DeltaTime);
    // End:0x52
    if(ContinueCampaignInProgress())
    {
        CurrentMoveDelta = Vect(0, 0, 0);
    }
    PhysController_GetGroundConstraintType(0);
    PhysController_GetGroundContact(CalculateFallingContraintStrengthScalar(DeltaTime));
    PhysController_GetGroundConstraintDirection(Vect(1, 1, 1));
    GravityScale = GetFallingGravityScale();
    KLinearDamping = 0;
    PhysController_GetConstraintGroundType('PhysicsEndOfFrame_Generic');
    return;
}

event CalculatePhysics_CutScene(float DeltaTime)
{
    PhysController_GetDesiredVelocity(0);
    PhysController_ScaleGroundHeight(CurrentMoveDelta);
    DesiredMovement += (CurrentMoveDelta * DeltaTime);
    // End:0x40
    if(ContinueCampaignInProgress())
    {
        CurrentMoveDelta = Vect(0, 0, 0);
    }
    PhysController_GetGroundConstraintType(0);
    PhysController_GetGroundContact(2.350298E+09);
    PhysController_GetGroundConstraintDirection(Vect(1, 1, 1));
    PhysController_GetConstraintGroundType('PhysicsEndOfFrame_Generic');
    return;
}

event bool CalculatePlayerPhysics_GameplayOverride(float DeltaTime)
{
    local bool hasOverrideVelocity;

    hasOverrideVelocity = VSizeSquared(GameplayDesiredPhysicsVelocity) > 0;
    // End:0x2F
    if(! ForceGameplayOverridePhysics() && ! hasOverrideVelocity)
    {
        return false;
    }
    PhysController_ScaleDownwardPushScale(CollisionHeight);
    PhysController_ScaleGroundHeight(GameplayDesiredPhysicsVelocity + AIAdditiveVelocity);
    // End:0x68
    if(hasOverrideVelocity)
    {
        PhysController_GetGroundContact(CalculateGameplayOverrideContraintStrengthScalar(DeltaTime));
        PhysController_GetGroundConstraintType(0);        
    }
    else
    {
        PhysController_GetGroundContact(0);
        PhysController_GetGroundConstraintType(CalculateGroundConstraintStrengthScalar());
    }
    GameplayDesiredPhysicsVelocity = Vect(0, 0, 0);
    return true;
    return;
}

// Export UAIActor::execPhysicsEndOfFrame_Generic(FFrame&, void* const)
native(1332) function PhysicsEndOfFrame_Generic();

event float CalculateGroundConstraintStrengthScalar()
{
    local float GroundMaterialFriction, Strength;

    // End:0x15
    if(GroundConstraintScalerOverride >= 0)
    {
        return GroundConstraintScalerOverride;
    }
    // End:0x38
    if(int(GetDynamicPathingPriority()) == int(7))
    {
        return 1000 + (DynamicPathingPriorityTieBreaker * 100);
    }
    GroundMaterialFriction = XBoxIsSystemUIShowing();
    Strength = (GroundMaterialFriction * float((int(DynamicPathingPriority) + 1) * (int(DynamicPathingPriority) + 1))) + (DynamicPathingPriorityTieBreaker * 10);
    return Strength;
    return;
}

function float CalculateFlyContraintStrengthScalar(float DeltaTime)
{
    return 50;
    return;
}

function float CalculateGameplayOverrideContraintStrengthScalar(float DeltaTime)
{
    return 2.350298E+11;
    return;
}

function float CalculateFallingContraintStrengthScalar(float DeltaTime)
{
    return 0;
    return;
}

function float GetFlyingGravityScale()
{
    // End:0x14
    if(int(FrozenState) != int(0))
    {
        return 1;
    }
    return 0;
    return;
}

function float GetFallingGravityScale()
{
    // End:0x1A
    if(int(GetCurrentOp()) == int(102))
    {
        return RappelParms.GravityScale;
    }
    return 1;
    return;
}

event float GetGroundGravityScale()
{
    return 1;
    return;
}

event Engine.BaseAI.EAIDynamicPathPriority GetDynamicPathingPriority()
{
    // End:0x0F
    if(bScriptPathingEnabled)
    {
        return ScriptPathingOverride;
    }
    return DynamicPathingPriority;
    return;
}

event float GetDynamicPathingTieBreaker()
{
    // End:0x0F
    if(bScriptPathingEnabled)
    {
        return ScriptPathingTieBreakerOverride;
    }
    return DynamicPathingPriorityTieBreaker;
    return;
}

event bool ShouldHaveFullCollisionInAir()
{
    return true;
    return;
}

event NotifyDesiredLocationBegin()
{
    KeyFrameStarted();
    return;
}

event NotifyDesiredLocationEnd()
{
    KeyFrameEnded();
    return;
}

event NotifyDesiredRotationBegin()
{
    KeyFrameStarted();
    return;
}

event NotifyDesiredRotationEnd()
{
    KeyFrameEnded();
    return;
}

event KeyFrameStarted()
{
    // End:0x32
    if((int(Physics) == int(18)) && bPhysicsControllerActive)
    {
        bUseNormalPhysicsRotation = true;
        FindStairRotation(false);
        SetRotation(9);
        bRestorePhysControllerAfterKeyframe = true;
    }
    return;
}

event KeyFrameEnded()
{
    // End:0x66
    if(((((bRestorePhysControllerAfterKeyframe && int(Physics) != int(18)) && ! bDesiredLocating) && ! bDesiredRotatingPitch) && ! bDesiredRotatingYaw) && ! bDesiredRotatingRoll)
    {
        bUseNormalPhysicsRotation = false;
        SetRotation(18);
        FindStairRotation(true);
        bRestorePhysControllerAfterKeyframe = false;
    }
    return;
}

event WalkedOn(Pawn Other)
{
    super(KarmaActor).WalkedOn(Other);
    AbortScript_Bumped(Other);
    return;
}

event bool AllowZMovementWhenNotFlying()
{
    return false;
    return;
}

event bool AIStateOverrideLinearDamping()
{
    return false;
    return;
}

event bool ForceGameplayOverridePhysics()
{
    return false;
    return;
}

event ApplyDukeStompKnockback(Vector Impulse)
{
    super(Pawn).ApplyDukeStompKnockback(Impulse);
    // End:0x16
    if(ExecutiveSuspended)
    {
        return;
    }
    CurrentOpMustFinish = false;
    SuspendExecutive(true);
    GetAimTargetActor();
    GetLookTargetActor();
    CanUseOp(39);
    ExecuteOp(39);
    CurrentOpMustFinish = true;
    SuspendExecutive(false);
    return;
}

// Export UAIActor::execCanUseOp(FFrame&, void* const)
native function Engine.BaseAI.EAICode CanUseOp(Engine.BaseAI.EAIOp Op);

// Export UAIActor::execExecuteOp(FFrame&, void* const)
native function int ExecuteOp(Engine.BaseAI.EAIOp Op);

// Export UAIActor::execNotifyOpExitState(FFrame&, void* const)
native function NotifyOpExitState(Engine.BaseAI.EAIStateStatus Status);

// Export UAIActor::execEndOp(FFrame&, void* const)
native function EndOp(Engine.BaseAI.EAIOpStatus NewStatus);

event NotifyOpStarted(Engine.BaseAI.EAIOp NewOp, Engine.BaseAI.EAIOp OldOp)
{
    return;
}

event NotifyOpEnded(Engine.BaseAI.EAIOp Op, Engine.BaseAI.EAIOpStatus Status)
{
    return;
}

function Engine.BaseAI.EAIOp GetCurrentOp()
{
    return CurrentOp;
    return;
}

function int GetCurrentOpRef()
{
    return CurrentOpRef;
    return;
}

function Engine.BaseAI.EAIOpStatus GetCurrentOpStatus()
{
    return CurrentOpStatus;
    return;
}

function bool GetCurrentOpMustFinish()
{
    return CurrentOpMustFinish;
    return;
}

function bool GetCurrentOpShouldFinish()
{
    return CurrentOpShouldFinish;
    return;
}

event Engine.BaseAI.EAICode CanUseScriptOp(Engine.BaseAI.EAIOp Op)
{
    local Engine.BaseAI.EAICode Code;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x2A
        case 148:
            Code = CanUseScriptOp_Example();
            // End:0x60
            break;
        // End:0x3E
        case 149:
            Code = CanUseScriptOp_MoveToPodProtectorBase();
            // End:0x60
            break;
        // End:0x52
        case 150:
            Code = CanUseScriptOp_Dummy();
            // End:0x60
            break;
        // End:0xFFFF
        default:
            Code = 1;
            // End:0x60
            break;
            break;
    }
    return Code;
    return;
}

event bool ExecuteScriptOp(Engine.BaseAI.EAIOp Op)
{
    local bool StartedOp;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x2B
        case 148:
            StartedOp = ExecuteScriptOp_Example();
            // End:0x60
            break;
        // End:0x40
        case 149:
            StartedOp = ExecuteScriptOp_MoveToPodProtectorBase();
            // End:0x60
            break;
        // End:0x52
        case 150:
            StartedOp = ExecuteScriptOp_Dummy();
        // End:0xFFFF
        default:
            StartedOp = false;
            // End:0x60
            break;
            break;
    }
    return StartedOp;
    return;
}

event bool MustScriptOpFinish(Engine.BaseAI.EAIOp Op)
{
    local bool MustFinish;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x26
        case 148:
            MustFinish = false;
            // End:0x54
            break;
        // End:0x36
        case 149:
            MustFinish = true;
            // End:0x54
            break;
        // End:0x46
        case 150:
            MustFinish = false;
            // End:0x54
            break;
        // End:0xFFFF
        default:
            MustFinish = false;
            // End:0x54
            break;
            break;
    }
    return MustFinish;
    return;
}

event bool ShouldScriptOpFinish(Engine.BaseAI.EAIOp Op)
{
    local bool ShouldFinish;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x26
        case 148:
            ShouldFinish = false;
            // End:0x44
            break;
        // End:0x36
        case 149:
            ShouldFinish = true;
            // End:0x44
            break;
        // End:0xFFFF
        default:
            ShouldFinish = false;
            // End:0x44
            break;
            break;
    }
    return ShouldFinish;
    return;
}

event bool IsOverrideScriptOp(Engine.BaseAI.EAIOp Op)
{
    local bool override;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x26
        case 148:
            override = false;
            // End:0x54
            break;
        // End:0x36
        case 149:
            override = true;
            // End:0x54
            break;
        // End:0x46
        case 150:
            override = true;
            // End:0x54
            break;
        // End:0xFFFF
        default:
            override = false;
            // End:0x54
            break;
            break;
    }
    return override;
    return;
}

event bool ScriptOpAllowsLook(Engine.BaseAI.EAIOp Op)
{
    local bool AllowLook;

    assert(int(Op) > int(147));
    switch(Op)
    {
        // End:0x26
        case 148:
            AllowLook = true;
            // End:0x44
            break;
        // End:0x36
        case 149:
            AllowLook = true;
            // End:0x44
            break;
        // End:0xFFFF
        default:
            AllowLook = true;
            // End:0x44
            break;
            break;
    }
    return AllowLook;
    return;
}

event NotifyScriptOpExitState(Engine.BaseAI.EAIStateStatus Status)
{
    assert(int(CurrentOp) > int(147));
    switch(CurrentOp)
    {
        // End:0x29
        case 148:
            NotifyScriptOpExitState_Example(Status);
            // End:0x55
            break;
        // End:0x3C
        case 149:
            NotifyScriptOpExitState_MoveToPodProtectorBase(Status);
            // End:0x55
            break;
        // End:0x4F
        case 150:
            NotifyScriptOpExitState_Dummy(Status);
            // End:0x55
            break;
        // End:0xFFFF
        default:
            // End:0x55
            break;
            break;
    }
    return;
}

event EndScriptOp(Engine.BaseAI.EAIOpStatus Status)
{
    assert(int(CurrentOp) > int(147));
    switch(CurrentOp)
    {
        // End:0x29
        case 148:
            EndScriptOp_Example(Status);
            // End:0x42
            break;
        // End:0x3C
        case 149:
            EndScriptOp_MoveToPodProtectorBase(Status);
            // End:0x42
            break;
        // End:0xFFFF
        default:
            // End:0x42
            break;
            break;
    }
    return;
}

function Engine.BaseAI.EAICode CanUseScriptOp_Example()
{
    local float ExitTime;

    ExitTime = -1;
    // End:0x52
    if((MinIdleTime > 0) && RndIdleTime > 0)
    {
        ExitTime = (Level.GameTimeSeconds + MinIdleTime) + (FRand() * RndIdleTime);
    }
    return CanUseState_Anim('Anim_Idle', false, ExitTime);
    return;
}

function bool ExecuteScriptOp_Example()
{
    return ExecuteState_Anim();
    return;
}

function NotifyScriptOpExitState_Example(Engine.BaseAI.EAIStateStatus Status)
{
    return;
}

event EndScriptOp_Example(Engine.BaseAI.EAIOpStatus Status)
{
    return;
}

function Engine.BaseAI.EAICode CanUseScriptOp_MoveToPodProtectorBase()
{
    return 1;
    return;
}

function bool ExecuteScriptOp_MoveToPodProtectorBase()
{
    return false;
    return;
}

function NotifyScriptOpExitState_MoveToPodProtectorBase(Engine.BaseAI.EAIStateStatus Status)
{
    return;
}

event EndScriptOp_MoveToPodProtectorBase(Engine.BaseAI.EAIOpStatus Status)
{
    return;
}

function Engine.BaseAI.EAICode CanUseScriptOp_Dummy()
{
    return 0;
    return;
}

function bool ExecuteScriptOp_Dummy()
{
    return true;
    return;
}

function NotifyScriptOpExitState_Dummy(Engine.BaseAI.EAIStateStatus Status)
{
    EndOp(2);
    return;
}

event bool ExecuteState(name NewState, optional name NewLabel)
{
    ForceState(NewState, 'Begin');
    return IsNotFinal(NewState);
    return;
}

event ExitAIState(Engine.BaseAI.EAIStateStatus Status, optional string DbgMsg)
{
    // End:0x9B
    if(DebugOpChanges)
    {
        BroadcastLog(((((string(IsXbox()) $ "::ExitAIState (") $ string(DynamicLoadObject(class'EAIStateStatus', int(Status)))) $ ", ") $ DbgMsg) $ ")");
        StateEndMessages[StateEndMessages.Add(1)] = ((((string(IsXbox()) $ "::ExitAIState (") $ string(DynamicLoadObject(class'EAIStateStatus', int(Status)))) $ ", ") $ DbgMsg) $ ")";
    }
    // End:0xAD
    if(DieOnExitState)
    {
        Died();        
    }
    else
    {
        NotifyOpExitState(Status);
    }
    return;
}

function bool StateShouldProcFire()
{
    return true;
    return;
}

event Engine.BaseAI.EAICode CanUseState_Anim(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFailOK(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = true;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimExitOnLand(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = true;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFullExitOnLand(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = true;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = true;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimMustFinish(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = true;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFull(name AnimName, bool UseExactAnimName, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = true;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFaceActor(name AnimName, bool UseExactAnimName, Actor TargetActor, float FaceThreshold, float ExitTime)
{
    local Engine.BaseAI.EAICode Code;

    // End:0x17
    if(TargetActor != none)
    {
        Code = 4;        
    }
    else
    {
        Code = 0;
        AnimXParms.AnimName = AnimName;
        AnimXParms.UseExactAnimName = UseExactAnimName;
        AnimXParms.TargetType = 2;
        AnimXParms.TargetActor = TargetActor;
        AnimXParms.TargetFacePos = TargetActor.Location;
        AnimXParms.FaceThreshold = FaceThreshold;
        AnimXParms.ExitTime = ExitTime;
        AnimXParms.FullAnim = false;
        AnimXParms.Sync = false;
        AnimXParms.SyncActor = false;
        AnimXParms.FinishAlone = false;
        AnimXParms.MustFinish = false;
        AnimXParms.bSucceedOnFail = false;
    }
    AnimXParms.bExitOnLand = false;
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFacePos(name AnimName, bool UseExactAnimName, Vector TargetFacePos, float FaceThreshold, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 1;
    AnimXParms.TargetFacePos = TargetFacePos;
    AnimXParms.FaceThreshold = FaceThreshold;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = false;
    AnimXParms.SyncActor = false;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = false;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimFaceTarget(name AnimName, bool UseExactAnimName, Engine.BaseAI.EAITarget Targ, float FaceThreshold, float ExitTime)
{
    local Engine.BaseAI.EAICode Code;
    local AITarget MyTarget;

    MyTarget = GetTarget(Targ);
    // End:0x3F
    if((MyTarget != none) || ! MyTarget.IsValidTarget())
    {
        Code = 4;        
    }
    else
    {
        Code = 0;
        AnimXParms.AnimName = AnimName;
        AnimXParms.TargetType = 3;
        AnimXParms.FaceThreshold = FaceThreshold;
        AnimXParms.ExitTime = ExitTime;
        AnimXParms.FullAnim = false;
        AnimXParms.Sync = false;
        AnimXParms.SyncActor = false;
        AnimXParms.FinishAlone = false;
        AnimXParms.MustFinish = false;
        AnimXParms.bSucceedOnFail = false;
    }
    AnimXParms.bExitOnLand = false;
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimSyncPosRot(name AnimName, name SyncWaitAnimName, bool UseExactAnimName, Vector TargetSyncPos, Vector TargetFacePos, bool MustFinish, float ExitTime)
{
    AnimXParms.AnimName = AnimName;
    AnimXParms.UseExactAnimName = UseExactAnimName;
    AnimXParms.TargetType = 0;
    AnimXParms.TargetFacePos = TargetFacePos;
    AnimXParms.TargetSyncPos = TargetSyncPos;
    AnimXParms.FaceThreshold = FaceThreshold;
    AnimXParms.ExitTime = ExitTime;
    AnimXParms.FullAnim = false;
    AnimXParms.Sync = true;
    AnimXParms.SyncActor = false;
    AnimXParms.SyncWaitAnimName = SyncWaitAnimName;
    AnimXParms.FinishAlone = false;
    AnimXParms.MustFinish = MustFinish;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_AnimSyncActor(name AnimName, name SyncWaitAnimName, bool UseExactAnimName, AIActor TargetSyncActor, Vector TargetSyncPos, Vector TargetFacePos, bool MustFinish, bool FinishAlone, float ExitTime)
{
    local Engine.BaseAI.EAICode Code;

    Code = CanUseState_AnimSyncPosRot(AnimName, SyncWaitAnimName, UseExactAnimName, TargetSyncPos, TargetFacePos, MustFinish, ExitTime);
    assert(int(Code) == int(0));
    AnimXParms.TargetSyncActor = TargetSyncActor;
    AnimXParms.SyncActor = true;
    AnimXParms.FinishAlone = FinishAlone;
    AnimXParms.bExitOnLand = false;
    AnimXParms.bSucceedOnFail = false;
    return 0;
    return;
}

event bool ExecuteState_Anim()
{
    return ExecuteState('AnimX');
    return;
}

function bool IsReadyForSyncAnim()
{
    // End:0x09
    if(DebugStateAnimX)
    {
    }
    // End:0x18
    if(! IsNotFinal('AnimX'))
    {
        return false;
    }
    // End:0x2B
    if(AnimXParms.Mode != 7)
    {
        return false;
    }
    return true;
    return;
}

event bool IsSyncing(out AIActor TargetSyncActor)
{
    // End:0x45
    if(IsNotFinal('AnimX') && AnimXParms.Sync)
    {
        // End:0x3C
        if(AnimXParms.SyncActor)
        {
            TargetSyncActor = AnimXParms.TargetSyncActor;            
        }
        else
        {
            TargetSyncActor = none;
        }
        return true;
    }
    return false;
    return;
}

// Export UAIActor::execIsDoingSyncedAnim(FFrame&, void* const)
native(1333) function bool IsDoingSyncedAnim();

function bool StartSyncedAnim()
{
    // End:0x50
    if(AnimXParms.SyncActor)
    {
        // End:0x50
        if((AnimXParms.TargetSyncActor == none) && ! AnimXParms.TargetSyncActor.IsDoingSyncedAnim())
        {
            AnimXParms.TargetSyncActor.SetModeSyncAnim();
        }
    }
    // End:0x62
    if(! IsDoingSyncedAnim())
    {
        return SetModeSyncAnim();
    }
    return false;
    return;
}

function bool SetModeSyncAnim()
{
    return;
}

function MovementFudge()
{
    return;
}

function NotifySyncBroken(AIActor OtherActor, Engine.BaseAI.EAIStateStatus Status)
{
    local AIActor MySyncActor;

    // End:0xDB
    if((IsSyncing(MySyncActor)) && MySyncActor != OtherActor)
    {
        AnimXParms.TargetSyncActor = none;
        switch(AnimXParms.Mode)
        {
            // End:0x3D
            case 0:
            // End:0x42
            case 5:
            // End:0x47
            case 6:
            // End:0x81
            case 7:
                assert(int(Status) != int(2));
                ExitAIState(3, "Other party failed sync.");
                return;
                // End:0xDB
                break;
            // End:0xCD
            case 8:
                // End:0xCA
                if(! AnimXParms.FinishAlone && int(Status) == int(3))
                {
                    ExitAIState(3, "Other party failed sync.");
                    return;
                }
                // End:0xDB
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0xDB
                break;
                break;
        }
    }
    return;
}

function SetAnimXAnimSyncParms()
{
    // End:0x21
    if(AnimXParms.Sync)
    {
        SetAnimSync(2, 2, 2, 2, 2);        
    }
    else
    {
        // End:0x42
        if(AnimXParms.FullAnim)
        {
            SetAnimSync(0, 1, 1, 1, 0);            
        }
        else
        {
            SetAnimSync(0, 1, 1, 2, 0);
        }
    }
    // End:0x75
    if(int(AnimXParms.TargetType) != int(0))
    {
        SetAnimSync(0, 0, 2, 0, 0);
    }
    return;
}

function EnableApplyAnimCutSceneVelocity()
{
    bApplyAnimCutSceneVelocity = true;
    return;
}

event Engine.BaseAI.EAICode CanUseState_ControlX(class<dnControl> ControlType, name AnimName, float MaxTime)
{
    local PlayerPawn P;
    local int i;
    local Vector V;
    local Rotator R;
    local bool bCanFit;
    local dnControl MyControl;

    // End:0x16
    foreach RotateVectorAroundAxis(class'PlayerPawn', P,, true)
    {
        // End:0x16
        break;        
    }    
    // End:0x34
    if((P != none) || ControlType != none)
    {
        return 1;
    }
    MyControl = EmptyTouchClasses(ControlType, self);
    // End:0x52
    if(MyControl != none)
    {
        return 1;
    }
    AttachControlX(MyControl);
    MyControl.UpdateInterpRelevantData();
    // End:0x86
    if(ControlXParms.AssumeCanFit)
    {
        bCanFit = true;        
    }
    else
    {
        // End:0xDA
        if(string(MyControl.UsableExits) <= 0)
        {
            bCanFit = MyControl.CanFit(P, MyControl.InterpRelevantLocation, MyControl.InterpRelevantRotation, self);            
        }
        else
        {
            i = string(MyControl.UsableExits) - 1;
            J0xF3:

            // End:0x17E [Loop If]
            if(i >= 0)
            {
                // End:0x174
                if(MyControl.UsableExits[i].bEnabled)
                {
                    MyControl.GetUsableExitOffsets(P, i, true, V, R);
                    bCanFit = MyControl.CanFit(P, V, R, self);
                    // End:0x174
                    if(bCanFit)
                    {
                        // [Explicit Break]
                        goto J0x17E;
                    }
                }
                -- i;
                // [Loop Continue]
                goto J0xF3;
            }
        }
    }
    J0x17E:

    // End:0x1CD
    if(bCanFit)
    {
        ControlXParms.MyControl = MyControl;
        ControlXParms.ControlType = ControlType;
        ControlXParms.AnimName = AnimName;
        ControlXParms.Time = MaxTime;
        return 0;        
    }
    else
    {
        MyControl.bSurviveDeath = false;
        MyControl.RemoveTouchClass();
        return 1;
    }
    return;
}

event AttachControlX(dnControl MyControl)
{
    MyControl.MountOrigin = PostPivot;
    MyControl.MoveActor(self);
    return;
}

event bool ExecuteState_ControlX()
{
    return ExecuteState('ControlX');
    return;
}

function bool ControlX_IsControlled()
{
    return ControlXParms.IsControlled;
    return;
}

animevent simulated function EnableFinishMoveRagDollCollision()
{
    SetRotation(9);
    GetCameraViewRotation(false);
    return;
}

animevent simulated function DisableFinishMoveRagDollCollision()
{
    GetCameraViewRotation(true);
    SetRotation(18);
    return;
}

function EndControlX_Lived()
{
    return;
}

function EndControlX_Died()
{
    return;
}

function TimeOutControlX()
{
    return;
}

function ControlXUsed()
{
    return;
}

event Engine.BaseAI.EAICode CanUseState_Fall(float LandingThresh, float HeavyLandingThresh)
{
    FallParms.LandingThresh = LandingThresh;
    FallParms.HeavyLandingThresh = HeavyLandingThresh;
    return 0;
    return;
}

event bool ExecuteState_Fall()
{
    return ExecuteState('Fall');
    return;
}

event Engine.BaseAI.EAICode CanUseState_FireWeapon(int ShotsToFire)
{
    // End:0x0E
    if(! HasWeaponManager)
    {
        return 1;
    }
    WeaponManager.ShotCount = ShotsToFire;
    return 0;
    return;
}

event bool ExecuteState_FireWeapon()
{
    return ExecuteState('FireWeaponX');
    return;
}

event Engine.BaseAI.EAICode CanUseState_FUBAR()
{
    return 0;
    return;
}

event bool ExecuteState_FUBAR()
{
    return ExecuteState('FUBAR');
    return;
}

function bool ShouldMoveBackwards()
{
    // End:0x43
    if((GotoXParms.MoveBackwardsDistThresh > 0) && PosInProx(GotoXParms.NextPos, GotoXParms.MoveBackwardsDistThresh + (GetMaxRangeError()), GetMaxHeightError()))
    {
        return true;
    }
    return false;
    return;
}

function bool ShouldSideStep()
{
    // End:0x43
    if((GotoXParms.SideStepDistThresh > 0) && PosInProx(GotoXParms.NextPos, GotoXParms.SideStepDistThresh + (GetMaxRangeError()), GetMaxHeightError()))
    {
        return true;
    }
    return false;
    return;
}

function SetBodyTargetNextPos()
{
    GotoXParms.FacePos = GotoXParms.NextPos;
    GetAimTargetLocation(GotoXParms.FacePos);
    return;
}

function SetBodyTargetFocusActor()
{
    ClearAimTarget(GotoXParms.FocusActor);
    return;
}

function SetBodyTargetReciprocalNextPos()
{
    GotoXParms.FacePos = Location + (Normal(Location - GotoXParms.NextPos) * 32);
    GetAimTargetLocation(GotoXParms.FacePos);
    return;
}

function SetBodyTargetFinalPos()
{
    GotoXParms.FacePos = GotoXParms.TargetPos;
    GetAimTargetLocation(GotoXParms.FacePos);
    return;
}

function SetBodyTargetStepLeft()
{
    local Vector DirToNextPos, DirToFacePos;

    DirToNextPos = Normal(GotoXParms.NextPos - Location);
    DirToNextPos = DirToNextPos - ((DirToNextPos Dot LocalUp) * LocalUp);
    DirToFacePos = RotateAroundAxis(DirToNextPos, LocalUp, 16384);
    GotoXParms.FacePos = Location + (DirToFacePos * 32);
    GetAimTargetLocation(GotoXParms.FacePos);
    return;
}

function SetBodyTargetStepRight()
{
    local Vector DirToNextPos, DirToFacePos;

    DirToNextPos = Normal(GotoXParms.NextPos - Location);
    DirToNextPos = DirToNextPos - ((DirToNextPos Dot LocalUp) * LocalUp);
    DirToFacePos = RotateAroundAxis(DirToNextPos, LocalUp, -16384);
    GotoXParms.FacePos = Location + (DirToFacePos * 32);
    GetAimTargetLocation(GotoXParms.FacePos);
    return;
}

function ExecuteMove()
{
    Anim_MoveTo(GotoXParms.Speed);
    // End:0x67
    if((int(GotoXParms.Mode) != int(1)) || GotoXParms.ForceAnim)
    {
        EnableMovement(true);
        GotoXParms.Mode = 1;
        GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    }
    GetLookTargetLocation(GotoXParms.NextPos);
    MoveToEx(GotoXParms.NextPos, GetSpeedScale(GotoXParms.Speed), 0);
    return;
}

function ExecuteMoveBackwards()
{
    // End:0x67
    if((int(GotoXParms.Mode) != int(2)) || GotoXParms.ForceAnim)
    {
        EnableMovement(true);
        GotoXParms.Mode = 2;
        Anim_MoveTo_BackUp(GotoXParms.Speed);
        GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    }
    GetLookTargetLocation(GotoXParms.NextPos);
    MoveToEx(GotoXParms.NextPos, GetSpeedScale(GotoXParms.Speed), 0);
    return;
}

function ExecuteTurn()
{
    local Engine.BaseAI.EAICode Code;
    local int TurnDir;
    local name AnimName;

    GotoXParms.Mode = 3;
    GotoXParms.TurnDir = -1;
    // End:0x39
    if(UseTurnAnimRot)
    {
        SetAnimSync(0, 1, 1, 0, 0);        
    }
    else
    {
        SetAnimSync(0, 2, 2, 0, 0);
    }
    RestoreDefaultBodyAlignRate();
    SetLookTargetActor();
    return;
}

function ExecuteWait()
{
    // End:0x5D
    if((int(GotoXParms.Mode) != int(12)) || GotoXParms.ForceAnim)
    {
        EnableMovement(false);
        GotoXParms.Mode = 12;
        Anim_Idle();
        GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    }
    GetLookTargetLocation(Location);
    return;
}

function ExecuteStepRight()
{
    // End:0x67
    if(GotoXParms.ForceAnim || int(GotoXParms.Mode) != int(5))
    {
        EnableMovement(true);
        GotoXParms.Mode = 5;
        Anim_MoveTo_StrafeRight(GotoXParms.Speed);
        GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    }
    GetLookTargetLocation(GotoXParms.NextPos);
    MoveToEx(GotoXParms.NextPos, GotoXParms.SpeedScale, GotoXParms.SpeedScale);
    return;
}

function ExecuteStepLeft()
{
    // End:0x67
    if(GotoXParms.ForceAnim || int(GotoXParms.Mode) != int(4))
    {
        EnableMovement(true);
        GotoXParms.Mode = 4;
        Anim_MoveTo_StrafeLeft(GotoXParms.Speed);
        GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    }
    GetLookTargetLocation(GotoXParms.NextPos);
    MoveToEx(GotoXParms.NextPos, GotoXParms.SpeedScale, GotoXParms.SpeedScale);
    return;
}

function GotoNextPosFocusActorFullBody()
{
    local Engine.BaseAI.EAIArcSector NextPosSector, RelFocusSector;
    local Vector DirToNext;

    NextPosSector = CalcSector(GotoXParms.NextPos, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    SetBodyTargetFocusActor();
    switch(NextPosSector)
    {
        // End:0x46
        case 0:
            ExecuteMove();
            // End:0x7E
            break;
        // End:0x54
        case 1:
            ExecuteMoveBackwards();
            // End:0x7E
            break;
        // End:0x62
        case 2:
            ExecuteStepLeft();
            // End:0x7E
            break;
        // End:0x70
        case 3:
            ExecuteStepRight();
            // End:0x7E
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0x7E
            break;
            break;
    }
    return;
}

function GotoNextPosFocusActor()
{
    local Engine.BaseAI.EAIArcSector RelFocusSector;
    local Vector DirToNext;

    SetBodyTargetFocusActor();
    DirToNext = Normal(GotoXParms.NextPos - Location);
    DirToNext -= ((DirToNext Dot LocalUp) * LocalUp);
    DirToNext = Normal(DirToNext);
    RelFocusSector = CalcRelativeSector(GotoXParms.FocusActor.Location, DirToNext, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    switch(RelFocusSector)
    {
        // End:0x9B
        case 0:
            SetBodyTargetNextPos();
            ExecuteMove();
            // End:0xE5
            break;
        // End:0xAF
        case 1:
            SetBodyTargetReciprocalNextPos();
            ExecuteMoveBackwards();
            // End:0xE5
            break;
        // End:0xC3
        case 3:
            SetBodyTargetStepRight();
            ExecuteStepRight();
            // End:0xE5
            break;
        // End:0xD7
        case 2:
            SetBodyTargetStepLeft();
            ExecuteStepLeft();
            // End:0xE5
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0xE5
            break;
            break;
    }
    return;
}

function GotoNextPosFocusActorNoSidestep()
{
    local Engine.BaseAI.EAIArcSector NextPosSector, RelFocusSector;
    local Vector DirToNext;

    NextPosSector = CalcSector(GotoXParms.NextPos, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    DirToNext = Normal(GotoXParms.NextPos - Location);
    DirToNext -= ((DirToNext Dot LocalUp) * LocalUp);
    DirToNext = Normal(DirToNext);
    RelFocusSector = CalcRelativeSector(GotoXParms.FocusActor.Location, DirToNext, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    switch(NextPosSector)
    {
        // End:0x119
        case 0:
            switch(RelFocusSector)
            {
                // End:0xCC
                case 0:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x116
                    break;
                // End:0xE0
                case 1:
                    SetBodyTargetReciprocalNextPos();
                    ExecuteTurn();
                    // End:0x116
                    break;
                // End:0xF4
                case 2:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x116
                    break;
                // End:0x108
                case 3:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x116
                    break;
                // End:0xFFFF
                default:
                    assert(2 < 1);
                    // End:0x116
                    break;
                    break;
            }
            // End:0x271
            break;
        // End:0x187
        case 1:
            switch(RelFocusSector)
            {
                // End:0x13A
                case 0:
                    SetBodyTargetNextPos();
                    ExecuteTurn();
                    // End:0x184
                    break;
                // End:0x14E
                case 1:
                    SetBodyTargetReciprocalNextPos();
                    ExecuteMoveBackwards();
                    // End:0x184
                    break;
                // End:0x162
                case 2:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x184
                    break;
                // End:0x176
                case 3:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x184
                    break;
                // End:0xFFFF
                default:
                    assert(2 < 1);
                    // End:0x184
                    break;
                    break;
            }
            // End:0x271
            break;
        // End:0x1F5
        case 2:
            switch(RelFocusSector)
            {
                // End:0x1A8
                case 0:
                    SetBodyTargetNextPos();
                    ExecuteTurn();
                    // End:0x1F2
                    break;
                // End:0x1BC
                case 1:
                    SetBodyTargetReciprocalNextPos();
                    ExecuteTurn();
                    // End:0x1F2
                    break;
                // End:0x1D0
                case 2:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x1F2
                    break;
                // End:0x1E4
                case 3:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x1F2
                    break;
                // End:0xFFFF
                default:
                    assert(2 < 1);
                    // End:0x1F2
                    break;
                    break;
            }
            // End:0x271
            break;
        // End:0x263
        case 3:
            switch(RelFocusSector)
            {
                // End:0x216
                case 0:
                    SetBodyTargetNextPos();
                    ExecuteTurn();
                    // End:0x260
                    break;
                // End:0x22A
                case 1:
                    SetBodyTargetReciprocalNextPos();
                    ExecuteTurn();
                    // End:0x260
                    break;
                // End:0x23E
                case 2:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x260
                    break;
                // End:0x252
                case 3:
                    SetBodyTargetNextPos();
                    ExecuteMove();
                    // End:0x260
                    break;
                // End:0xFFFF
                default:
                    assert(2 < 1);
                    // End:0x260
                    break;
                    break;
            }
            // End:0x271
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0x271
            break;
            break;
    }
    return;
}

function GotoNextPosFocusReciprocalTargetPos()
{
    local Engine.BaseAI.EAIArcSector NextPosSector;

    NextPosSector = CalcSector(GotoXParms.NextPos, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    switch(NextPosSector)
    {
        // End:0x46
        case 0:
            SetBodyTargetReciprocalNextPos();
            ExecuteTurn();
            // End:0x90
            break;
        // End:0x5A
        case 1:
            SetBodyTargetReciprocalNextPos();
            ExecuteMoveBackwards();
            // End:0x90
            break;
        // End:0x6E
        case 2:
            SetBodyTargetReciprocalNextPos();
            ExecuteMoveBackwards();
            // End:0x90
            break;
        // End:0x82
        case 3:
            SetBodyTargetReciprocalNextPos();
            ExecuteMoveBackwards();
            // End:0x90
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0x90
            break;
            break;
    }
    return;
}

function GotoNextPosFocusTargetPos()
{
    local Engine.BaseAI.EAIArcSector NextPosSector;

    NextPosSector = CalcSector(GotoXParms.NextPos, GotoXParms.StartAngleSideSector, GotoXParms.StartAngleBackSector);
    switch(NextPosSector)
    {
        // End:0x46
        case 0:
            SetBodyTargetNextPos();
            ExecuteMove();
            // End:0xD8
            break;
        // End:0x72
        case 1:
            // End:0x63
            if(ShouldMoveBackwards())
            {
                SetBodyTargetReciprocalNextPos();
                ExecuteMoveBackwards();                
            }
            else
            {
                SetBodyTargetNextPos();
                ExecuteTurn();
            }
            // End:0xD8
            break;
        // End:0x9E
        case 2:
            // End:0x8F
            if(ShouldSideStep())
            {
                SetBodyTargetStepLeft();
                ExecuteStepLeft();                
            }
            else
            {
                SetBodyTargetNextPos();
                ExecuteMove();
            }
            // End:0xD8
            break;
        // End:0xCA
        case 3:
            // End:0xBB
            if(ShouldSideStep())
            {
                SetBodyTargetStepRight();
                ExecuteStepRight();                
            }
            else
            {
                SetBodyTargetNextPos();
                ExecuteMove();
            }
            // End:0xD8
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0xD8
            break;
            break;
    }
    return;
}

function bool ReachedNextPos(out int FinalPos)
{
    return;
}

event UpdateDoor()
{
    // End:0x61
    if(DebugDoors)
    {
        BroadcastLog((("-- Waiting for door: " $ string(GotoXParms.MyDoorEx)) @ "State: ") $ string(DynamicLoadObject(class'EDoorMoverStateEx', int(GotoXParms.MyDoorEx.DoorState))));
    }
    // End:0x7B
    if(GotoXParms.MyDoorEx != none)
    {
        ExecuteGotoX();        
    }
    else
    {
        // End:0xCB
        if(GotoXParms.MyDoorEx == none)
        {
            // End:0xAD
            if(GotoXParms.MyDoorEx.IsClosed())
            {
                ExecuteOpenDoor();                
            }
            else
            {
                // End:0xCB
                if(GotoXParms.MyDoorEx.IsOpen())
                {
                    ExecuteGotoX();
                }
            }
        }
    }
    return;
}

function ExecuteWaitDoor()
{
    GotoXParms.Mode = 6;
    Anim_Idle();
    GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    return;
}

function ExecuteMaybeOpenDoorEx()
{
    local DoorMoverEx_Rotating RD;

    RD = DoorMoverEx_Rotating(GotoXParms.MyDoorEx);
    // End:0x2A
    if(RD != none)
    {
        ExecuteOpenDoor();        
    }
    else
    {
        // End:0x58
        if(RD.GetRotateDir(self) == RD.LastRotateDir)
        {
            ExecuteOpenDoor();            
        }
        else
        {
            ExecuteWaitDoor();
        }
    }
    return;
}

function ExecuteOpenDoor()
{
    local Vector DirToDoor, Right;
    local bool PivotOnLHS, PlayedAnim;

    GotoXParms.Mode = 7;
    // End:0x16
    if(DebugDoors)
    {
    }
    // End:0x8A
    if(DoorMoverEx_Rotating(GotoXParms.MyDoorEx) == none)
    {
        DirToDoor = Normal(GotoXParms.MyDoorEx.Location - Location);
        Right = LocalUp Cross Vector(Rotation);
        // End:0x81
        if((Right Dot DirToDoor) > 0)
        {
            Anim_OpenDoorL();            
        }
        else
        {
            Anim_OpenDoorR();
        }        
    }
    else
    {
        Anim_OpenDoor();
    }
    GotoXParms.Mode = 6;
    GotoXParms.MyDoorEx.Used(self, self);
    GotoXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
    return;
}

function Anim_OpenDoor()
{
    PlayAnim('Anim_Idle');
    return;
}

function Anim_OpenDoorL()
{
    Anim_OpenDoor();
    return;
}

function Anim_OpenDoorR()
{
    Anim_OpenDoor();
    return;
}

animevent simulated function DoorPush(optional EventInfo EventParms)
{
    // End:0x09
    if(DebugDoors)
    {
    }
    // End:0x31
    if(GotoXParms.MyDoorEx == none)
    {
        GotoXParms.MyDoorEx.Used(self, self);
    }
    return;
}

event Engine.BaseAI.EAICode CanUseState_GotoActor(Actor TargetActor, Actor RefActor, Engine.BaseAI.EAIOffsetType OffsetType, float Range, float Bearing, float Height, float ClipTolerance, Engine.BaseAI.EAIFocus Focus, Actor FocusActor, int MaxSteps, optional bool bDebug, optional Vector TargetExtent)
{
    local Engine.BaseAI.EAICode Code;
    local Vector NextPathPos;
    local int FinalDest;

    Code = GotoXTargetsValid(2, TargetActor, Focus, FocusActor);
    PathInfo.TargetExtent = TargetExtent;
    PathInfo.PathCacheID = -1;
    // End:0x5D
    if(Range == 0)
    {
        Range = GetDefaultGotoXRange(Range);
    }
    // End:0xA4
    if(int(Code) == int(0))
    {
        Code = CanGotoActorOffset(TargetActor, RefActor, OffsetType, Range, Bearing, Height, ClipTolerance, NextPathPos, FinalDest);
    }
    // End:0x218
    if(int(Code) == int(0))
    {
        GotoXParms.TargetType = 2;
        GotoXParms.TargetActor = TargetActor;
        GotoXParms.TargetPos = TargetActor.Location;
        GotoXParms.RefActor = RefActor;
        GotoXParms.NextPos = NextPathPos;
        GotoXParms.FinalDest = FinalDest;
        GotoXParms.OffsetType = OffsetType;
        GotoXParms.Range = Range;
        GotoXParms.Bearing = Bearing;
        GotoXParms.Height = Height;
        GotoXParms.ClipTolerance = ClipTolerance;
        GotoXParms.Focus = Focus;
        GotoXParms.FocusActor = FocusActor;
        GotoXParms.MaxSteps = MaxSteps;
        GotoXParms.PreVerified = true;
        GotoXParms.ForceEval = true;
        GotoXParms.EvalGate = 0;
        GotoXParms.EvalGateTime = Level.GameTimeSeconds;
        GotoXParms.EvalCount = 0;
        GotoXParms.bDebug = bDebug;
        GotoXParms.TargetExtent = TargetExtent;
        GotoXParms.ExitOnLand = false;
    }
    // End:0x2DA
    if((int(Code) != int(0)) && int(Code) != int(9))
    {
        // End:0x2DA
        if(bDebug)
        {
            BroadcastLog((((string(self) $ " could NOT path to Actor! TargetActor: ") $ string(TargetActor)) $ ". CanGotoActorOffset returned: ") $ string(DynamicLoadObject(class'EAICode', int(Code))));
            GetSlotVolume(Location, TargetActor.Location, NewColorBytes(255, 0, 0), 10);
        }
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_GotoPos(Vector TargetPos, Actor RefActor, float Range, float Height, float ClipTolerance, Engine.BaseAI.EAIFocus Focus, Actor FocusActor, int MaxSteps, optional bool bDebug, optional Vector TargetExtent)
{
    local Engine.BaseAI.EAICode Code;
    local Vector NextPathPos;
    local int FinalDest;

    Code = GotoXTargetsValid(1, none, Focus, FocusActor);
    PathInfo.TargetExtent = TargetExtent;
    PathInfo.PathCacheID = -1;
    // End:0x59
    if(Range == 0)
    {
        Range = GetDefaultGotoXRange(Range);
    }
    // End:0x96
    if(int(Code) == int(0))
    {
        Code = CanGotoPos(TargetPos, RefActor, Range, Height, ClipTolerance, NextPathPos, FinalDest);
    }
    // End:0x1E7
    if(int(Code) == int(0))
    {
        GotoXParms.TargetType = 1;
        GotoXParms.TargetPos = TargetPos;
        GotoXParms.RefActor = RefActor;
        GotoXParms.NextPos = NextPathPos;
        GotoXParms.FinalDest = FinalDest;
        GotoXParms.TargetActor = none;
        GotoXParms.OffsetType = 0;
        GotoXParms.Range = Range;
        GotoXParms.Bearing = 0;
        GotoXParms.Height = Height;
        GotoXParms.ClipTolerance = ClipTolerance;
        GotoXParms.Focus = Focus;
        GotoXParms.FocusActor = FocusActor;
        GotoXParms.MaxSteps = MaxSteps;
        GotoXParms.PreVerified = true;
        GotoXParms.ForceEval = false;
        GotoXParms.EvalGate = 1;
        GotoXParms.EvalGateTime = Level.GameTimeSeconds;
        GotoXParms.EvalCount = 0;
        GotoXParms.TargetExtent = TargetExtent;
        GotoXParms.ExitOnLand = false;
    }
    // End:0x206
    if(DebugGotoX)
    {
        DrawDiamond(TargetPos, 0, 0, 255, 255, 3);
    }
    // End:0x2B7
    if((int(Code) != int(0)) && int(Code) != int(9))
    {
        // End:0x2B7
        if(bDebug)
        {
            BroadcastLog((((string(self) $ " could NOT path to position! TargetPos: ") $ string(TargetPos)) $ ". CanGotoPos returned: ") $ string(DynamicLoadObject(class'EAICode', int(Code))));
            GetSlotVolume(Location, TargetPos, NewColorBytes(255, 0, 0), 10);
        }
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_GotoLandPos(Vector GoalPos, Actor FocusActor)
{
    local Engine.BaseAI.EAICode Code;
    local Vector NextPathPos;
    local int FinalDest;
    local float Range, Height, ClipTolerance;

    Code = GotoXTargetsValid(1, none, 4, FocusActor);
    ClipTolerance = CollisionRadius + 60;
    Range = GetDefaultGotoXRange(Range);
    PathInfo.TargetExtent = Vect(0, 0, 0);
    PathInfo.PathCacheID = -1;
    // End:0x9E
    if(int(Code) == int(0))
    {
        Code = CanGotoPos(GoalPos, none, Range, Height, ClipTolerance, NextPathPos, FinalDest);
    }
    // End:0x1F0
    if(int(Code) == int(0))
    {
        GotoXParms.TargetType = 1;
        GotoXParms.TargetPos = GoalPos;
        GotoXParms.RefActor = none;
        GotoXParms.NextPos = NextPathPos;
        GotoXParms.FinalDest = FinalDest;
        GotoXParms.TargetActor = none;
        GotoXParms.OffsetType = 0;
        GotoXParms.Range = Range;
        GotoXParms.Bearing = 0;
        GotoXParms.Height = Height;
        GotoXParms.ClipTolerance = ClipTolerance;
        GotoXParms.Focus = 4;
        GotoXParms.FocusActor = FocusActor;
        GotoXParms.MaxSteps = 0;
        GotoXParms.PreVerified = true;
        GotoXParms.ForceEval = false;
        GotoXParms.EvalGate = 1;
        GotoXParms.EvalGateTime = Level.GameTimeSeconds;
        GotoXParms.EvalCount = 0;
        GotoXParms.TargetExtent = Vect(0, 0, 0);
        GotoXParms.ExitOnLand = true;
    }
    return Code;
    return;
}

event float GetDefaultGotoXRange(float Range)
{
    return 0;
    return;
}

event float GetDefaultGotoXHeight()
{
    return 0;
    return;
}

event bool ExecuteState_GotoX(Engine.BaseAI.EAIMoveSpeed Speed, float SideArcTurnSpeedThresh, float StepBackwardsSpeedThresh, float StartAngleSideSector, float StartAngleBackSector, float MoveBackwardsDistThresh, float SideStepDistThresh)
{
    local bool StartedState;

    GotoXParms.Speed = Speed;
    GotoXParms.SpeedScale = GetSpeedScale(Speed);
    GotoXParms.FacePos = GotoXParms.TargetPos;
    GotoXParms.RefId = -1;
    GotoXParms.Mode = 0;
    GotoXParms.SideArcTurnSpeedThresh = SideArcTurnSpeedThresh;
    GotoXParms.StepBackwardsSpeedThresh = StepBackwardsSpeedThresh;
    GotoXParms.StartAngleSideSector = StartAngleSideSector;
    GotoXParms.StartAngleBackSector = StartAngleBackSector;
    GotoXParms.MoveBackwardsDistThresh = CollisionRadius * 2;
    GotoXParms.SideStepDistThresh = SideStepDistThresh;
    GotoXParms.MyDoorEx = none;
    GotoXParms.StuckTime = -1;
    GotoXParms.ConstraintStrengthOverride = -1;
    PhysicsParms.bDisablePhysicsConstraints = false;
    GotoXParms.EvalGate = 1;
    GotoXParms.EvalGateTime = Level.GameTimeSeconds;
    GotoXParms.EvalCount = 0;
    GotoXParms.bWaitingOnDynamicBlocker = false;
    // End:0x160
    if(GotoXParms.Height == 0)
    {
        GotoXParms.Height = GetDefaultGotoXHeight();
    }
    StartedState = ExecuteState('GotoX');
    // End:0x181
    if(bGotoXTracking)
    {
        CacheGotoXHistory();
    }
    // End:0x209
    if(((((int(Speed) != int(1)) && ! IsNotFinal('GotoX') || int(GotoXParms.Speed) == int(1)) && WalkDistThresh > 0) && GotoXParms.FinalDest > 0) && VSizeSquared(GotoXParms.NextPos - Location) <= (WalkDistThresh * WalkDistThresh))
    {
        GotoXParms.Speed = 1;
    }
    return StartedState;
    return;
}

function Engine.BaseAI.EAICode GotoXTargetsValid(Engine.BaseAI.EAITargetType TargetType, Actor TargetActor, Engine.BaseAI.EAIFocus Focus, Actor FocusActor)
{
    // End:0x1F
    if((int(TargetType) == int(2)) && TargetActor != none)
    {
        return 4;
    }
    // End:0x4C
    if((int(Focus) == int(3)) || int(Focus) == int(4))
    {
        // End:0x4C
        if(FocusActor != none)
        {
            return 6;
        }
    }
    return 0;
    return;
}

event bool ShouldSnapToDestination()
{
    return GotoXParms.FinalDest > 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_Haywire(float MinDuration, float MaxDuration, Vector LinearAccel, Vector LinearAccelVar, Vector AngularAccel, Vector AngularAccelVar)
{
    HaywireParms.MinTime = Level.GameTimeSeconds + MinDuration;
    HaywireParms.MaxTime = Level.GameTimeSeconds + MaxDuration;
    HaywireParms.LinearAccel = VVar(LinearAccel, LinearAccelVar);
    HaywireParms.AngularAccel = VVar(AngularAccel, AngularAccelVar);
    // End:0x95
    if(FRand() < 0.5)
    {
        HaywireParms.AngularAccel = - HaywireParms.AngularAccel;
    }
    return 0;
    return;
}

event bool ExecuteState_Haywire()
{
    return ExecuteState('Haywire');
    return;
}

event ExecuteHaywireExplode(Vector HitNormal)
{
    local Vector ExplosionLoc;
    local dnFriendFX_Spawners ExplosionActor;

    // End:0x86
    if(HaywireParms.ExplosionClass == none)
    {
        ExplosionActor = FindFriendSpawner(HaywireParms.ExplosionClass);
        // End:0x86
        if(ExplosionActor == none)
        {
            ExplosionLoc = Location;
            ExplosionActor.SetDesiredRotation(ExplosionLoc);
            ExplosionActor.DisableDesiredRotation_Roll(Rotator(HitNormal));
            ExplosionActor.RemoteRole = ROLE_None;
            ExplosionActor.ExecuteEffect(true);
        }
    }
    // End:0xC0
    if(HaywireParms.HurtRadiusDamage > float(0))
    {
        HurtRadius(HaywireParms.HurtRadiusDamage, Location, HaywireParms.DamageRadius, HaywireParms.DamageRadiusFallOffStart);
    }
    bInstaGib = true;
    InstaGibRandomImpulse = 10000;
    FindSoundAndSpeak(HaywireParms.ExplosionSoundName);
    return;
}

event bool ShouldHaywireExplode()
{
    // End:0x3D
    if((Level.GameTimeSeconds - HaywireParms.HaywireStartTime) > HaywireParms.MinTimeToExplode)
    {
        // End:0x3D
        if(HaywireParms.ChanceExplosion > FRand())
        {
            return true;
        }
    }
    return false;
    return;
}

event Engine.BaseAI.EAICode CanUseState_Hide()
{
    return 0;
    return;
}

event bool ExecuteState_Hide()
{
    return ExecuteState('Hide');
    return;
}

event Engine.BaseAI.EAICode CanUseState_Jump(Vector JumpVel, float HeavyLandingThresh, optional Actor FocusActor, optional float FlyingGravityScale, optional float JumpTime, optional Vector TargetPos, optional int JumpType, optional bool bSnapToTargetDuringLand, optional bool bUseAccelaration, optional bool bFaceTarget)
{
    JumpParms.JumpVel = JumpVel;
    JumpParms.HeavyLandingThresh = HeavyLandingThresh;
    JumpParms.FocusActor = FocusActor;
    JumpParms.bTakeOffNoLand = false;
    JumpParms.ExitTime = JumpTime;
    JumpParms.AnimSet = JumpType;
    JumpParms.FlyingGravityScale = FlyingGravityScale;
    JumpParms.TargetPos = TargetPos;
    JumpParms.bSnapToTargetDuringLand = bSnapToTargetDuringLand;
    JumpParms.bUseAccelaration = bUseAccelaration;
    JumpParms.FaceTarget = bFaceTarget;
    // End:0xE8
    if(TargetPos == Vect(0, 0, 0))
    {
        JumpParms.bCheckTargetPos = false;
        JumpParms.bSnapToTargetDuringLand = false;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpTakeOff(Vector JumpVel, float TakeOffIdleTime, optional Actor FocusActor, optional float GravityScale, optional Vector TakeOffTarget)
{
    JumpParms.JumpVel = JumpVel;
    JumpParms.HeavyLandingThresh = HeavyLandingThresh;
    JumpParms.FocusActor = FocusActor;
    JumpParms.bTakeOffNoLand = true;
    JumpParms.ExitTime = 0;
    JumpParms.TakeOffIdleTime = TakeOffIdleTime;
    JumpParms.AnimSet = 1;
    JumpParms.FlyingGravityScale = GravityScale;
    JumpParms.TargetPos = TakeOffTarget;
    JumpParms.FaceTarget = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpToTargetPos()
{
    return;
}

event bool ExecuteState_Jump()
{
    // End:0x2C
    if(JumpParms.ExitTime > float(0))
    {
        JumpParms.ExitTime += Level.GameTimeSeconds;
    }
    JumpParms.bSnapActive = false;
    JumpParms.bLandAnimComplete = false;
    // End:0x76
    if(JumpParms.TargetPos == Vect(0, 0, 0))
    {
        JumpParms.bRequireCompleteSnap = false;        
    }
    else
    {
        JumpParms.bRequireCompleteSnap = true;
    }
    return ExecuteState('Jump');
    return;
}

function UpdateTakeOff(float DeltaSecs)
{
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpAttack()
{
    // End:0x11
    if(JumpAttackParms.bDisabled)
    {
        return 1;
    }
    JumpAttackParms.PresetFrameVelocity = Vect(0, 0, 0);
    JumpAttackParms.bInstantJump = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpAttackDodge()
{
    // End:0x11
    if(JumpAttackParms.bDisabled)
    {
        return 1;
    }
    JumpAttackParms.PresetFrameVelocity = DodgeInfo[DodgeIndex].PhysicsFrameVelocity >> Rotation;
    JumpAttackParms.bInstantJump = false;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpAttackPresetInstant(Vector PresetVelocity)
{
    // End:0x11
    if(JumpAttackParms.bDisabled)
    {
        return 1;
    }
    JumpAttackParms.PresetFrameVelocity = PresetVelocity;
    JumpAttackParms.bInstantJump = true;
    JumpAttackParms.TargetActor = none;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_JumpAttackPreset(Vector PresetVelocity)
{
    // End:0x11
    if(JumpAttackParms.bDisabled)
    {
        return 1;
    }
    JumpAttackParms.PresetFrameVelocity = PresetVelocity;
    JumpAttackParms.bInstantJump = false;
    JumpAttackParms.TargetActor = none;
    return 0;
    return;
}

event bool ExecuteState_JumpAttack(Actor TargetActor, int Type, bool AttackOnTakeoff)
{
    JumpAttackParms.TargetActor = TargetActor;
    JumpAttackParms.Type = Type;
    JumpAttackParms.AttackOnTakeoff = AttackOnTakeoff;
    JumpAttackParms.Gate = Level.GameTimeSeconds + JumpAttackParms.MinInterval;
    JumpAttackParms.GroundFinderGate = Level.GameTimeSeconds + JumpAttackParms.GroundFinderInterval;
    return ExecuteState('JumpAttack');
    return;
}

event StateJumpAttack_Apply(out Vector MyJumpVel)
{
    // End:0x28
    if(VSizeSquared(JumpAttackParms.PresetFrameVelocity) > 0)
    {
        MyJumpVel = JumpAttackParms.PresetFrameVelocity;
        return;
    }
    CalcJumpAttackVelocity(JumpAttackParms.TargetActor, MyJumpVel);
    FindSoundAndSpeak('Sound_JumpAttack');
    return;
}

event bool ShouldJumpAttackShrunk(Actor Target)
{
    // End:0x3F
    if((Target.bIsPawn && Pawn(Target).PhysController_SetGroundConstraintDirection()) || Corpse(Target) == none)
    {
        return true;
    }
    return false;
    return;
}

event Vector GetJumpAttackTargetPos(Actor TargetActor)
{
    local Pawn pawnTarget;

    // End:0x23
    if(TargetActor.bIsPawn)
    {
        pawnTarget = Pawn(TargetActor);
    }
    // End:0x40
    if(pawnTarget == none)
    {
        return pawnTarget.FindInventoryTypeByName();        
    }
    else
    {
        return TargetActor.Location + Vect(0, 0, TargetActor.CollisionHeight * 0.66);
    }
    return;
}

event float CalcJumpAttackHeight(Actor TargetActor)
{
    local float Dist, Height;

    // End:0x35
    if((JumpAttackParms.ParabolaMinJumpHeight == 0) && JumpAttackParms.ParabolaMaxJumpHeight == 0)
    {
        return JumpAttackParms.ParabolaJumpHeight;
    }
    // End:0x61
    if(PrimaryTarget.IsValidTarget())
    {
        Dist = PrimaryTarget.GetDist2D();        
    }
    else
    {
        Dist = VSize(TargetActor.Location - Location);
    }
    Height = CalcMapRange(Dist, MinJumpAttackRange, MaxJumpAttackRange, JumpAttackParms.ParabolaMinJumpHeight, JumpAttackParms.ParabolaMaxJumpHeight);
    return Height;
    return;
}

event Engine.BaseAI.EAICode CanUseState_MoveUnderground(Vector DestLocation, Rotator DestRotation, float Time)
{
    MoveUndergroundParms.DestLocation = DestLocation;
    MoveUndergroundParms.DestRotation = DestRotation;
    MoveUndergroundParms.StartTime = Level.GameTimeSeconds;
    MoveUndergroundParms.Duration = Time;
    return 0;
    return;
}

event bool ExecuteState_MoveUnderground()
{
    return ExecuteState('MoveUnderground');
    return;
}

event Engine.BaseAI.EAICode CanUseState_Pause(float Time)
{
    PauseParms.Time = Time;
    return 0;
    return;
}

event bool ExecuteState_Pause()
{
    return ExecuteState('Pause');
    return;
}

event Engine.BaseAI.EAICode CanUseState_PlaceTripMine(Actor TargetActor)
{
    // End:0x0C
    if(IsWeaponAimerOn())
    {
        return 77;
    }
    // End:0x1B
    if(Weapon != none)
    {
        return 29;
    }
    // End:0x46
    if((int(AnimCtrl.m_eController) != int(5)) && int(AnimCtrl.m_eController) != int(1))
    {
        return 39;
    }
    PlaceTripMineParms.TargetActor = TargetActor;
    return 0;
    return;
}

event bool ExecuteState_PlaceTripMine()
{
    return ExecuteState('PlaceTripMine');
    return;
}

event Engine.BaseAI.EAICode CanUseState_PhysicsGotoTargetActor()
{
    // End:0x26
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 4;
    }
    return 0;
    return;
}

event bool ExecuteState_PhysicsGotoX()
{
    return ExecuteState('PhysicsGotoX');
    return;
}

event Engine.BaseAI.EAICode CanUseState_SelectWeapon(class<Weapon> DesiredWeaponClass, optional bool QuickWeaponSwitch)
{
    local Engine.BaseAI.EAICode Code;
    local class<Weapon> CurrentWeaponClass;
    local Weapon InvWeapon;
    local int LoadedAmmo, TotalAmmo;

    Code = 1;
    GetCurrentWeapon(CurrentWeaponClass, LoadedAmmo, TotalAmmo);
    // End:0x5C
    if(((DesiredWeaponClass != CurrentWeaponClass) || DesiredWeaponClass != class'IntegratedWeapon') || CurrentWeaponClass != class'IntegratedWeapon')
    {
        Code = 12;        
    }
    else
    {
        // End:0x83
        if(DesiredWeaponClass != none)
        {
            Code = 0;
            SelectWeaponParms.NewWeaponClass = DesiredWeaponClass;            
        }
        else
        {
            Code = 0;
            SelectWeaponParms.NewWeaponClass = DesiredWeaponClass;
        }
    }
    SelectWeaponParms.QuickSwitch = QuickWeaponSwitch;
    return Code;
    return;
}

event bool ExecuteState_SelectWeapon()
{
    return ExecuteState('SelectWeapon');
    return;
}

event Engine.BaseAI.EAICode CanUseState_SetAim(bool On)
{
    local Engine.BaseAI.EAICode Code;
    local Engine.BaseAI.EAIAim CurrentState;

    Code = 1;
    // End:0x1E
    if(! HasWeaponAimer)
    {
        Code = 24;        
    }
    else
    {
        CurrentState = GetWeaponAimerState();
        // End:0x64
        if(On)
        {
            // End:0x59
            if(int(CurrentState) == int(0))
            {
                Code = 0;
                SetAimParms.DesiredState = 1;                
            }
            else
            {
                Code = 15;
            }            
        }
        else
        {
            // End:0x8A
            if(int(CurrentState) == int(1))
            {
                Code = 0;
                SetAimParms.DesiredState = 0;                
            }
            else
            {
                Code = 16;
            }
        }
    }
    return Code;
    return;
}

event bool ExecuteState_SetAim(float Time)
{
    SetAimParms.Time = Time;
    return ExecuteState('SetAim');
    return;
}

event Engine.BaseAI.EAICode CanUseState_SetFireMode(bool On, bool Expedite)
{
    local Engine.BaseAI.EAICode Code;
    local bool IsHoldingFire, FireOff;

    Code = 1;
    Expedite = true;
    // End:0x30
    if(! HasWeaponManager)
    {
        SetFireModeParms.On = On;
        return 0;
    }
    // End:0x41
    if(! WeaponIsActive())
    {
        return Code;
    }
    IsHoldingFire = WeaponManagerHoldingFire();
    FireOff = WeaponManagerCompletelyOff();
    SetFireModeParms.Done = false;
    // End:0xA5
    if(On)
    {
        // End:0x95
        if(IsHoldingFire || FireOff)
        {
            SetFireModeParms.Done = false;            
        }
        else
        {
            SetFireModeParms.Done = true;
        }        
    }
    else
    {
        // End:0xCD
        if(! IsHoldingFire || ! FireOff)
        {
            SetFireModeParms.Done = false;            
        }
        else
        {
            SetFireModeParms.Done = true;
        }
    }
    SetFireModeParms.On = On;
    SetFireModeParms.Expedite = Expedite;
    return 0;
    return;
}

event bool ExecuteState_SetFireMode()
{
    return ExecuteState('SetFireMode');
    return;
}

event SetFireModeDontIdle(bool bDontPlayIdle)
{
    SetFireModeParms.DontIdle = bDontPlayIdle;
    return;
}

event Engine.BaseAI.EAICode CanUseState_Stun(float Time)
{
    PauseParms.Time = Time;
    return 0;
    return;
}

event bool ExecuteState_Stun()
{
    return ExecuteState('Stun');
    return;
}

function bool ShouldUnStun()
{
    return true;
    return;
}

final function StunTimer()
{
    // End:0x14
    if(ShouldUnStun())
    {
        ExitAIState(2);        
    }
    else
    {
        TraceFire(PauseParms.Time, false, 'StunTimer');
    }
    return;
}

event Engine.BaseAI.EAICode CanUseState_TurnToActor(Actor TargetActor, float ShouldTurnThresh, float FaceThresh, float ExitTime, optional float AnimThresh)
{
    local Engine.BaseAI.EAICode Code;
    local Vector FacePos;

    Code = CanTurnToActor(TargetActor, ShouldTurnThresh, FacePos);
    // End:0xC8
    if(int(Code) == int(0))
    {
        TurnToXParms.TargetType = 2;
        TurnToXParms.TargetActor = TargetActor;
        TurnToXParms.FaceThreshold = FaceThresh;
        TurnToXParms.ExitTime = ExitTime;
        // End:0xAB
        if(AnimThresh != 0)
        {
            TurnToXParms.AnimThreshold = AnimThresh;
            TurnToXParms.PlayTurnAnim = ! FacingActor(TargetActor, AnimThresh, FacePos);            
        }
        else
        {
            TurnToXParms.PlayTurnAnim = true;
            TurnToXParms.AnimThreshold = 0;
        }
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_TurnToPos(Vector TargetPos, float ShouldTurnThresh, float FaceThresh, float ExitTime, optional float AnimThresh)
{
    local Engine.BaseAI.EAICode Code;
    local Vector FacePos;

    Code = CanTurnToPos(TargetPos, ShouldTurnThresh);
    // End:0xBE
    if(int(Code) == int(0))
    {
        TurnToXParms.TargetType = 1;
        TurnToXParms.TargetPos = TargetPos;
        TurnToXParms.FaceThreshold = FaceThresh;
        TurnToXParms.ExitTime = ExitTime;
        // End:0xA1
        if(AnimThresh != 0)
        {
            TurnToXParms.AnimThreshold = AnimThresh;
            TurnToXParms.PlayTurnAnim = ! FacingPos(TargetPos, AnimThresh);            
        }
        else
        {
            TurnToXParms.PlayTurnAnim = true;
            TurnToXParms.AnimThreshold = 0;
        }
    }
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_TurnToTarget(Engine.BaseAI.EAITarget Targ, float ShouldTurnThresh, float FaceThresh, float ExitTime, optional float AnimThresh)
{
    local Engine.BaseAI.EAICode Code;
    local Vector FacePos;

    // End:0x26
    if(! GetTarget(Targ).IsValidTarget())
    {
        Code = 4;        
    }
    else
    {
        FacePos = GetTarget(Targ).GetPos();
        Code = CanTurnToPos(FacePos, ShouldTurnThresh);
        // End:0x100
        if(int(Code) == int(0))
        {
            TurnToXParms.TargetType = 3;
            TurnToXParms.TargetPos = FacePos;
            TurnToXParms.FaceThreshold = FaceThresh;
            TurnToXParms.ExitTime = ExitTime;
            // End:0xE3
            if(AnimThresh != 0)
            {
                TurnToXParms.AnimThreshold = AnimThresh;
                TurnToXParms.PlayTurnAnim = ! FacingPos(FacePos, AnimThresh);                
            }
            else
            {
                TurnToXParms.PlayTurnAnim = true;
                TurnToXParms.AnimThreshold = 0;
            }
        }
    }
    return Code;
    return;
}

event bool ExecuteState_TurnToX()
{
    // End:0x16
    if(bNeverPlayerTurnAnim)
    {
        TurnToXParms.PlayTurnAnim = false;
    }
    return ExecuteState('TurnToX');
    return;
}

event FinalizeTurn(Vector FacePos)
{
    local Rotator NewRotation;
    local Vector DirTo;

    NewRotation = Rotation;
    DirTo = FacePos - Location;
    NewRotation.Yaw = Rotator(DirTo).Yaw;
    DisableDesiredRotation_Roll(NewRotation);
    return;
}

event Engine.BaseAI.EAICode CanUseState_UseX(Actor TargetActor, name InputDispatcherTag, name AttachedEvent, int Attempts, float AttemptInterval, optional bool ForceAttach, optional bool AllowProceduralAim)
{
    local Engine.BaseAI.EAICode Code;
    local dnUsableSomething UsableSomething;

    Code = 0;
    // End:0x1C
    if(UseXParms.TargetActor == none)
    {
        return 0;
    }
    UseXParms.TargetActor = InteractiveActor(TargetActor);
    UsableSomething = dnUsableSomething(UseXParms.TargetActor);
    // End:0x55
    if(UsableSomething != none)
    {
        return 1;
    }
    // End:0x9E
    if((UsableSomething.User == none) || (UsableSomething.AIReserved == none) && UsableSomething.AIReserved == self)
    {
        return 1;
    }
    // End:0xBA
    if(UseXParms.TargetActor != none)
    {
        Code = 1;        
    }
    else
    {
        UseXParms.InputDispatcher = none;
        // End:0xF5
        if(NameForString(InputDispatcherTag, 'None'))
        {
            // End:0xF4
            foreach RotateVectorAroundAxis(class'AIInputDispatcher_Base', UseXParms.InputDispatcher, InputDispatcherTag)
            {
                // End:0xF4
                break;                
            }            
        }
        // End:0x13D
        if((UseXParms.InputDispatcher != none) || ! UseXParms.InputDispatcher.CanUse(UseXParms.TargetActor, self, PrimaryTargetActor))
        {
            Code = 1;            
        }
        else
        {
            UseXParms.InputDispatcher.MyActor = self;
            UseXParms.AttachedEvent = AttachedEvent;
            UseXParms.Attempts = Attempts;
            UseXParms.AttemptInterval = AttemptInterval;
            UseXParms.ForceAttach = ForceAttach;
            UseXParms.AllowProceduralAim = AllowProceduralAim;
            UseXParms.Using = false;
        }
    }
    UsableSomething.AIReserved = self;
    UseXParms.bAttached = false;
    UseXParms.bDetaching = false;
    return Code;
    return;
}

event Engine.BaseAI.EAICode CanUseState_UseXExplicit(dnUsableSomething UsableSomething, AIInputDispatcher_Base InputDispatcher)
{
    local Engine.BaseAI.EAICode Code;

    // End:0x1D
    if((UsableSomething != none) || InputDispatcher != none)
    {
        return 1;
    }
    // End:0x66
    if((UsableSomething.User == none) || (UsableSomething.AIReserved == none) && UsableSomething.AIReserved == self)
    {
        return 1;
    }
    // End:0x91
    if(! InputDispatcher.CanUse(UsableSomething, self, PrimaryTargetActor))
    {
        Code = 1;        
    }
    else
    {
        Code = 0;
        UseXParms.TargetActor = UsableSomething;
        UseXParms.InputDispatcher = InputDispatcher;
        UseXParms.InputDispatcher.MyActor = self;
        UseXParms.AttachedEvent = 'None';
        UseXParms.Attempts = 1;
        UseXParms.AttemptInterval = 0.5;
        UseXParms.ForceAttach = false;
        UseXParms.Using = false;
        UsableSomething.AIReserved = self;
        UseXParms.bAttached = false;
        UseXParms.bDetaching = false;
    }
    return Code;
    return;
}

event bool ExecuteState_UseX()
{
    return ExecuteState('UseX');
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveFlank(optional float ExitTime)
{
    FreeMoveParms.Mode = 1;
    FreeMoveParms.MinDotToTarget = -1;
    FreeMoveParms.MaxDotToTarget = -0.7;
    FreeMoveParms.ExitTime = ExitTime;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveCircleStrafe(optional float ExitTime)
{
    FreeMoveParms.Mode = 0;
    FreeMoveParms.MinDotToTarget = 0;
    FreeMoveParms.MaxDotToTarget = 0;
    FreeMoveParms.ExitTime = ExitTime;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveFloat(optional float ExitTime)
{
    FreeMoveParms.Mode = 2;
    FreeMoveParms.MinDotToTarget = 0;
    FreeMoveParms.MaxDotToTarget = 0;
    FreeMoveParms.ExitTime = ExitTime;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveHover(optional float ExitTime)
{
    FreeMoveParms.Mode = 4;
    FreeMoveParms.MinDotToTarget = 0;
    FreeMoveParms.MaxDotToTarget = 0;
    FreeMoveParms.ExitTime = ExitTime;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveRest(optional float ExitTime)
{
    FreeMoveParms.Mode = 6;
    FreeMoveParms.ExitTime = ExitTime;
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveCharge(optional float ExitTime)
{
    local Vector Extent;

    FreeMoveParms.Mode = 3;
    FreeMoveParms.MinDotToTarget = 0;
    FreeMoveParms.MaxDotToTarget = 0;
    FreeMoveParms.ExitTime = ExitTime;
    // End:0x63
    if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
    {
        return 1;
    }
    Extent = Vect(CollisionRadius, CollisionRadius, CollisionHeight);
    // End:0xDA
    if(ChargeParms.RequireLOS && ! ClearShot(PrimaryTargetActor, Location, PrimaryTarget.GetAimPos() + Vect(0, 0, CollisionHeight / 2), 3, 0, true, Extent, true))
    {
        return 27;
    }
    return 0;
    return;
}

event Engine.BaseAI.EAICode CanUseState_FreeMoveGoto(Vector TargetPos, float ExitTime)
{
    FreeMoveParms.Mode = 5;
    FreeMoveParms.FreeMoveTarget = TargetPos;
    FreeMoveParms.ExitTime = ExitTime;
    return;
}

event bool ExecuteState_FreeMove()
{
    // End:0x2C
    if(FreeMoveParms.ExitTime != float(0))
    {
        FreeMoveParms.ExitTime += Level.GameTimeSeconds;
    }
    return ExecuteState('FreeMove');
    return;
}

function Anim_DrawWeapon(class<Weapon> NewWeaponClass)
{
    local name AnimName;
    local int iIndex;

    AnimName = EvaluateCompare('Anim_Draw', GetWeaponAnimName(NewWeaponClass));
    iIndex = AnimCtrl.m_oController.GetNumberOfCachedAnimSequences(AnimName);
    SetScaleModifier().IsMyDigs(AnimCtrl.m_oController.Animations[iIndex].AnimSequence);
    PlayAnim(AnimName,,, true);
    return;
}

function Anim_EyesBlink(int nEyeSet)
{
    local name fnAnimName;

    fnAnimName = CompositeNames(string('Anim_EyesBlink') $ string(nEyeSet));
    PlayAnim(fnAnimName);
    return;
}

function Anim_EyesClose(int nEyeSet)
{
    local name fnAnimName;

    fnAnimName = CompositeNames(string('Anim_EyesClose') $ string(nEyeSet));
    PlayAnim(fnAnimName);
    return;
}

function name CalcTurnAnim(Vector FacePos, out int TurnDir, optional bool LowerBodyOnly)
{
    local Vector Fwd, Right, Up, DirToFaceTarget;
    local float FaceTargetDotFwd, FaceTargetDotRight;
    local name AnimName;

    GetAxes(Rotation, Fwd, Right, Up);
    DirToFaceTarget = Normal(FacePos - Location);
    FaceTargetDotRight = DirToFaceTarget Dot Right;
    // End:0x75
    if(int(GetCurrentOp()) == int(17))
    {
        // End:0x68
        if(FaceTargetDotRight <= 0)
        {
            TurnDir = 1;
            return 'Anim_FireTurnLeft';
        }
        TurnDir = 0;
        return 'Anim_FireTurnRight';
    }
    FaceTargetDotFwd = DirToFaceTarget Dot Fwd;
    // End:0x9E
    if(LowerBodyOnly)
    {
        AnimName = 'Anim_TurnLower';        
    }
    else
    {
        AnimName = 'Anim_Turn';
    }
    // End:0x101
    if(FaceTargetDotFwd >= 0)
    {
        // End:0xE4
        if(FaceTargetDotRight <= 0)
        {
            TurnDir = 1;
            AnimName = EvaluateCompare(AnimName, 'Left45');            
        }
        else
        {
            TurnDir = 0;
            AnimName = EvaluateCompare(AnimName, 'Right45');
        }        
    }
    else
    {
        // End:0x12D
        if(FaceTargetDotRight <= 0)
        {
            TurnDir = 1;
            AnimName = EvaluateCompare(AnimName, 'Left180');            
        }
        else
        {
            TurnDir = 0;
            AnimName = EvaluateCompare(AnimName, 'Right180');
        }
    }
    return AnimName;
    return;
}

function Anim_StartFall(int nType)
{
    PlayAnim(CompositeNames(string('Anim_StartFall') $ string(nType)));
    return;
}

function Anim_Fall(int nType)
{
    PlayAnim(CompositeNames(string('Anim_Fall') $ string(nType)));
    return;
}

function Anim_HeavyLanding(int nType)
{
    PlayAnim(CompositeNames(string('Anim_HeavyLand') $ string(nType)));
    return;
}

function Anim_HolsterWeapon(Weapon MyWeapon)
{
    local name WeaponName, AnimName;
    local float fAnimTime;
    local int iIndex;

    WeaponName = MyWeapon.GetWeaponAnimName();
    AnimName = CompositeNames(string('Anim_Holster') $ string(WeaponName));
    iIndex = AnimCtrl.m_oController.GetNumberOfCachedAnimSequences(AnimName);
    fAnimTime = SetScaleModifier().IsMyDigs(AnimCtrl.m_oController.Animations[iIndex].AnimSequence);
    WeaponAimerRemoveTarget(true, fAnimTime);
    PlayAnim(AnimName,,, true);
    return;
}

function bool Anim_QuickSwitchWeapon(class<Weapon> NewWeaponClass)
{
    local name AnimName;

    AnimName = EvaluateCompare('Anim_QuickSwitchTo', GetWeaponAnimName(NewWeaponClass));
    BroadcastLog("DCR AnimName=" $ string(AnimName));
    return PlayAnim(AnimName);
    return;
}

function Anim_Hurl()
{
    local name AnimName;

    // End:0x3B
    if(Weapon == none)
    {
        AnimName = EvaluateCompare('Anim_HurlBarrel', Weapon.GetWeaponAnimName());
        PlayAnim(AnimName,,, true);        
    }
    else
    {
        PlayAnim('Anim_HurlBarrel',,, true);
    }
    return;
}

function Anim_Idle()
{
    PlayAnim(GetIdleAnimName());
    return;
}

event name GetMeleeAttackAnimName()
{
    return 'Anim_Attack';
    return;
}

event name GetShootProjectileAnimName()
{
    return 'Anim_ShootProjectile';
    return;
}

event name GetIdleAnimName()
{
    // End:0x22
    if(bUseWeaponReadyIdle && ShouldUseWeaponActiveIdle())
    {
        bWeaponActiveAnimsActive = true;
        return 'Anim_IdleReady';
    }
    bWeaponActiveAnimsActive = false;
    return 'Anim_Idle';
    return;
}

function Anim_IdleLower()
{
    PlayAnim('Anim_LowerIdle');
    return;
}

function Anim_JumpAttack(int nType)
{
    local name AnimName;

    AnimName = CompositeNames(string('Anim_JumpAttack') $ string(nType));
    PlayAnim(AnimName);
    return;
}

function Anim_JumpStart(int nType)
{
    local name AnimName;

    AnimName = CompositeNames(string('Anim_Jump') $ string(nType));
    PlayAnim(AnimName);
    return;
}

function Anim_Landing(int nType)
{
    local name AnimName;

    AnimName = CompositeNames(string('Anim_Land') $ string(nType));
    PlayAnim(AnimName);
    return;
}

function Anim_MoveTo(Engine.BaseAI.EAIMoveSpeed eMoveSpeed)
{
    switch(eMoveSpeed)
    {
        // End:0x16
        case 1:
            Anim_Walk();
            // End:0x7C
            break;
        // End:0x24
        case 2:
            Anim_Run();
            // End:0x7C
            break;
        // End:0xFFFF
        default:
            BroadcastLog("-- ERROR -- AIActor_EDF::Anim_MoveTo() - Unsupported eMoveSpeed: " $ string(eMoveSpeed));
            // End:0x7C
            break;
            break;
    }
    return;
}

function Anim_MoveTo_BackUp(Engine.BaseAI.EAIMoveSpeed eMoveSpeed)
{
    switch(eMoveSpeed)
    {
        // End:0x16
        case 1:
            Anim_WalkBackward();
            // End:0x83
            break;
        // End:0x24
        case 2:
            Anim_RunBackward();
            // End:0x83
            break;
        // End:0xFFFF
        default:
            BroadcastLog("-- ERROR -- AIActor_EDF::Anim_MoveTo_BackUp() - Unsupported eMoveSpeed: " $ string(eMoveSpeed));
            // End:0x83
            break;
            break;
    }
    return;
}

function Anim_MoveTo_StrafeLeft(Engine.BaseAI.EAIMoveSpeed eMoveSpeed)
{
    // End:0x30
    if((int(AnimCtrl.m_eController) == int(2)) || int(AnimCtrl.m_eController) == int(3))
    {
        Anim_Walk();
        return;
    }
    // End:0x4C
    if(int(eMoveSpeed) == int(1))
    {
        PlayAnim('Anim_SidestepLeft');        
    }
    else
    {
        // End:0x67
        if(! PlayAnim('Anim_StrafeLeft'))
        {
            PlayAnim('Anim_SidestepLeft');
        }
    }
    return;
}

function Anim_MoveTo_StrafeRight(Engine.BaseAI.EAIMoveSpeed eMoveSpeed)
{
    // End:0x30
    if((int(AnimCtrl.m_eController) == int(2)) || int(AnimCtrl.m_eController) == int(3))
    {
        Anim_Walk();
        return;
    }
    // End:0x4C
    if(int(eMoveSpeed) == int(1))
    {
        PlayAnim('Anim_SidestepRight');        
    }
    else
    {
        // End:0x67
        if(! PlayAnim('Anim_StrafeRight'))
        {
            PlayAnim('Anim_SidestepRight');
        }
    }
    return;
}

function Anim_Run()
{
    // End:0x2A
    if(bUseWeaponMovementAnims && ShouldUseWeaponActiveMovement())
    {
        bWeaponActiveAnimsActive = true;
        PlayAnim('Anim_RunReady');        
    }
    else
    {
        bWeaponActiveAnimsActive = false;
        PlayAnim('Anim_Run');
    }
    return;
}

function Anim_RunBackward()
{
    PlayAnim('Anim_RunBackwards');
    return;
}

function Anim_TurnTo(Vector vTurnDir)
{
    AnimCtrl.m_oController.PlayTurn(vTurnDir);
    return;
}

function Anim_TurnToPos(Vector vTurnTo)
{
    Anim_TurnTo(Normal(vTurnTo - self.Location));
    return;
}

function Anim_Walk()
{
    // End:0x2A
    if(bUseWeaponMovementAnims && ShouldUseWeaponActiveMovement())
    {
        bWeaponActiveAnimsActive = true;
        PlayAnim('Anim_WalkReady');        
    }
    else
    {
        bWeaponActiveAnimsActive = false;
        PlayAnim('Anim_Walk');
    }
    return;
}

function Anim_WalkBackward()
{
    PlayAnim('Anim_WalkBackwards');
    return;
}

animevent simulated function PlaySFX(optional EventInfo EventParms)
{
    FindSoundAndSpeak(CompositeNames(EventParms.EventString));
    return;
}

animevent simulated function HolsterWeapon(optional EventInfo AnimEventInfo)
{
    return;
}

animevent simulated function AnimEvent_ApplyJumpVelocity(optional EventInfo AnimEventInfo)
{
    return;
}

animevent simulated function JumpTakeoff(optional EventInfo AnimEventInfo)
{
    AnimEvent_ApplyJumpVelocity();
    return;
}

animevent simulated function BlastRelease(optional EventInfo AnimEventInfo)
{
    FireProjectile(ProjectileMuzzleName, ProjectileClass, CalcLeadTime(ProjectileClass.default.MaxSpeed), false);
    return;
}

animevent simulated function ShootProjectile(optional EventInfo AnimEventInfo)
{
    FireProjectile(ProjectileMuzzleName, ProjectileClass, CalcLeadTime(ProjectileClass.default.MaxSpeed), false);
    return;
}

animevent simulated function ScaledClawDamage(optional EventInfo AnimEventInfo)
{
    local float Scale;

    Scale = float(AnimEventInfo.EventString);
    ApplyDamage(class'MeleeDamage', int(ClawDamageAmount * Scale), ClawDamageVel * Scale, 4);
    return;
}

animevent simulated function ClawDamage(optional EventInfo AnimEventInfo)
{
    ApplyDamage(class'MeleeDamage', int(ClawDamageAmount), ClawDamageVel, 4);
    return;
}

animevent simulated function BiteDamage(optional EventInfo AnimEventInfo)
{
    ApplyDamage(class'BiteDamage', int(BiteDamageAmount), BiteDamageVel, 4);
    return;
}

animevent simulated function ApplyKickDamage(optional EventInfo AnimEventInfo)
{
    ApplyDamage(class'BiteDamage', int(KickDamageAmount), KickDamageVel, 4);
    return;
}

animevent simulated function StompDamage(optional EventInfo AnimEventInfo)
{
    DoStompDamage();
    return;
}

animevent simulated function ConstrainRootOnDeath(optional EventInfo AnimEventInfo)
{
    bFixCorpseRoot = true;
    return;
}

animevent simulated function KillMe(optional EventInfo AnimEventInfo)
{
    local AnimChanInfo ChannelInfo;

    // End:0x5E
    if(AnimEventInfo.EventString ~= "corpse")
    {
        DelayCorpseRagdoll = true;
        // End:0x5B
        if((SetScaleModifier() == none) && MeshInstance.GetAnimTime(0, 'Bottom'))
        {
            ChannelInfo = MeshInstance.IsMP(0, 'Bottom');
        }        
    }
    else
    {
        DelayCorpseRagdoll = false;
    }
    bNoDamage = false;
    Invulnerable = false;
    Died();
    // End:0xD1
    if(((MyCorpse == none) && DelayCorpseRagdoll) && ChannelInfo.Sequence != AnimEventInfo.EventAnim)
    {
        MyCorpse.SetGlobalAnimRate(AnimEventInfo.EventAnim,, ChannelInfo.FrameScale);
    }
    return;
}

animevent simulated function DropWeapon(optional EventInfo AnimEventInfo)
{
    SpawnPickupForWeapon();
    Level.Game.DiscardInventory(self);
    return;
}

animevent simulated function DropCarriedWeapon(optional EventInfo AnimEventInfo)
{
    local Weapon MyWeapon;
    local DualPistol MyDualPistol;

    SpawnPickupForWeapon();
    MyWeapon = GetWeapon();
    MyWeapon.RemoveTouchClass();
    return;
}

animevent simulated function DieOnAnimEnd(optional EventInfo AnimEventInfo)
{
    DieOnExitState = true;
    return;
}

animevent simulated function ForceDeath(optional EventInfo AnimEventInfo)
{
    Died();
    return;
}

function bool SetPawnCompositeWeaponAnimState(name fnNewAnimState, optional bool bForceReset)
{
    return;
}

simulated function bool UpdateWeaponAnimationState(Weapon SourceWeapon, byte NewWeaponState)
{
    local DualPistol MyDualPistol;

    // End:0xD8
    if((Weapon == none) && SourceWeapon != Weapon)
    {
        // End:0xB7
        if(! bDontPlayShootAnim && (int(NewWeaponState) == int(5)) || int(NewWeaponState) == int(4))
        {
            // End:0x5F
            if(! DisableAimGrids)
            {
                PlayAnim('Anim_ShootRefPose');
            }
            MyDualPistol = DualPistol(Weapon);
            // End:0xAC
            if(MyDualPistol == none)
            {
                // End:0x9E
                if(MyDualPistol.MuzzleFireIndex == 0)
                {
                    PlayAnim('Anim_ShootLeft');                    
                }
                else
                {
                    PlayAnim('Anim_ShootRight');
                }                
            }
            else
            {
                PlayAnim('Anim_Shoot');
            }
        }
        bDontPlayShootAnim = false;
        ForceNonDirectShot = false;
        return super(Pawn).UpdateWeaponAnimationState(SourceWeapon, NewWeaponState);
    }
    bDontPlayShootAnim = false;
    ForceNonDirectShot = false;
    return true;
    return;
}

simulated function MaybeFadeChannelBlock(name ChannelBlockName, float TargetAlpha, float FadeTime, optional bool bClearAnimsOnFinish)
{
    local float Alpha;

    // End:0x13
    if(AnimCtrl.m_oController != none)
    {
        return;
    }
    // End:0x47
    if((int(Role) == int(ROLE_Authority)) && IsMP())
    {
        ClientMaybeFadeChannelBlock(ChannelBlockName, TargetAlpha, FadeTime, bClearAnimsOnFinish);
    }
    Alpha = AnimCtrl.m_oController.AnimationFinished(ChannelBlockName);
    // End:0xC2
    if((Alpha != TargetAlpha) && AnimCtrl.m_oController.UpdateGlobalAnimRateScale(ChannelBlockName) != TargetAlpha)
    {
        AnimCtrl.m_oController.UpdateChannelBlendAlpha(ChannelBlockName, FadeTime, Alpha, TargetAlpha, bClearAnimsOnFinish);
    }
    return;
}

event bool ShouldUseWeaponActiveMovement()
{
    // End:0x2B
    if((WeaponActive()) && int(TargetInHorizRangeLimits(WeaponManager.MinRange, 999999.9)) == int(0))
    {
        return true;
    }
    return false;
    return;
}

event bool ShouldUseWeaponActiveIdle()
{
    // End:0x2B
    if((WeaponActive()) && int(TargetInHorizRangeLimits(WeaponManager.MinRange, 999999.9)) == int(0))
    {
        return true;
    }
    return false;
    return;
}

event bool WeaponActive()
{
    return (WeaponManager.CurrentWeaponClass == none) && ! WeaponManagerCompletelyOff();
    return;
}

event SetRefPose()
{
    // End:0x7F
    if((WeaponManager.CurrentWeaponClass == none) && ! WeaponManagerCompletelyOff())
    {
        // End:0x42
        if(! DisableAimGrids)
        {
            PlayAnim('Anim_ShootIdle');
            PlayAnim('Anim_ShootRefPose');            
        }
        else
        {
            // End:0x6B
            if(bUseWeaponIdle)
            {
                PlayAnim('Anim_ShootIdle');
                MaybeFadeChannelBlock('WeaponIdle', 1, 0.25);
            }
        }
        // End:0x7C
        if(WeaponManagerInFireLoop())
        {
            SetWeaponManagerMode(12);
        }        
    }
    else
    {
        // End:0xA3
        if(! DisableAimGrids)
        {
            PlayAnim('AnimClear_ShootRefPose');
            PlayAnim('AnimClear_ShootIdle');            
        }
        else
        {
            MaybeFadeChannelBlock('WeaponIdle', 0, 0.125, true);
        }
    }
    return;
}

event bool GetDeathAnimName(out name AnimName, out name FinishMeAnimName, out name FinishMeReviveAnimName, out float FinishMeTimeout, out int UseExactAnimName)
{
    local bool bRet;

    // End:0x96
    if(AnimCtrl.m_oController == none)
    {
        bRet = AnimCtrl.m_oController.GetDeathAnimName(DamageInfo.Part, int(DamageInfo.Damage), DamageInfo.Dir, AnimName, FinishMeAnimName, FinishMeReviveAnimName, FinishMeTimeout, UseExactAnimName);
        // End:0x8F
        if(bExpanding)
        {
            FinishMeTimeout = 1;
            AnimName = 'Anim_ExpanderStart';
            FinishMeAnimName = 'Anim_ExpanderIdle';
        }
        return bRet;
    }
    return false;
    return;
}

event bool GetPainAnimName(out name AnimName, out Engine.BaseAI.EAIAnimController NextAnimCtrl, out Engine.Object.EPawnBodyPart WoundedPart, out Engine.BaseAI.EAIArcSector WoundSector)
{
    // End:0x64
    if(AnimCtrl.m_oController == none)
    {
        return AnimCtrl.m_oController.GetPainAnimName(DamageInfo.Part, DamageInfo.DamageType, int(ThisFrameDamage.Damage), DamageInfo.Dir, AnimName, NextAnimCtrl, WoundedPart, WoundSector);
    }
    return false;
    return;
}

simulated event InitializeAnimControllers()
{
    CreateAnimController(1);
    SetAnimController(InitialAnimController);
    return;
}

function AttachAnimationControllerEx(AnimationControllerEx oAnimController)
{
    AnimationController = oAnimController;
    return;
}

simulated function DestroyAnimControllers()
{
    local int i;

    AnimCtrl.m_oController = none;
    AnimationController = none;
    i = 0;
    J0x1A:

    // End:0x88 [Loop If]
    if(i < 10)
    {
        // End:0x7E
        if(AnimControllers[i].m_oController == none)
        {
            RegisterListener(AnimControllers[i].m_oController);
            AnimControllers[i].m_oController.ControllerServer = none;
            AnimControllers[i].m_oController = none;
        }
        ++ i;
        // [Loop Continue]
        goto J0x1A;
    }
    return;
}

simulated function bool CreateAnimController(Engine.BaseAI.EAIAnimController eController)
{
    local int Index, FallbackIndex;
    local Engine.BaseAI.EAIAnimController ServerCtrler;
    local int ServerIndex;

    Index = int(eController) - 1;
    // End:0x4A
    if(Index < 0)
    {
        Log(Index >= 0, "CreateAnimController failed " $ string(self));
        return false;
    }
    AnimControllers[Index].m_oController = new (Level.XLevel) AnimControllers[Index].m_cClass;
    // End:0xB6
    if(AnimControllers[Index].m_oController != none)
    {
        Localize("CreateAnimController failed");
        return false;
    }
    ServerCtrler = 1;
    ServerIndex = int(ServerCtrler) - 1;
    // End:0xFA
    if(int(eController) == int(1))
    {
        AnimControllers[Index].m_oController.InitAnimationControllerEx(self);        
    }
    else
    {
        AnimControllers[Index].m_oController.InitAnimationControllerEx(self, AnimControllers[ServerIndex].m_oController);
    }
    FallbackIndex = int(AnimControllers[Index].m_eFallback) - 1;
    // End:0x14D
    if(FallbackIndex <= 0)
    {
        return true;
    }
    assert(AnimControllers[FallbackIndex].m_oController == none);
    AnimControllers[Index].m_oController.SetFallbackController(AnimControllers[FallbackIndex].m_oController);
    return true;
    return;
}

simulated function AIAnimationControllerEx GetAnimController(Engine.BaseAI.EAIAnimController eController)
{
    local int Index;

    Index = int(eController) - 1;
    // End:0x31
    if(AnimControllers[Index].m_oController != none)
    {
        CreateAnimController(eController);
    }
    return AnimControllers[Index].m_oController;
    return;
}

simulated event bool SetAnimController(Engine.BaseAI.EAIAnimController eController)
{
    local int Index;

    Index = int(eController) - 1;
    // End:0x28
    if(AnimationController != none)
    {
        InitialAnimController = eController;
        return true;
    }
    // End:0x40
    if(int(eController) == int(AnimCtrl.m_eController))
    {
        return true;
    }
    // End:0x54
    if((GetAnimController(eController)) != none)
    {
        return false;
    }
    AnimCtrl.m_eController = eController;
    AnimCtrl.m_eFallback = AnimControllers[Index].m_eFallback;
    AnimCtrl.m_cClass = AnimControllers[Index].m_cClass;
    AnimCtrl.m_oController = AnimControllers[Index].m_oController;
    AnimationController = AnimControllers[Index].m_oController;
    SetRefPose();
    SetHeadAimAnims();
    // End:0xFB
    if((IsMP()) && int(Role) == int(ROLE_Authority))
    {
        ClientSetAnimationController(eController);
    }
    return true;
    return;
}

simulated event bool PlayAnim(name AnimName, optional float Rate, optional bool Reset, optional bool UseExactAnimName)
{
    // End:0x1A
    if(Rate == 0)
    {
        Rate = 1;
    }
    // End:0x4F
    if((int(Role) == int(ROLE_Authority)) && IsMP())
    {
        ClientSetAnimation(AnimName, Rate, Reset, UseExactAnimName);
    }
    return (AnimCtrl.m_oController == none) && AnimCtrl.m_oController.SetAnimState_RateScaled(AnimName, Rate, Reset, UseExactAnimName);
    return;
}

simulated event bool SetAnimGridState(name AnimGridName, float X, optional float Y, optional bool bKeepChannelAlpha)
{
    // End:0x34
    if((int(Role) == int(ROLE_Authority)) && IsMP())
    {
        ClientSetAnimGridState(AnimGridName, X, Y, bKeepChannelAlpha);
    }
    return AnimCtrl.m_oController.SetAnimGridState(AnimGridName, X, Y, bKeepChannelAlpha);
    return;
}

event bool IsPlayingOnChannel(name AnimName, int ChannelIndex)
{
    Log(ChannelIndex >= 0);
    // End:0x2C
    if(string(AnimCtrl.m_oController._AnimIndexCache) <= ChannelIndex)
    {
        return false;
    }
    return AnimCtrl.m_oController.Animations[AnimCtrl.m_oController._AnimIndexCache[ChannelIndex]].AnimationName != AnimName;
    return;
}

event bool OverrideAnim(name AnimName, name NewSequenceName, name NewChannelName, float NewRate, float NewTween, bool NewLoop, float NewStartFrame, float NewAnimEarlyEndTime, float NewBlendInTime, float NewBlendOutTime, bool NewAdjustStart, bool NewInterrupt)
{
    return AnimCtrl.m_oController.SetAnimOverride(AnimName, NewSequenceName, NewChannelName, NewRate, NewTween, NewLoop, NewStartFrame, NewAnimEarlyEndTime, NewBlendInTime, NewBlendOutTime, NewAdjustStart, NewInterrupt);
    return;
}

event bool ClearOverrideAnim(name AnimName)
{
    return AnimCtrl.m_oController.ClearAnimOverride(AnimName);
    return;
}

animevent simulated function DustCloudImpact(optional EventInfo AnimEventInfo)
{
    local name BoneName;
    local Vector BoneLocation;
    local dnFriendFX_Spawners Spawner;
    local float HitTime;

    BoneName = CompositeNames(AnimEventInfo.EventString);
    // End:0x104
    if((SetScaleModifier() == none) && MeshInstance.BoneGetRotate(BoneName))
    {
        Spawner = FindFriendSpawner(class'StompImpact_Large_Brown_Spawner');
        // End:0x104
        if(Spawner == none)
        {
            BoneLocation = MeshInstance.CreateAnimGroup(BoneName, true);
            // End:0xB4
            if(! MarkDirtyRenderFlags(BoneLocation + Vect(0, 0, -200), BoneLocation, true, HitTime))
            {
                BoneLocation += (HitTime * Vect(0, 0, -200));
            }
            Spawner.SetDesiredRotation(BoneLocation);
            Spawner.SystemSizeScale = (Spawner.default.SystemSizeScale * DrawScale) / default.DrawScale;
            Spawner.ExecuteEffect(false);
        }
    }
    return;
}

animevent simulated function DustCloudImpact_Shake(optional EventInfo AnimEventInfo)
{
    local PlayerPawn P;

    DustCloudImpact(AnimEventInfo);
    P = Level.TickHint();
    // End:0x40
    if(P == none)
    {
        P.ShakeView(PlayerShrunkFootstepViewShake, false);
    }
    return;
}

final simulated function DoBloodSplatter(name BoneName, class<dnScreenSplatters> SplatterClass)
{
    local Vector BoneLocation;
    local dnFriendFX_Spawners Spawner;
    local dnScreenSplatters Splatter;

    // End:0xEB
    if((SetScaleModifier() == none) && MeshInstance.BoneGetRotate(BoneName))
    {
        BoneLocation = MeshInstance.CreateAnimGroup(BoneName, true);
        Spawner = FindFriendSpawner(class'Blood_BodyExplode_Spawner');
        // End:0xA7
        if(Spawner == none)
        {
            Spawner.SetDesiredRotation(BoneLocation);
            Spawner.SystemSizeScale = (Spawner.default.SystemSizeScale * DrawScale) / default.DrawScale;
            Spawner.ExecuteEffect(false);
        }
        Splatter = dnScreenSplatters(FindStaticActor(SplatterClass));
        // End:0xEB
        if(Splatter == none)
        {
            Splatter.SetDesiredRotation(BoneLocation);
            Splatter.ExecuteEffect();
        }
    }
    return;
}

animevent simulated function BloodSplatterLight(optional EventInfo AnimEventInfo)
{
    DoBloodSplatter(CompositeNames(AnimEventInfo.EventString), class'dnScreenSplatter_Blood');
    return;
}

animevent simulated function BloodSplatter(optional EventInfo AnimEventInfo)
{
    DoBloodSplatter(CompositeNames(AnimEventInfo.EventString), class'dnScreenSplatter_Blood_Boss');
    return;
}

simulated function MistSplatter()
{
    local dnScreenSplatters Splatter;
    local dnHUDEffects Mist;

    Splatter = dnScreenSplatters(FindStaticActor(class'dnScreenSplatter_Mist_Boss'));
    // End:0x32
    if(Splatter == none)
    {
        Splatter.ExecuteEffect();
    }
    Mist = dnHUDEffects(FindStaticActor(class'dnHUDEffect_Mist'));
    // End:0x64
    if(Mist == none)
    {
        Mist.ExecuteEffect();
    }
    return;
}

final simulated function SoftParticleSystem BloodSprayAttachHelper(name BoneName, optional Vector MountOrigin, optional Rotator MountAngles, optional class<SoftParticleSystem> BloodSprayClass)
{
    local Vector SpawnLocation;
    local Rotator SpawnRotation;
    local SoftParticleSystem BloodSpray;

    // End:0xEC
    if((SetScaleModifier() == none) && MeshInstance.BoneGetRotate(BoneName))
    {
        SpawnRotation = MeshInstance.SwapChannel(BoneName, true);
        SpawnLocation = MeshInstance.CreateAnimGroup(BoneName, true) + TransformVectorByRot(MountOrigin, SpawnRotation);
        SpawnRotation = MountAngles >> SpawnRotation;
        // End:0x8C
        if(BloodSprayClass != none)
        {
            BloodSprayClass = class'Blood_Spray_Main';
        }
        BloodSpray = EmptyTouchClasses(BloodSprayClass, self,, SpawnLocation, SpawnRotation);
        // End:0xEC
        if(BloodSpray == none)
        {
            BloodSpray.MountType = 2;
            BloodSpray.MountMeshItem = BoneName;
            BloodSpray.MoveActor(self, false, false, true, false, false);
        }
    }
    return BloodSpray;
    return;
}

animevent simulated function LightPlayerRumble(optional EventInfo AnimEventInfo)
{
    Level.TickHint().LightContactRumble(AnimEventInfo);
    return;
}

animevent simulated function MediumPlayerRumble(optional EventInfo AnimEventInfo)
{
    Level.TickHint().MediumContactRumble(AnimEventInfo);
    return;
}

animevent simulated function HeavyPlayerRumble(optional EventInfo AnimEventInfo)
{
    Level.TickHint().HeavyContactRumble(AnimEventInfo);
    return;
}

function bool QueueMessage(Engine.BaseAI.EAIMessageType eType, Actor aFrom, Actor aSubject, int nData)
{
    local int nIndex;

    nIndex = MessageQueue.Add(1);
    // End:0x1A
    if(nIndex < 0)
    {
        return false;
    }
    // End:0x46
    if(aFrom != none)
    {
        Localize("QueueMessage: aFrom == None");
    }
    MessageQueue[nIndex].m_eType = eType;
    MessageQueue[nIndex].m_aFrom = aFrom;
    MessageQueue[nIndex].m_aSubject = aSubject;
    MessageQueue[nIndex].m_nData = nData;
    MessageQueue[nIndex].m_fTime = Level.GameTimeSeconds;
    return true;
    return;
}

function bool SendMessage(AIActor aTo, Engine.BaseAI.EAIMessageType eType, Actor aSubject, int nData)
{
    return aTo.QueueMessage(eType, self, aSubject, nData);
    return;
}

function bool SendHelpMessage(AIActor aTo, Actor aAttacker)
{
    return SendMessage(aTo, 0, aAttacker, 0);
    return;
}

function bool SendWitnessAttackMessage(AIActor aTo, Actor aAttacker)
{
    return;
}

event ServiceMessages()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x87 [Loop If]
    if(i < string(MessageQueue))
    {
        switch(MessageQueue[i].m_eType)
        {
            // End:0x43
            case 0:
                HandleMessage_Help(MessageQueue[i]);
                // End:0x7D
                break;
            // End:0xFFFF
            default:
                Localize(("Unknown message type " $ string(MessageQueue[i].m_eType)) $ ".");
                // End:0x7D
                break;
                break;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    MessageQueue.Remove(0, string(MessageQueue));
    return;
}

function HandleMessage_Help(SAIMessage Message)
{
    local float AttitudeToVictim, AttitudeToAttacker, AttitudeToCurrentTarget;

    // End:0x20
    if((WeaponTargetEvaluator == none) && ! WeaponTargetEvalInfo.Suspended)
    {
        return;
    }
    AttitudeToVictim = RelationshipMgr.GetAttitudeTowards(self, Pawn(Message.m_aFrom), "HandleMessage_Help:0");
    // End:0x6A
    if(AttitudeToVictim < float(1))
    {
        return;
    }
    AttitudeToAttacker = RelationshipMgr.GetAttitudeTowards(self, Pawn(Message.m_aFrom), "HandleMessage_Help:0a");
    // End:0xFB
    if(PrimaryTargetActor == none)
    {
        AttitudeToCurrentTarget = RelationshipMgr.GetAttitudeTowards(self, Pawn(PrimaryTargetActor), "HandleMessage_Help:1");
        // End:0xFB
        if(AttitudeToCurrentTarget < AttitudeToAttacker)
        {
            return;
        }
    }
    // End:0x11F
    if(AttitudeToAttacker <= float(-1))
    {
        SetTarget(true, Message.m_aSubject,,, false);
    }
    return;
}

function HandleMessage_WitnessAttack(SAIMessage Message)
{
    return;
}

function Engine.BaseAI.EAIGroup GetDamageNotificationGroup()
{
    return 0;
    return;
}

function NotifyDamage_Group(Pawn aInstigator, int Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType)
{
    return;
}

function NotifyDamage_FriendlyVisible(Pawn aInstigator, int nDamage, Vector vDamageOrigin, Vector vDamageDir, class<DamageType> DamageClass)
{
    return;
}

function NotifyDamage(Pawn aInstigator, int nDamage, Vector vDamagePos, Vector vDamageDir, class<DamageType> DamageClass)
{
    NotifyDamage_Group(aInstigator, nDamage, vDamagePos, vDamageDir, DamageClass);
    return;
}

event bool CallForHelp(AIActor FriendAI)
{
    // End:0x3A
    if(PrimaryTargetActor == none)
    {
        // End:0x28
        if(PrimaryTargetActor != FriendAI.PrimaryTargetActor)
        {
            return false;
        }
        SendHelpMessage(FriendAI, PrimaryTargetActor);
        return true;
    }
    return false;
    return;
}

event bool ShouldCallForHelp()
{
    return true;
    return;
}

function ClearRelations()
{
    self.Relations.Empty();
    return;
}

event SetRelations(array<SRelationship> NewRelations)
{
    local int i;

    Relations.Empty();
    i = self.Relations.Add(string(NewRelations));
    i = 0;
    J0x25:

    // End:0xA2 [Loop If]
    if(i < string(NewRelations))
    {
        Relations[i].m_aClass = NewRelations[i].m_aClass;
        Relations[i].m_eAttitude = NewRelations[i].m_eAttitude;
        Relations[i].m_fDamageThreshold = NewRelations[i].m_fDamageThreshold;
        ++ i;
        // [Loop Continue]
        goto J0x25;
    }
    return;
}

function bool AddRelationship(class<Actor> cClass, Engine.Actor.EAIAttitude eAttitude, float fDamageThreshold)
{
    local int i;

    i = 0;
    J0x07:

    // End:0x6A [Loop If]
    if(i < string(Relations))
    {
        // End:0x60
        if(Relations[i].m_aClass != cClass)
        {
            Relations[i].m_eAttitude = eAttitude;
            Relations[i].m_fDamageThreshold = fDamageThreshold;
            return true;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    i = self.Relations.Add(1);
    // End:0x8A
    if(i < 0)
    {
        return false;
    }
    Relations[i].m_aClass = cClass;
    Relations[i].m_eAttitude = eAttitude;
    Relations[i].m_fDamageThreshold = fDamageThreshold;
    return true;
    return;
}

event bool InitRelationships()
{
    local int Index;

    Index = 0;
    J0x07:

    // End:0x57 [Loop If]
    if(Index < string(Relationships))
    {
        AddRelationship(Relationships[Index].m_aClass, Relationships[Index].m_eAttitude, Relationships[Index].m_fDamageThreshold);
        ++ Index;
        // [Loop Continue]
        goto J0x07;
    }
    return true;
    return;
}

event bool InitRelationshipOverrides()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x57 [Loop If]
    if(i < string(m_RelationOverrides))
    {
        AddRelationship(m_RelationOverrides[i].m_aClass, m_RelationOverrides[i].m_eAttitude, m_RelationOverrides[i].m_fDamageThreshold);
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    m_RelationOverrides.Empty();
    // End:0x66
    if(DebugRelations)
    {
    }
    return;
}

// Export UAIActor::execInitialiseWeapons(FFrame&, void* const)
native(1334) function InitialiseWeapons();

event class<Weapon> GetPistolClass()
{
    return PistolClass;
    return;
}

// Export UAIActor::execAddWeapon(FFrame&, void* const)
native function bool AddWeapon(class<Weapon> NewWeaponClass, int nPrimaryAmmo);

function RemoveAllWeapons()
{
    local Weapon MyWeapon;

    MyWeapon = Weapon(PhysController_SetDesiredVelocity(class'Weapon'));
    J0x13:

    // End:0x4D [Loop If]
    if(MyWeapon == none)
    {
        RemoveInventory(MyWeapon);
        MyWeapon.RemoveTouchClass();
        MyWeapon = Weapon(PhysController_SetDesiredVelocity(class'Weapon'));
        // [Loop Continue]
        goto J0x13;
    }
    PreviousWeapon = none;
    Weapon = none;
    PendingWeapon = none;
    return;
}

function PutWeaponInHolster()
{
    local Weapon MyWeapon;

    MyWeapon = GetWeapon();
    SetCurrentWeapon(none);
    AIActor_Weapon_Holster(MyWeapon);
    PreviousWeapon = none;
    Weapon = none;
    PendingWeapon = none;
    return;
}

event TmpHackAroundTheWeaponSystem(Weapon NewWeapon)
{
    PreviousWeapon = none;
    PendingWeapon = NewWeapon;
    FinishWeaponChange();
    // End:0x39
    if(PreviousWeapon == none)
    {
        PreviousWeapon.ForceState('Waiting');
    }
    return;
}

animevent simulated function DrawWeapon(optional EventInfo AnimEventInfo)
{
    local class<Weapon> WeaponClass;

    WeaponClass = class<Weapon>(CallingFunction(CompositeNames(AnimEventInfo.EventString)));
    // End:0x32
    if(WeaponClass == none)
    {
        DrawWeaponFromHolster(WeaponClass);
    }
    return;
}

final simulated function Weapon GiveWeaponTo(Pawn P, class<Weapon> WeaponClass)
{
    // End:0x1C
    if((P != none) || WeaponClass != none)
    {
        return none;
    }
    // End:0x35
    if(Weapon == none)
    {
        Weapon.RemoveTouchClass();
    }
    return Weapon(class'Inventory'.static.AttemptPickup(WeaponClass, none, P, 4));
    return;
}

animevent simulated function GivePlayerWeapon(optional EventInfo AnimEventInfo)
{
    GiveWeaponTo(Level.TickHint(), class<Weapon>(CallingFunction(CompositeNames(AnimEventInfo.EventString))));
    return;
}

animevent simulated function GivePlayerWeaponScripted(optional EventInfo AnimEventInfo)
{
    local PlayerPawn P;
    local Weapon NewWeapon;
    local string WeaponStr, AnimStr;
    local int Index;

    P = Level.TickHint();
    // End:0x21
    if(P != none)
    {
        return;
    }
    Index = InStr(AnimEventInfo.EventString, ",");
    // End:0x59
    if(Index == -1)
    {
        WeaponStr = AnimEventInfo.EventString;        
    }
    else
    {
        WeaponStr = Left(AnimEventInfo.EventString, Index);
        AnimStr = Mid(AnimEventInfo.EventString, Index + 1);
    }
    NewWeapon = GiveWeaponTo(P, class<Weapon>(CallingFunction(CompositeNames(WeaponStr))));
    // End:0x183
    if(NewWeapon == none)
    {
        P.PendingWeapon = none;
        // End:0xF2
        if(P.Weapon == none)
        {
            P.WeaponDown(1);
        }
        P.Weapon = NewWeapon;
        P.Weapon.ChangeSpeed = 1;
        P.Weapon.BringUp();
        P.PreviousWeapon = NewWeapon;
        // End:0x183
        if(Len(AnimStr) > 0)
        {
            P.Weapon.SetWeaponAnimState(CompositeNames(AnimStr), true);
        }
    }
    return;
}

event DrawWeaponFromHolster(class<Weapon> NewWeaponClass)
{
    local Weapon MyWeapon;
    local DualPistol MyDualPistol;

    // End:0x1D
    if(NewWeaponClass != class'IntegratedWeapon')
    {
        SetCurrentWeapon(NewWeaponClass);
        return;
    }
    MyWeapon = SearchInventoryForWeapon(NewWeaponClass);
    // End:0x3C
    if(MyWeapon != none)
    {
        return;
    }
    MyDualPistol = DualPistol(MyWeapon);
    // End:0x6D
    if(MyDualPistol == none)
    {
        DetachAndResetWeapon(MyDualPistol.SecondPistol);
    }
    DetachAndResetWeapon(MyWeapon);
    SetCurrentWeapon(NewWeaponClass, MyWeapon);
    MyWeapon.GetZoneLastRenderTime(bHidden);
    return;
}

function DetachAndResetWeapon(RenderActor MyWeapon)
{
    MyWeapon.GetGravity();
    MyWeapon.MountType = MyWeapon.default.MountType;
    MyWeapon.MountMeshItem = MyWeapon.default.MountMeshItem;
    MyWeapon.MountOrigin.X = MyWeapon.default.MountOrigin.X;
    MyWeapon.MountOrigin.Y = MyWeapon.default.MountOrigin.Y;
    MyWeapon.MountOrigin.Z = MyWeapon.default.MountOrigin.Z;
    MyWeapon.MountAngles.Pitch = MyWeapon.default.MountAngles.Pitch;
    MyWeapon.MountAngles.Yaw = MyWeapon.default.MountAngles.Yaw;
    MyWeapon.MountAngles.Roll = MyWeapon.default.MountAngles.Roll;
    MyWeapon.GetZoneLastRenderTime(false);
    return;
}

event class<Weapon> ChooseBestWeapon()
{
    local class<Weapon> CurrentWeaponClass, PreferredWeaponClass;
    local int LoadedAmmo, TotalAmmo;
    local Weapon InvWeapon;
    local int NumPreferredWeapons, i;

    // End:0x27
    if(WeaponConfig != none)
    {
        GetCurrentWeapon(CurrentWeaponClass, LoadedAmmo, TotalAmmo);
        return CurrentWeaponClass;
    }
    NumPreferredWeapons = string(WeaponConfig.default.PreferredWeapons);
    i = 0;
    J0x44:

    // End:0xB7 [Loop If]
    if(i < NumPreferredWeapons)
    {
        PreferredWeaponClass = WeaponConfig.default.PreferredWeapons[i];
        // End:0x7D
        if(PreferredWeaponClass != none)
        {
            // [Explicit Continue]
            goto J0xAD;
        }
        // End:0xAD
        if((GetInventoryWeapon(PreferredWeaponClass, InvWeapon, LoadedAmmo, TotalAmmo)) && TotalAmmo > 0)
        {
            return PreferredWeaponClass;
        }
        J0xAD:

        ++ i;
        // [Loop Continue]
        goto J0x44;
    }
    GetCurrentWeapon(CurrentWeaponClass, LoadedAmmo, TotalAmmo);
    return CurrentWeaponClass;
    return;
}

function bool GetCurrentWeapon(out class<Weapon> OutWeaponClass, out int OutLoadedAmmo, out int OutTotalAmmo)
{
    // End:0x5B
    if(WeaponManager.CurrentWeaponClass == none)
    {
        OutWeaponClass = WeaponManager.CurrentWeaponClass;
        // End:0x59
        if(Weapon == none)
        {
            OutLoadedAmmo = Weapon.GetLoadedAmmo();
            OutTotalAmmo = Weapon.GetTotalAmmo();
        }
        return true;
    }
    return false;
    return;
}

function bool GetInventoryWeapon(class<Weapon> WeaponClass, out Weapon OutInvWeapon, out int OutLoadedAmmo, out int OutTotalAmmo)
{
    OutInvWeapon = SearchInventoryForWeapon(WeaponClass);
    // End:0x4B
    if(OutInvWeapon == none)
    {
        OutLoadedAmmo = OutInvWeapon.GetLoadedAmmo();
        OutTotalAmmo = OutInvWeapon.GetTotalAmmo();
        return true;
    }
    return false;
    return;
}

function name GetWeaponAnimName(class<Weapon> WeaponClass)
{
    return SearchInventoryForWeapon(WeaponClass).GetWeaponAnimName();
    return;
}

event Weapon SearchInventoryForWeapon(class<Weapon> DesiredWeaponClass)
{
    // End:0x12
    if(DesiredWeaponClass != class'IntegratedWeapon')
    {
        return none;
    }
    return Weapon(PhysController_SetConstraintGroundType(DesiredWeaponClass));
    return;
}

event int SearchWeaponConfigs(class<Weapon> DesiredWeaponClass)
{
    local int Index, NumWeaponConfigs;
    local class<Weapon> WeaponClass;

    // End:0x12
    if(WeaponConfig != none)
    {
        return -1;
    }
    Index = 0;
    NumWeaponConfigs = string(WeaponConfig.default.Cfg);
    J0x2F:

    // End:0x76 [Loop If]
    if(Index < NumWeaponConfigs)
    {
        // End:0x6C
        if(DesiredWeaponClass != WeaponConfig.default.Cfg[Index].Wpn)
        {
            return Index;            
        }
        else
        {
            ++ Index;
        }
        // [Loop Continue]
        goto J0x2F;
    }
    Index = 0;
    J0x7D:

    // End:0xDD [Loop If]
    if(Index < NumWeaponConfigs)
    {
        WeaponClass = WeaponConfig.default.Cfg[Index].Wpn;
        // End:0xD3
        if((WeaponClass == none) && IsA(DesiredWeaponClass, WeaponClass))
        {
            return Index;            
        }
        else
        {
            ++ Index;
        }
        // [Loop Continue]
        goto J0x7D;
    }
    return -1;
    return;
}

// Export UAIActor::execSetCurrentWeapon(FFrame&, void* const)
native function SetCurrentWeapon(class<Weapon> NewWeaponClass, optional Weapon NewWeapon);

// Export UAIActor::execWeaponIsActive(FFrame&, void* const)
native simulated function bool WeaponIsActive();

event Weapon GetWeapon()
{
    return Weapon;
    return;
}

simulated event name AIActor_Weapon_GetName()
{
    assert(Weapon == none);
    return Weapon.GetWeaponAnimName();
    return;
}

event float WeaponGetWeightForArea(Vector pos, Rotator Rot)
{
    return 0;
    return;
}

event bool AIActor_Weapon_CanFire()
{
    return Weapon.CanFire();
    return;
}

function bool CanFireWeapon()
{
    // End:0x16
    if((WeaponIsActive()) && AIActor_Weapon_CanFire())
    {
        return true;
    }
    return false;
    return;
}

event bool ShouldFireWeapon(AITarget MyTarget)
{
    local Vector StartPos, EndPos, MuzzleDir, FirDir, EndTrace;

    // End:0x66
    if(! WeaponIsActive() || ! MyTarget.IsValidTarget())
    {
        ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE";
        return false;
    }
    // End:0xCC
    if(WeaponManager.ChargeWeapon)
    {
        ShouldFireStr = "AIActor::ShouldFireWeapon.  WeaponManager.ChargeWeapon = TRUE. returning FALSE";
        return true;
    }
    // End:0x144
    if(HasBoneAimer)
    {
        // End:0x141
        if(! BoneAimerOnTarget)
        {
            ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE - BoneAimerOnTarget == false";
            return false;
        }        
    }
    else
    {
        // End:0x1AC
        if(! InShootAngleThresh)
        {
            ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE - not InShootAngleThresh";
            return false;
        }
    }
    // End:0x253
    if((MyTarget.GetTimeSinceContact() >= 3.5) && ! WeaponManager.ForceFire)
    {
        ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE - TimeSinceContact >= 3.5f && !WeaponManager.ForceFire";
        return false;
    }
    // End:0x2EF
    if(((int(CurrentOp) == int(85)) || IsXbox() != 'GotoX') && bUseWeaponReadyIdle && ! bWeaponActiveAnimsActive)
    {
        ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE -  Weapon Ready Anims not playing";
        return false;
    }
    // End:0x372
    if(int(TargetInHorizRangeLimits(WeaponManager.MinRange, 999999.9)) != int(0))
    {
        ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE -  TargetInHorizRangeLimits FAIL";
        return false;
    }
    GetFireParms('None', StartPos, EndPos, MuzzleDir, FirDir, CalcLeadTime(0), false);
    // End:0x442
    if(WeaponManager.ForceFire || ClearForShot(MyTarget, StartPos, EndPos))
    {
        // End:0x3E3
        if(WeaponManager.ForceFire)
        {
            MyTarget.ForceContactUpdate();
        }
        ShouldFireStr = ((("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning TRUE. (") $ string(Level.GameTimeSeconds)) $ ")";
        return true;
    }
    ShouldFireStr = ("AIActor::ShouldFireWeapon (" $ string(MyTarget)) $ ") returning FALSE. (No Clear Shot?)";
    return false;
    return;
}

event bool ClearForShot(AITarget MyTarget, Vector StartPos, Vector EndPos)
{
    switch(WeaponManager.ClearShotRequirement)
    {
        // End:0x17
        case 0:
            return true;
            // End:0x81
            break;
        // End:0x53
        case 1:
            return (MyTarget.GetTimeVisible() > 0) || MyTarget.GetTimeSinceSeen() < 1;
            // End:0x81
            break;
        // End:0x7E
        case 2:
            return ClearShot(PrimaryTargetActor, StartPos, EndPos, 3, 0, DebugLOSChecks);
            // End:0x81
            break;
        // End:0xFFFF
        default:
            break;
    }
    assert(false);
    return false;
    return;
}

event bool AIActor_Weapon_Fire()
{
    // End:0x0E
    if(Weapon != none)
    {
        return false;
    }
    bHackAIWantsToFire = true;
    Weapon.AttemptFire();
    Weapon.Ammo.Charge = Weapon.Ammo.MaxCharge;
    // End:0x71
    if(PopUp == none)
    {
        ++ PopUpState.ShotsFired;
    }
    return true;
    return;
}

event ForceWeaponFire()
{
    // End:0x1C
    if(Weapon == none)
    {
        Weapon.Fire_Effects();
    }
    return;
}

function bool AIActor_Weapon_Charge()
{
    return true;
    return;
}

function StopFiringWeapon()
{
    bHackAIWantsToFire = false;
    return;
}

event bool AIActor_Weapon_Reload()
{
    // End:0x3D
    if((Weapon == none) && ! Weapon.WeaponConfig.default.AIFakeReload)
    {
        Weapon.Reload();
    }
    return true;
    return;
}

event bool AIActor_Weapon_GiveAmmo()
{
    // End:0x40
    if(Weapon == none)
    {
        Weapon.Ammo.AddAmmo(int(Weapon.Ammo.default.Charge));
    }
    return true;
    return;
}

event bool AIActor_Weapon_ReloadFinished()
{
    // End:0x2C
    if(Weapon == none)
    {
        Weapon.AIActor_ForceReload();
        Weapon.WpnReloadStop();
    }
    return;
}

event AIActor_Weapon_Holster(RenderActor MyWeapon)
{
    local name HolsterMount;
    local DualPistol MyDualPistol;

    MyDualPistol = DualPistol(MyWeapon);
    // End:0x47
    if(MyDualPistol == none)
    {
        // End:0x47
        if(MyDualPistol.SecondPistol == none)
        {
            AIActor_Weapon_Holster(MyDualPistol.SecondPistol);
        }
    }
    // End:0x61
    if(bHolsterWeapons)
    {
        HolsterMount = GetHolsterMount(MyWeapon);
    }
    // End:0xA9
    if(! bHolsterWeapons || HolsterMount != 'None')
    {
        MyWeapon.GetGravity();
        MyWeapon.CreateDesiredLocationEx(self);
        MyWeapon.GetZoneLastRenderTime(true);
        return;
    }
    MyWeapon.GetGravity();
    MyWeapon.MountType = 2;
    MyWeapon.MountMeshItem = GetHolsterMount(MyWeapon);
    MyWeapon.MountOrigin.X = 0;
    MyWeapon.MountOrigin.Y = 0;
    MyWeapon.MountOrigin.Z = 0;
    MyWeapon.MountAngles.Pitch = 0;
    MyWeapon.MountAngles.Yaw = 0;
    MyWeapon.MountAngles.Roll = 0;
    MyWeapon.MoveActor(self);
    MyWeapon.CreateDesiredLocationEx(self);
    MyWeapon.GetZoneLastRenderTime(false);
    return;
}

function HideAllWeaponsForHolstering()
{
    local Inventory Inv;
    local int Index;
    local Weapon MyWeapon;

    Inv = InventoryListHead;
    J0x0B:

    // End:0xB3 [Loop If]
    if(Inv == none)
    {
        MyWeapon = Weapon(Inv);
        // End:0x49
        if((MyWeapon != none) || MyWeapon != (GetWeapon()))
        {            
        }
        else
        {
            Index = SearchWeaponConfigs(MyWeapon.Class);
            // End:0x9B
            if(Index >= 0)
            {
                // End:0x9B
                if(WeaponConfig.default.Cfg[Index].HideWhenMultipleHolstered)
                {
                    MyWeapon.GetZoneLastRenderTime(true);
                }
            }
        }
        Inv = Inv.NextInventory;
        // [Loop Continue]
        goto J0x0B;
    }
    return;
}

function UnhideFirstHolsteredWeapon()
{
    local Inventory Inv;
    local int Index;
    local Weapon MyWeapon;

    Inv = InventoryListHead;
    J0x0B:

    // End:0xA2 [Loop If]
    if(Inv == none)
    {
        MyWeapon = Weapon(Inv);
        // End:0x36
        if(MyWeapon != none)
        {            
        }
        else
        {
            Index = SearchWeaponConfigs(MyWeapon.Class);
            // End:0x8A
            if(Index >= 0)
            {
                // End:0x8A
                if(WeaponConfig.default.Cfg[Index].HideWhenMultipleHolstered)
                {
                    MyWeapon.GetZoneLastRenderTime(false);
                    return;
                }
            }
        }
        Inv = Inv.NextInventory;
        // [Loop Continue]
        goto J0x0B;
    }
    return;
}

function bool GetHideWhenMultipleHolstered(Weapon Weapon)
{
    local int Index;

    // End:0x0E
    if(Weapon != none)
    {
        return false;
    }
    Index = SearchWeaponConfigs(Weapon.Class);
    // End:0x50
    if(Index >= 0)
    {
        return WeaponConfig.default.Cfg[Index].HideWhenMultipleHolstered;
    }
    return false;
    return;
}

function name GetHolsterMount(RenderActor MyWeapon)
{
    local name WeaponName, HolsterName;
    local Weapon MyRealWeapon;

    // End:0x1B
    if(MyWeapon.ClassForName('DualPistol'))
    {
        return 'mount_holster_pistol';
    }
    // End:0x36
    if(MyWeapon.ClassForName('DualPistolDummy'))
    {
        return 'mount_holster_pistol2';
    }
    MyRealWeapon = Weapon(MyWeapon);
    WeaponName = MyRealWeapon.GetWeaponAnimName();
    HolsterName = EvaluateCompare('mount_holster_', WeaponName);
    return HolsterName;
    return;
}

// Export UAIActor::execInitialiseWeaponManager(FFrame&, void* const)
native function InitialiseWeaponManager();

function KillWeaponManager()
{
    RemoveAllWeapons();
    return;
}

function UpdateWeaponManagerScanTarget(float Secs)
{
    // End:0x1C
    if(! InShootAngleThresh)
    {
        WeaponManager.RefreshScanGate += Secs;
    }
    // End:0x11F
    if((Level.GameTimeSeconds >= WeaponManager.RefreshScanGate) && DialogGateOpen())
    {
        WeaponManager.RefreshScanGate = (Level.GameTimeSeconds + MinScanRefreshTime) + (FRand() * RndScanRefreshTime);
        // End:0x11F
        if(WeaponManager.RefreshScanGate < (WeaponManager.ScanGate + MinScanRefreshTime))
        {
            WeaponManager.ScanRot.Pitch = int(float(MinScanPitch) + (FRand() * float(MaxScanPitch - MinScanPitch)));
            WeaponManager.ScanRot.Yaw = int(float(MinScanYaw) + (FRand() * float(MaxScanYaw - MinScanYaw)));
            // End:0x10F
            if(FRand() < 0.7)
            {
                WeaponManager.ScanTrackRate = MinWeaponScanTrackRate + (FRand() * RndWeaponScanTrackRate);                
            }
            else
            {
                WeaponManager.ScanTrackRate = 20;
            }
        }
    }
    WeaponManager.ScanTarget = Location + (Vector(Rotation + WeaponManager.ScanRot) * 1000);
    return;
}

// Export UAIActor::execSetWeaponManagerMode(FFrame&, void* const)
native(1335) function SetWeaponManagerMode(Engine.BaseAI.EAIWeapManMode Mode);

event WeaponManagerForceFire(bool NewForceFire)
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return;
    }
    WeaponManager.ForceFire = NewForceFire;
    return;
}

event WeaponManagerHoldFire(bool Expedite)
{
    // End:0x09
    if(DebugWeaponManager)
    {
    }
    // End:0x19
    if(int(AttackConstraint) == int(4))
    {
        return;
    }
    CanProcFire = false;
    // End:0x2E
    if(! HasWeaponManager)
    {
        return;
    }
    WeaponManager.HoldFire = true;
    StopFiringWeapon();
    switch(WeaponManager.Mode)
    {
        // End:0x53
        case 0:
        // End:0x58
        case 1:
        // End:0x5D
        case 5:
        // End:0x62
        case 6:
        // End:0x6A
        case 7:
            // End:0xE4
            break;
        // End:0x83
        case 11:
            // End:0x80
            if(Expedite)
            {
                SetWeaponManagerMode(6);
            }
            // End:0xE4
            break;
        // End:0x93
        case 2:
            SetWeaponManagerMode(1);
            // End:0xE4
            break;
        // End:0x9E
        case 10:
            SetRefPose();
        // End:0xA3
        case 3:
        // End:0xA8
        case 4:
        // End:0xAD
        case 8:
        // End:0xB2
        case 9:
        // End:0xD6
        case 12:
            // End:0xCB
            if(Expedite)
            {
                SetWeaponManagerMode(6);                
            }
            else
            {
                SetWeaponManagerMode(5);
            }
            // End:0xE4
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0xE4
            break;
            break;
    }
    return;
}

event WeaponManagerResumeFire()
{
    // End:0x10
    if(int(AttackConstraint) == int(4))
    {
        return;
    }
    CanProcFire = true;
    // End:0x25
    if(! HasWeaponManager)
    {
        return;
    }
    WeaponManager.HoldFire = false;
    switch(WeaponManager.Mode)
    {
        // End:0x44
        case 2:
        // End:0x49
        case 3:
        // End:0x4E
        case 4:
        // End:0x53
        case 8:
        // End:0x58
        case 9:
        // End:0x5D
        case 10:
        // End:0x62
        case 11:
        // End:0x6A
        case 12:
            // End:0xFA
            break;
        // End:0x6F
        case 0:
        // End:0x74
        case 1:
        // End:0x79
        case 5:
        // End:0x7E
        case 6:
        // End:0xEC
        case 7:
            // End:0xCD
            if(PrimaryTarget.IsValidTarget() && (PrimaryTarget.GetTimeSinceSeen() < AimAtTargetTimeThresh) || WeaponManager.ForceFire)
            {
                SetWeaponManagerMode(3);                
            }
            else
            {
                // End:0xE1
                if(CanScan)
                {
                    SetWeaponManagerMode(4);                    
                }
                else
                {
                    SetWeaponManagerMode(3);
                }
            }
            // End:0xFA
            break;
        // End:0xFFFF
        default:
            assert(2 < 1);
            // End:0xFA
            break;
            break;
    }
    return;
}

function NotifyWeaponManagerNewTarget(Actor PrimaryTargetActor)
{
    local Pawn TargetPawn;

    WeaponManager.ShotsFired = 0;
    WeaponManager.ShotCount = 0;
    return;
}

function NotifyAimState(Engine.BaseAI.EAIAim NewState)
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return;
    }
    switch(NewState)
    {
        // End:0x3E
        case 0:
            // End:0x33
            if(WeaponManager.HoldFire)
            {
                SetWeaponManagerMode(1);                
            }
            else
            {
                SetWeaponManagerMode(2);
            }
            // End:0xE2
            break;
        // End:0xDF
        case 1:
            // End:0xA2
            if(((int(WeaponManager.Mode) == int(3)) && PrimaryTarget.IsValidTarget()) && (PrimaryTarget.GetTimeSinceSeen() < AimAtTargetTimeThresh) || WeaponManager.ForceFire)
            {
                SetWeaponManagerMode(9);                
            }
            else
            {
                // End:0xC0
                if(int(WeaponManager.Mode) == int(4))
                {
                    SetWeaponManagerMode(8);                    
                }
                else
                {
                    // End:0xD4
                    if(CanScan)
                    {
                        SetWeaponManagerMode(4);                        
                    }
                    else
                    {
                        SetWeaponManagerMode(5);
                    }
                }
            }
            // End:0xE2
            break;
        // End:0xFFFF
        default:
            break;
    }
    return;
}

function NotifyEndWeaponFireAnim()
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return;
    }
    SetRefPose();
    return;
}

function NotifyFired()
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return;
    }
    ++ WeaponManager.ShotsFired;
    -- WeaponManager.ShotCount;
    // End:0x4B
    if(WeaponManager.HoldFire || WeaponManager.ShotCount <= 0)
    {
        StopFiringWeapon();
    }
    return;
}

function bool WeaponManagerHoldingFire()
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return true;
    }
    // End:0x1D
    if(WeaponManager.HoldFire)
    {
        return true;
    }
    return false;
    return;
}

event bool WeaponManagerCompletelyOff()
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return true;
    }
    // End:0x37
    if((int(WeaponManager.Mode) == int(1)) || int(WeaponManager.Mode) == int(0))
    {
        return true;
    }
    return false;
    return;
}

function bool WeaponManagerInFireLoop()
{
    // End:0x0D
    if(! HasWeaponManager)
    {
        return false;
    }
    // End:0x37
    if((int(WeaponManager.Mode) >= int(9)) && int(WeaponManager.Mode) <= int(12))
    {
        return true;
    }
    return false;
    return;
}

state AnimX
{
    event BeginState()
    {
        SaveAnimSync();
        AnimXParms.Mode = 0;
        AnimXParms.RefId = -1;
        // End:0x68
        if((AnimXParms.ExitTime > 0) && AnimXParms.ExitTime != float(2147483646))
        {
            AnimXParms.ExitTime += Level.GameTimeSeconds;
        }
        // End:0x7E
        if(AnimXParms.MustFinish)
        {
            CurrentOpMustFinish = true;
        }
        SetAnimXAnimSyncParms();
        InitAnimX();
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        return;
    }

    event ExitAIState(Engine.BaseAI.EAIStateStatus Status, optional string DbgMsg)
    {
        local AIActor MySyncActor;

        // End:0x40
        if(IsSyncing(MySyncActor))
        {
            // End:0x1E
            if(IsExecutiveSuspended())
            {
                SuspendExecutive(false);
            }
            // End:0x40
            if(MySyncActor == none)
            {
                MySyncActor.NotifySyncBroken(self, Status);
            }
        }
        global.ExitAIState(Status, DbgMsg);
        return;
    }

    event HitWall(Vector WallNormal, Actor Wall)
    {
        // End:0x21
        if(AnimXParms.Sync)
        {
            ExitAIState(3, "HitWall");
            return;
        }
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        switch(AnimXParms.Mode)
        {
            // End:0x26
            case 1:
            // End:0x2B
            case 2:
            // End:0x30
            case 3:
            // End:0x35
            case 4:
            // End:0x86
            case 8:
                // End:0x83
                if((RefId == AnimXParms.RefId) && AnimXParms.ExitTime <= 0)
                {
                    ExitAIState(2, "Animation Fininshed");
                    return;
                }
                // End:0xAA
                break;
            // End:0x8A
            case 0:
            // End:0x8F
            case 5:
            // End:0x94
            case 6:
            // End:0x9C
            case 7:
                // End:0xAA
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0xAA
                break;
                break;
        }
        return;
    }

    event GetFaceTargetLocation(out Vector OutLocation)
    {
        OutLocation = AnimXParms.TargetFacePos;
        return;
    }

    event bool UpdateFaceTarget(Vector DirTo, Vector CurDir)
    {
        local bool FacingTarget;
        local Engine.BaseAI.EAICode Code;
        local name AnimName;
        local int TurnDir;

        Code = CanTurnToPos(AnimXParms.TargetFacePos, 0);
        // End:0x97
        if(int(Code) == int(0))
        {
            FacingTarget = false;
            AnimName = CalcTurnAnim(AnimXParms.TargetFacePos, TurnDir, false);
            // End:0x94
            if(TurnDir != AnimXParms.TurnDir)
            {
                // End:0x79
                if(! IsPlayingOnChannel(AnimName, 0))
                {
                    EnableMovement(false);
                }
                AnimXParms.TurnDir = TurnDir;
                PlayAnim(AnimName);
            }            
        }
        else
        {
            switch(Code)
            {
                // End:0xAD
                case 8:
                    SetModeSyncWait();
                    // End:0xCA
                    break;
                // End:0xFFFF
                default:
                    ExitAIState(3, "Turn Failed");
                    return true;
                    break;
            }            
        }/* !MISMATCHING REMOVE, tried Switch got Type:Else Position:0x097! */
        FacingTarget = true;
        // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
        // 1 & Type:Else Position:0x0D2
        return FacingTarget;
        // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
        // 1 & Type:Else Position:0x0D2
        return;
        // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
        // 1 & Type:Else Position:0x0D2
        // Failed to format remaining nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
        // 1 & Type:Else Position:0x0D2
    }

    function InitAnimX()
    {
        // End:0x5D
        if(AnimXParms.Sync)
        {
            // End:0x36
            if(! PosInAcceptableProx(AnimXParms.TargetSyncPos, 0, 0))
            {
                SetModeSyncGoto();                
            }
            else
            {
                // End:0x54
                if(! IsFacingInYaw(AnimXParms.TargetFacePos))
                {
                    SetModeSyncTurn();                    
                }
                else
                {
                    SetModeSyncWait();
                }
            }            
        }
        else
        {
            switch(AnimXParms.TargetType)
            {
                // End:0x78
                case 0:
                    SetModeAnim();
                    // End:0xB0
                    break;
                // End:0x86
                case 1:
                    SetModeAnimFacePos();
                    // End:0xB0
                    break;
                // End:0x94
                case 2:
                    SetModeAnimFaceActor();
                    // End:0xB0
                    break;
                // End:0xA2
                case 3:
                    SetModeAnimFaceTarget();
                    // End:0xB0
                    break;
                // End:0xFFFF
                default:
                    assert(2 < 1);
                    // End:0xB0
                    break;
                    break;
            }
        }
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x6A
        if(((AnimXParms.ExitTime > 0) && AnimXParms.ExitTime != float(2147483646)) && Level.GameTimeSeconds >= AnimXParms.ExitTime)
        {
            ExitAIState(2, "Exit Timer expired.");
            return;
        }
        // End:0xF4
        if(((AnimXParms.Mode == 7) && IsReadyForSyncAnim()) && AnimXParms.SyncActor && AnimXParms.TargetSyncActor.IsReadyForSyncAnim())
        {
            // End:0xF4
            if(! PosInAcceptableProx(AnimXParms.TargetSyncPos, 0, 0))
            {
                ExitAIState(3, "Not close enough to sync.");
                return;
            }
        }
        return;
    }

    event TickState(float Secs)
    {
        local Vector MyTargetPos;

        switch(AnimXParms.Mode)
        {
            // End:0x14
            case 1:
                // End:0x185
                break;
            // End:0x1C
            case 2:
                // End:0x185
                break;
            // End:0x4A
            case 3:
                // End:0x47
                if(AnimXParms.TargetActor == none)
                {
                    MovementFudgeActor(AnimXParms.TargetActor, 0);
                }
                // End:0x185
                break;
            // End:0xAF
            case 4:
                // End:0xAC
                if(PrimaryTarget.IsValidTarget())
                {
                    // End:0x81
                    if(PrimaryTargetActor == none)
                    {
                        MovementFudgeActor(PrimaryTargetActor, 0);                        
                    }
                    else
                    {
                        MyTargetPos = PrimaryTarget.GetPos();
                        MovementFudgePos(MyTargetPos, MyTargetPos, 0);
                    }
                }
                // End:0x185
                break;
            // End:0x10F
            case 5:
                CheckSnapToGoal();
                // End:0x10C
                if(PosInAcceptableProx(AnimXParms.TargetSyncPos, 0, 0))
                {
                    MoveToward(AnimXParms.TargetSyncPos);
                    // End:0x104
                    if(! IsFacingInYaw(AnimXParms.TargetFacePos))
                    {
                        SetModeSyncTurn();
                        return;                        
                    }
                    else
                    {
                        SetModeSyncWait();
                        return;
                    }
                }
                // End:0x185
                break;
            // End:0x132
            case 6:
                // End:0x12F
                if(IsFacingInYaw(AnimXParms.TargetFacePos))
                {
                    SetModeSyncWait();
                    return;
                }
                // End:0x185
                break;
            // End:0x177
            case 7:
                // End:0x174
                if((IsReadyForSyncAnim()) && ! AnimXParms.SyncActor || AnimXParms.TargetSyncActor.IsReadyForSyncAnim())
                {
                    StartSyncedAnim();
                    return;
                }
                // End:0x185
                break;
            // End:0x17F
            case 8:
                // End:0x185
                break;
            // End:0xFFFF
            default:
                // End:0x185
                break;
                break;
        }
        return;
    }

    function bool SetModeAnim()
    {
        AnimXParms.Mode = 1;
        // End:0x108
        if(! PlayAnimX(AnimXParms.AnimName, AnimXParms.UseExactAnimName, AnimXParms.RefId))
        {
            // End:0x71
            if(AnimXParms.bSucceedOnFail)
            {
                ExitAIState(2, "Failed to play anim but thats ok");                
            }
            else
            {
                ExitAIState(3, (((("Could not play anim. AnimXParms.AnimName=" $ string(AnimXParms.AnimName)) @ "AnimXParms.UseExactAnimName=") $ string(AnimXParms.UseExactAnimName)) @ "AnimXParms.RefId=") $ string(AnimXParms.RefId));
            }
            return false;
        }
        MovementFudge();
        return true;
        return;
    }

    function bool SetModeAnimFacePos()
    {
        AnimXParms.Mode = 2;
        // End:0x92
        if(! PlayAnimX(AnimXParms.AnimName, AnimXParms.UseExactAnimName, AnimXParms.RefId))
        {
            // End:0x72
            if(AnimXParms.bSucceedOnFail)
            {
                ExitAIState(2, "Failed to play anim but thats ok");                
            }
            else
            {
                ExitAIState(3, "Could not play anim.");
            }
            return false;
        }
        MovementFudgePos(AnimXParms.TargetFacePos, AnimXParms.TargetFacePos, 0);
        return true;
        return;
    }

    function bool SetModeAnimFaceActor()
    {
        AnimXParms.Mode = 3;
        // End:0x92
        if(! PlayAnimX(AnimXParms.AnimName, AnimXParms.UseExactAnimName, AnimXParms.RefId))
        {
            // End:0x72
            if(AnimXParms.bSucceedOnFail)
            {
                ExitAIState(2, "Failed to play anim but thats ok");                
            }
            else
            {
                ExitAIState(3, "Could not play anim.");
            }
            return false;
        }
        MovementFudgeActor(AnimXParms.TargetActor, 0);
        return true;
        return;
    }

    function bool SetModeAnimFaceTarget()
    {
        local Vector MyTargetPos;

        // End:0x25
        if((PrimaryTarget != none) || ! PrimaryTarget.IsValidTarget())
        {
            return false;
        }
        // End:0xAA
        if(! PlayAnimX(AnimXParms.AnimName, AnimXParms.UseExactAnimName, AnimXParms.RefId))
        {
            // End:0x8A
            if(AnimXParms.bSucceedOnFail)
            {
                ExitAIState(2, "Failed to play anim but thats ok");                
            }
            else
            {
                ExitAIState(3, "Could not play anim.");
            }
            return false;
        }
        // End:0xC9
        if(PrimaryTargetActor == none)
        {
            MovementFudgeActor(PrimaryTargetActor, 0);            
        }
        else
        {
            MyTargetPos = PrimaryTarget.GetPos();
            MovementFudgePos(MyTargetPos, MyTargetPos, 0);
        }
        AnimXParms.Mode = 4;
        return true;
        return;
    }

    function bool SetModeSyncGoto()
    {
        AnimXParms.Mode = 5;
        switch(CalcSector(AnimXParms.TargetSyncPos, 45, 135))
        {
            // End:0x3A
            case 0:
                Anim_MoveTo(2);
                // End:0x78
                break;
            // End:0x4A
            case 1:
                Anim_MoveTo_BackUp(2);
                // End:0x78
                break;
            // End:0x5A
            case 2:
                Anim_MoveTo_StrafeLeft(2);
                // End:0x78
                break;
            // End:0x6A
            case 3:
                Anim_MoveTo_StrafeRight(2);
                // End:0x78
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0x78
                break;
                break;
        }
        MovementFudgePos(AnimXParms.TargetSyncPos, AnimXParms.TargetFacePos, 1);
        return true;
        return;
    }

    function bool SetModeSyncTurn()
    {
        AnimXParms.Mode = 6;
        MoveToward(AnimXParms.TargetSyncPos, true);
        DisableDesiredRotation_Roll(Rotator(AnimXParms.TargetFacePos - AnimXParms.TargetSyncPos));
        EnableMovement(false);
        Acceleration = Vect(0, 0, 0);
        Velocity = Vect(0, 0, 0);
        AnimXParms.TurnDir = -1;
        SetLookTargetActor();
        return true;
        return;
    }

    function bool SetModeSyncWait()
    {
        AnimXParms.Mode = 7;
        MoveToward(AnimXParms.TargetSyncPos, true);
        DisableDesiredRotation_Roll(Rotator(AnimXParms.TargetFacePos - AnimXParms.TargetSyncPos));
        EnableMovement(false);
        Acceleration = Vect(0, 0, 0);
        Velocity = Vect(0, 0, 0);
        // End:0xA6
        if((IsReadyForSyncAnim()) && ! AnimXParms.SyncActor || AnimXParms.TargetSyncActor.IsReadyForSyncAnim())
        {
            return StartSyncedAnim();
        }
        // End:0xC4
        if(AnimXParms.SyncWaitAnimName != 'None')
        {
            Anim_Idle();            
        }
        else
        {
            // End:0x10D
            if(! PlayAnimX(AnimXParms.SyncWaitAnimName, false, AnimXParms.RefId))
            {
                ExitAIState(3, "Could not play sync waitanim.");
                return false;
            }
        }
        return true;
        return;
    }

    function bool SetModeSyncAnim()
    {
        AnimXParms.Mode = 8;
        MoveToward(AnimXParms.TargetSyncPos, true);
        DisableDesiredRotation_Roll(Rotator(AnimXParms.TargetFacePos - AnimXParms.TargetSyncPos));
        EnableMovement(false);
        Acceleration = Vect(0, 0, 0);
        Velocity = Vect(0, 0, 0);
        SetAnimSync(0, 0, 0, 1, 0);
        // End:0xFF
        if(! PlayAnimX(AnimXParms.AnimName, AnimXParms.UseExactAnimName, AnimXParms.RefId))
        {
            // End:0xDF
            if(AnimXParms.bSucceedOnFail)
            {
                ExitAIState(2, "Failed to play anim but thats ok");                
            }
            else
            {
                ExitAIState(3, "Could not play anim.");
            }
            return false;
        }
        MovementFudge();
        return true;
        return;
    }

    function bool PlayAnimX(name AnimName, bool UseExactName, out int RefId)
    {
        // End:0x1A
        if(! PlayAnim(AnimName,, false, UseExactName))
        {
            return false;
        }
        RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        // End:0x90
        if(RefId <= 0)
        {
            BroadcastLog((("DCR Got INvalid RefID Back???: AnimName: " $ string(AnimName)) @ " RefID: ") $ string(RefId));
        }
        return true;
        return;
    }

    function MovementFudge()
    {
        local Vector MoveTarget;

        MoveTarget = Location + (Vector(Rotation) * 10000);
        GetLookTargetLocation(MoveTarget);
        MoveToEx(MoveTarget, 0, 0);
        GetAimTargetActor();
        return;
    }

    function MovementFudgePos(Vector MoveTarget, Vector FaceTarget, float Speed)
    {
        GetAimTargetLocation(FaceTarget);
        GetLookTargetLocation(MoveTarget);
        MoveToEx(MoveTarget, Speed, 0);
        return;
    }

    function MovementFudgeActor(Actor MoveTarget, float Speed)
    {
        ClearAimTarget(MoveTarget);
        ClearLookTarget(MoveTarget);
        MoveToEx(MoveTarget.Location, Speed, 0);
        return;
    }

    function bool ValidSyncParty()
    {
        local AIActor OthersSyncActor;

        // End:0x6C
        if(AnimXParms.SyncActor && (((AnimXParms.TargetSyncActor != none) || AnimXParms.TargetSyncActor.bDeleteMe) || ! AnimXParms.TargetSyncActor.IsSyncing(OthersSyncActor)) || OthersSyncActor == self)
        {
            return false;
        }
        return true;
        return;
    }

    function CheckSnapToGoal()
    {
        local float Dist;
        local Vector ActualMovement, DesiredMovement, NewLocation, StartingLocation;
        local int FinalPos;

        // End:0x35
        if(IsFlying())
        {
            ActualMovement = Location - PreviousLocation;
            DesiredMovement = AnimXParms.TargetSyncPos - PreviousLocation;            
        }
        else
        {
            ActualMovement = (Location - PreviousLocation) * Vect(1, 1, 0);
            DesiredMovement = (AnimXParms.TargetSyncPos - PreviousLocation) * Vect(1, 1, 0);
        }
        // End:0x11D
        if((VSizeSquared(DesiredMovement) > 0) && VSizeSquared(ActualMovement) > VSizeSquared(DesiredMovement))
        {
            StartingLocation = Location;
            NewLocation = AnimXParms.TargetSyncPos;
            // End:0x115
            if(! IsFlying() && Abs(AnimXParms.TargetSyncPos.Z - Location.Z) > (CollisionHeight / 4))
            {
                NewLocation.Z = Location.Z;
            }
            MoveToward(NewLocation);
        }
        return;
    }

    event Landed(Vector HitNormal, Actor LandedOnActor)
    {
        super(Pawn).Landed(HitNormal, LandedOnActor);
        // End:0x30
        if(AnimXParms.bExitOnLand)
        {
            ExitAIState(2, "landed");
            return;
        }
        return;
    }
Begin:

    stop;            
}

state ControlX
{
    event BeginState()
    {
        SaveAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        // End:0x1F
        if(! bExpanding)
        {
            bUsable = true;
        }
        DisablePhysics = true;
        ControlXParms.IsControlled = false;
        SetAnimSync(1, 1, 1, 2, 2);
        bUseHealthRecovery = true;
        HealthRecoveryState = 1;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        DisablePhysics = default.DisablePhysics;
        ControlXParms.IsControlled = false;
        bUsable = default.bUsable;
        // End:0x5C
        if(ControlXParms.MyControl == none)
        {
            ControlXParms.MyControl.GetGravity();
        }
        bUseHealthRecovery = false;
        return;
    }

    event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
    {
        local PlayerPawn Player;

        Player = PlayerPawn(Instigator);
        // End:0x58
        if((ControlXParms.DieOnTakeDamage && Player == none) && Damage > 0)
        {
            GetStateName('None');
            DeathAnimChance = 0;
            EnableIKSystem(1E-05);
        }
        super(Pawn).TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
        return;
    }

    function HurtRadiusActivity(Actor DamageInstigator, float DamageAmount, Vector DamageOrigin, float DamageRadius, float DamageFalloffStart, class<DamageType> DamageType, Vector DamageStart, optional bool bIgnoreDrawScale, optional float RelativeScale)
    {
        global.HurtRadiusActivity(DamageInstigator, DamageAmount, DamageOrigin, DamageRadius, DamageFalloffStart, DamageType, DamageStart, bIgnoreDrawScale, RelativeScale);
        // End:0x7E
        if(MyCorpse == none)
        {
            MyCorpse.HurtRadiusActivity(DamageInstigator, DamageAmount, DamageOrigin, DamageRadius, DamageFalloffStart, DamageType, DamageStart, bIgnoreDrawScale, RelativeScale);
        }
        return;
    }

    simulated event bool ShouldDrawHUDInfoUsePhrase(Pawn TestPawn)
    {
        // End:0x0B
        if(bExpanding)
        {
            return false;
        }
        // End:0x18
        if(! bUsable)
        {
            return false;
        }
        // End:0x44
        if(ControlXParms.MyControl == none)
        {
            return ControlXParms.MyControl.ShouldDrawHUDInfoUsePhrase(TestPawn);
        }
        return super(InteractiveActor).ShouldDrawHUDInfoUsePhrase(TestPawn);
        return;
    }

    simulated event string GetUsePhrase()
    {
        // End:0x27
        if(ControlXParms.MyControl == none)
        {
            return ControlXParms.MyControl.GetUsePhrase();
        }
        return super(InteractiveActor).GetUsePhrase();
        return;
    }

    event Used(Actor Other, Pawn Instigator)
    {
        // End:0x23
        if((ControlXParms.MyControl != none) || ControlXParms.IsControlled)
        {
            return;
        }
        ControlXParms.MyControl.Used(Other, Instigator);
        // End:0x76
        if(ControlXParms.MyControl.User != Instigator)
        {
            ControlXParms.IsControlled = true;
            bUsable = false;
        }
        Spawn('TimeOutControlX');
        ControlXUsed();
        return;
    }

    simulated function bool CanBeUsedBy(Pawn TestPawn)
    {
        // End:0x2E
        if(((ControlXParms.MyControl != none) || ControlXParms.IsControlled) || bExpanding)
        {
            return false;
        }
        return ControlXParms.MyControl.CanBeUsedBy(TestPawn);
        return;
    }

    function EndControlX_Lived()
    {
        WasExecuted = false;
        ControlXParms.IsControlled = false;
        bUsable = false;
        FinishMeReviveAnimName = 'None';
        ExitAIState(3, "EndControlX_Lived");
        return;
    }

    function EndControlX_Died()
    {
        ExitAIState(2, "EndControlX_Died");
        return;
    }

    function TimeOutControlX()
    {
        // End:0x74
        if(bExpanding)
        {
            DeathAnimChance = 0;
            Died(ExpandInstigator,,,, class'ExpandDeathDamageType');
            // End:0x71
            if((MyCorpse == none) && NameForString(ExpandingBoneName, 'None'))
            {
                PlaySoundInfo(0, ExpandPopSound);
                MyCorpse.InitFriendData(UpdateScaleModifier(Mesh, ExpandingBoneName),,,, true, true);
            }            
        }
        else
        {
            ExitAIState(3, "TimeOutControlX");
        }
        return;
    }

    function ExecuteControlX()
    {
        // End:0x25
        if(NameForString(ControlXParms.AnimName, 'None'))
        {
            PlayAnim(ControlXParms.AnimName);
        }
        Destroy(ControlXParms.Time, false, 'TimeOutControlX');
        return;
    }
Begin:

    ExecuteControlX();
LoopPoint:


    // End:0x63
    if((ControlXParms.MyControl == none) && ControlXParms.MyControl.MountOrigin != PostPivot)
    {
        ControlXParms.MyControl.MountOrigin = PostPivot;
        ControlXParms.MyControl.SetMass();
    }
    SpawnAmmoCasing(1E-05);
    GetStateName(, 'LoopPoint');
    stop;            
}

state Fall
{
    event BeginState()
    {
        SaveAnimSync();
        FallParms.Mode = 0;
        FallParms.RefId = -1;
        FallParms.AnimSet = 0;
        FallParms.StartZ = Location.Z;
        AlignYaw = default.AlignYaw;
        GetAimTargetActor();
        GetLookTargetActor();
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        AlignYaw = default.AlignYaw;
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x2B
        if(RefId != FallParms.RefId)
        {
            return;
        }
        switch(FallParms.Mode)
        {
            // End:0x47
            case 0:
                ExecuteModeFall();
                return;
                // End:0x7F
                break;
            // End:0x56
            case 1:
                ExecuteModeFall();
                return;
                // End:0x7F
                break;
            // End:0x71
            case 2:
                ExitAIState(2, "Landed.");
                return;
                // End:0x7F
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0x7F
                break;
                break;
        }
        return;
    }

    event PhysicsChange(optional Engine.Object.EPhysics PreviousPhysics)
    {
        // End:0x26
        if((int(Physics) == int(2)) && FallParms.Mode != 1)
        {
            ExecuteModeStartFall();
        }
        return;
    }

    event Landed(Vector HitNormal, Actor LandedOnActor)
    {
        global.Landed(HitNormal, LandedOnActor);
        ExecuteModeLand();
        return;
        return;
    }

    event HitWall(Vector WallNormal, Actor WallActor)
    {
        return;
    }

    event bool ShouldAbortMovement()
    {
        return false;
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x1F
        if((FallParms.Mode != 2) && XBoxIsSignedIn())
        {
            ExecuteModeLand();
        }
        return;
    }

    function ExecuteModeStartFall()
    {
        // End:0x3C
        if(HasStartFallAnim)
        {
            Anim_StartFall(FallParms.AnimSet);
            FallParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();            
        }
        else
        {
            ExecuteModeFall();
        }
        return;
    }

    function ExecuteModeFall()
    {
        FallParms.Mode = 1;
        Anim_Fall(FallParms.AnimSet);
        FallParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        return;
    }

    function ExecuteModeLand()
    {
        local float FallDist;

        FallDist = FallParms.StartZ - Location.Z;
        // End:0x5E
        if(FallDist < FallParms.LandingThresh)
        {
            ExitAIState(2, "FallDist < FallParms.LandingThresh");
            return;
        }
        FallParms.Mode = 2;
        RestoreSavedAnimSync();
        // End:0xAE
        if((FallParms.HeavyLandingThresh > 0) && FallDist > FallParms.HeavyLandingThresh)
        {
            Anim_HeavyLanding(FallParms.AnimSet);            
        }
        else
        {
            Anim_Landing(FallParms.AnimSet);
        }
        FallParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        return;
    }
Begin:

    ExecuteModeStartFall();
    stop;    
}

state FireWeaponX
{
    event BeginState()
    {
        SaveAnimSync();
        WeaponManager.NoFire = false;
        WeaponManager.ForceFire = true;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        WeaponManager.NoFire = default.WeaponManager.NoFire;
        WeaponManager.ForceFire = default.WeaponManager.ForceFire;
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x2A
        if(WeaponManager.ShotCount <= 0)
        {
            ExitAIState(2, "Fired all shots.");
        }
        return;
    }
Begin:

    stop;            
}

state FUBAR
{Begin:

    stop;            
}

state GotoX
{
    event BeginState()
    {
        EnableMovement(true);
        SaveAnimSync();
        // End:0x47
        if(IsFlying())
        {
            // End:0x37
            if(GotoXParms.bUseAccelerationWhenFlying)
            {
                SetAnimSync(0, 0, 0, 0, 1);                
            }
            else
            {
                SetAnimSync(0, 0, 0, 0, 2);
            }
        }
        MovingFireGate = Level.GameTimeSeconds + 0.25;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        ClearGotoX();
        return;
    }

    event UpdateStateOPNotWorking(float DeltaSecs)
    {
        // End:0x2C
        if(int(GotoXParms.Mode) == int(13))
        {
            ClearGotoX();
            Anim_Idle();
            GotoXParms.Mode = 0;
        }
        return;
    }

    final function ClearGotoX()
    {
        RestoreSavedAnimSync();
        PhysicsParms.bDisablePhysicsConstraints = false;
        EnableMovement(false);
        GetAimTargetActor();
        GetLookTargetActor();
        GotoXParms.Mode = 13;
        return;
    }

    event ExitAIState(Engine.BaseAI.EAIStateStatus Status, optional string DbgMsg)
    {
        global.ExitAIState(Status, DbgMsg);
        return;
    }

    event TickState(float Secs)
    {
        CheckStuck(Secs);
        // End:0x47
        if(((int(Executive) != int(1)) && int(CurrentOpStatus) == int(1)) && GotoXParms.StuckTime > 3)
        {
            EndOp(3);
        }
        return;
    }

    event TickPathRover()
    {
        local int FinalDest;
        local Vector NextPos;
        local Engine.BaseAI.EAICode Code;

        Code = GetNextPosition(NextPos, FinalDest);
        // End:0x5F
        if(int(Code) == int(0))
        {
            GetVisibilityPoint(NextPos, NewColorBytes(0, 255, 0), 0.001);
            DisableDesiredRotation(NextPos,, 5,,,, Vect(80, 80, 80));            
        }
        else
        {
            BroadcastLog("DCR PhysRover failed in pathing");
        }
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        local int FinalPos, i;
        local Vector NewLocation;

        // End:0x1C
        if(bPathRover)
        {
            PercentageMoved = 1;
            TickPathRover();
            return;
        }
        // End:0x37
        if(int(GotoXParms.Mode) == int(6))
        {
            UpdateDoor();
            return;
        }
        // End:0x4C
        if(int(GotoXParms.Mode) == int(3))
        {
            return;
        }
        // End:0x8F
        if((GotoXParms.ExitOnLand && IsFlying()) && ! InAir(GotoXParms.ExitOnLandHeight))
        {
            ExitAIState(2, "Landed.");
            return;
        }
        CheckSnapToGoal();
        UpdateEvalGate();
        // End:0x203
        if(ReachedNextPos(FinalPos))
        {
            // End:0xD0
            if(GotoXParms.bDebug)
            {
                GetVisibilityPoint(Location, NewColorBytes(0, 255, 0), 1);
            }
            // End:0x120
            if(FinalPos > 0)
            {
                // End:0xFE
                if(GotoXParms.bDebug)
                {
                    BroadcastLog(string(self) @ "IM THERE");
                }
                ExitAIState(2, "Reached final dest.");
                return;                
            }
            else
            {
                ExecuteGotoX();
                // End:0x1FE
                if(! IsFlying())
                {
                    i = 0;
                    J0x138:

                    // End:0x1FE [Loop If]
                    if((++ i < 1) && ReachedNextPos(FinalPos))
                    {
                        // End:0x1A0
                        if(GotoXParms.bDebug)
                        {
                            BroadcastLog((string(self) @ "ReachNextPos: ") $ string(i));
                            GetVisibilityPoint(Location, NewColorBytes(255, 0, 255), 1);
                        }
                        NewLocation = GotoXParms.NextPos;
                        // End:0x1D5
                        if(Abs(NewLocation.Z - Location.Z) > CollisionHeight)
                        {
                            // [Explicit Break]
                            goto J0x1FE;
                        }
                        NewLocation.Z = Location.Z;
                        SetLocationMeqon(NewLocation);
                        ExecuteGotoX();
                        // [Loop Continue]
                        goto J0x138;
                    }
                }
                J0x1FE:

                return;
            }            
        }
        else
        {
            // End:0x2C4
            if(((! GotoXParms.bDisableEvalGate && GotoXParms.EvalGate >= 0) && Level.NumAGotoXEvalPerFrame > 0) && (GotoXParms.EvalGate == 0) || (GotoXParms.EvalGateTime + GotoXParms.EvalGate) <= Level.GameTimeSeconds)
            {
                -- Level.NumAGotoXEvalPerFrame;
                // End:0x2BE
                if(GotoXParms.EvalGate > float(0))
                {
                    GotoXParms.EvalGateTime = Level.GameTimeSeconds;
                }
                ExecuteGotoX();
            }
        }
        UpdateBodyTarget();
        return;
    }

    event UpdateBodyTarget()
    {
        // End:0x1C
        if(int(GotoXParms.Focus) == int(4))
        {
            GotoNextPosFocusActorFullBody();            
        }
        else
        {
            SetMoveParms();
            // End:0x3E
            if(int(GotoXParms.Mode) == int(4))
            {
                SetBodyTargetStepLeft();                
            }
            else
            {
                // End:0x57
                if(int(GotoXParms.Mode) == int(5))
                {
                    SetBodyTargetStepRight();
                }
            }
        }
        return;
    }

    event ExecuteGotoX()
    {
        local Engine.BaseAI.EAICode Code;
        local int FinalDest;
        local Vector NextPos;

        ++ GotoXParms.EvalCount;
        Code = GetNextPosition(NextPos, FinalDest);
        // End:0x43
        if(int(Code) == int(0))
        {
            SetNewNextPos(NextPos, FinalDest);            
        }
        else
        {
            // End:0x96
            if(int(Code) == int(9))
            {
                // End:0x74
                if(GotoXParms.bDebug)
                {
                    BroadcastLog(string(self) $ "IN RANGE");
                }
                ExitAIState(2, "Reached final dest.");
                return;                
            }
            else
            {
                // End:0xBA
                if(PathInfo.bFailedInDynamicPathing)
                {
                    GotoXParms.bWaitingOnDynamicBlocker = true;
                    ExecuteWait();                    
                }
                else
                {
                    // End:0x114
                    if(GotoXParms.bDebug)
                    {
                        BroadcastLog((((string(self) @ "[tag=") $ string(Tag)) $ "] failed pathing!. Code : ") $ string(DynamicLoadObject(class'EAICode', int(Code))));
                    }
                    ExitAIState(3, "Path Failed: " $ string(DynamicLoadObject(class'EAICode', int(Code))));
                }
                return;
            }
        }
        GotoXParms.bWaitingOnDynamicBlocker = false;
        GotoNextPos();
        SetMoveParms();
        return;
    }

    function SetNewNextPos(Vector NewNextPos, int NewFinalDest)
    {
        local Vector OldVelocity, NewDir, NewVelocity;

        // End:0x60
        if(! IsFalling() && ! bUseAcceleration)
        {
            GetConstraintCount(OldVelocity);
            NewDir = NewNextPos - Location;
            NewVelocity = Normal(NewDir) * VSize(OldVelocity);
            NewVelocity.Z = 0;
            KPushGeneratedSimpleState(NewVelocity);
        }
        // End:0x84
        if(bAnimCutScene && DumbAI)
        {
            DisableDesiredRotation_Roll(Rotator(NewNextPos - Location));
        }
        GotoXParms.NextPos = NewNextPos;
        GotoXParms.FinalDest = NewFinalDest;
        return;
    }

    function Engine.BaseAI.EAICode GetNextPosition(out Vector NextPos, out int FinalDest)
    {
        local Engine.BaseAI.EAICode Code;

        PathInfo.TargetExtent = GotoXParms.TargetExtent;
        // End:0x87
        if(int(GotoXParms.TargetType) == int(2))
        {
            Code = CanGotoActorOffset(GotoXParms.TargetActor, GotoXParms.RefActor, GotoXParms.OffsetType, GotoXParms.Range, GotoXParms.Bearing, GotoXParms.Height, GotoXParms.ClipTolerance, NextPos, FinalDest);            
        }
        else
        {
            Code = CanGotoPos(GotoXParms.TargetPos, GotoXParms.RefActor, GotoXParms.Range, GotoXParms.Height, GotoXParms.ClipTolerance, NextPos, FinalDest);
        }
        return Code;
        return;
    }

    function GotoNextPos()
    {
        switch(GotoXParms.Focus)
        {
            // End:0x38
            case 3:
                // End:0x2F
                if(GotoXParms.SideStepDistThresh > 0)
                {
                    GotoNextPosFocusActor();                    
                }
                else
                {
                    GotoNextPosFocusActorNoSidestep();
                }
                // End:0x70
                break;
            // End:0x46
            case 4:
                GotoNextPosFocusActorFullBody();
                // End:0x70
                break;
            // End:0x54
            case 1:
                GotoNextPosFocusTargetPos();
                // End:0x70
                break;
            // End:0x62
            case 2:
                GotoNextPosFocusReciprocalTargetPos();
                // End:0x70
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0x70
                break;
                break;
        }
        return;
    }

    function bool ReachedNextPos(out int FinalPos)
    {
        // End:0x62
        if(int(GotoXParms.TargetType) == int(2))
        {
            // End:0x62
            if(AtActorOffset(GotoXParms.TargetActor, GotoXParms.OffsetType, GotoXParms.Range, GotoXParms.Bearing, GotoXParms.Height))
            {
                FinalPos = 1;
                PercentageMoved = 1;
                return true;
            }
        }
        // End:0x99
        if(PosInAcceptableProx(GotoXParms.TargetPos, GotoXParms.Range + CollisionRadius, GotoXParms.Height))
        {
            FinalPos = 1;
            return true;
        }
        // End:0xCC
        if(! IsFlying() && PosInAcceptableHorizProx(GotoXParms.TargetPos, GotoXParms.Range))
        {
            FinalPos = 1;
            return true;
        }
        // End:0xEB
        if(PosInAcceptableProx(GotoXParms.NextPos, 0, 0))
        {
            return true;
        }
        return false;
        return;
    }

    event bool UpdateFaceTarget(Vector DirTo, Vector CurDir)
    {
        local Engine.BaseAI.EAIArcSector TargetsSector;
        local int TurnDir;
        local name AnimName;

        TargetsSector = CalcSector(GotoXParms.FacePos, 10, 180);
        // End:0x7E
        if(GotoXParms.bDebug)
        {
            GetSlotVolume(Location, GotoXParms.FacePos, NewColorBytes(0, 255, 0), 0.01);
            GetSlotVolume(Location, Location + (Vector(Rotation) * 50), NewColorBytes(255, 0, 0), 0.01);
        }
        // End:0x103
        if(int(TargetsSector) == int(0))
        {
            // End:0xE1
            if(GotoXParms.bDebug)
            {
                IsSoundPlayingOnSlot(Location, Vector(Rotation), NewColorBytes(255, 255, 0), 50, 10);
                GetSlotVolume(Location, GotoXParms.FacePos, NewColorBytes(0, 255, 0), 10.01);
            }
            FinalizeTurn(GotoXParms.FacePos);
            EnableMovement(true);
            ExecuteGotoX();
            return true;            
        }
        else
        {
            AnimName = CalcTurnAnim(GotoXParms.FacePos, TurnDir, false);
            // End:0x19C
            if(TurnDir != GotoXParms.TurnDir)
            {
                // End:0x169
                if(GotoXParms.TurnDir != -1)
                {
                    FinalizeTurn(GotoXParms.FacePos);
                    EnableMovement(true);
                    ExecuteGotoX();
                    return true;                    
                }
                else
                {
                    // End:0x181
                    if(! IsPlayingOnChannel(AnimName, 0))
                    {
                        EnableMovement(false);
                    }
                    GotoXParms.TurnDir = TurnDir;
                    PlayAnim(AnimName);
                }
            }
        }
        return false;
        return;
    }

    event GetFaceTargetLocation(out Vector OutLocation)
    {
        OutLocation = GotoXParms.FacePos;
        return;
        return;
    }

    function SetMoveParms()
    {
        // End:0x15
        if(int(GotoXParms.Mode) == int(3))
        {
            return;
        }
        SetAnimSync(0, GotoXParms.UseAnimDispDirMod, 2, 0, 0);
        RestoreDefaultBodyAlignRate();
        return;
    }

    function SetLocationMeqon(Vector NewLocation)
    {
        // End:0x45
        if(GotoXParms.bDebug)
        {
            GetSlotVolume(NewLocation, Location, NewColorBytes(255, 0, 255), 3);
            GetVisibilityPoint(NewLocation, NewColorBytes(255, 0, 255), 3);
        }
        MoveToward(NewLocation);
        PercentageMoved = 1;
        return;
    }

    function CheckSnapToGoal()
    {
        local float Dist;
        local Vector ActualMovement, DesiredMovement, NewLocation, StartingLocation;
        local int FinalPos;

        // End:0x35
        if(IsFlying())
        {
            ActualMovement = Location - PreviousLocation;
            DesiredMovement = GotoXParms.NextPos - PreviousLocation;            
        }
        else
        {
            ActualMovement = (Location - PreviousLocation) * Vect(1, 1, 0);
            DesiredMovement = (GotoXParms.NextPos - PreviousLocation) * Vect(1, 1, 0);
        }
        // End:0x1CF
        if((VSizeSquared(DesiredMovement) > 0) && VSizeSquared(ActualMovement) > VSizeSquared(DesiredMovement))
        {
            // End:0x123
            if(GotoXParms.bDebug)
            {
                BroadcastLog(((string(self) @ "snap - ") $ string(VSizeSquared(ActualMovement))) @ string(VSizeSquared(DesiredMovement)));
                GetSlotVolume(GotoXParms.NextPos, PreviousLocation, NewColorBytes(255, 0, 0), 10);
                GetSlotVolume(Location, PreviousLocation, NewColorBytes(0, 255, 0), 10);
            }
            StartingLocation = Location;
            NewLocation = GotoXParms.NextPos;
            // End:0x18E
            if(! IsFlying() && Abs(GotoXParms.NextPos.Z - Location.Z) > (CollisionHeight / 4))
            {
                NewLocation.Z = Location.Z;
            }
            SetLocationMeqon(NewLocation);
            // End:0x1C9
            if(! ReachedNextPos(FinalPos))
            {
                NewLocation.Z = StartingLocation.Z;
                SetLocationMeqon(NewLocation);
            }
            ExecuteGotoX();
        }
        return;
    }

    function UpdateEvalGate()
    {
        // End:0x1F
        if(EvalGateOverride >= -1)
        {
            GotoXParms.EvalGate = EvalGateOverride;
        }
        // End:0x4A
        if(PathInfo.bIsDynamicPathing)
        {
            GotoXParms.EvalGate = Level.AIEvalGateTime;            
        }
        else
        {
            GotoXParms.EvalGate = Level.AIEvalGateTimeDynamicPathing;
        }
        return;
    }

    function bool CheckStuck(float DeltaSeconds)
    {
        // End:0x47
        if(PercentageMoved < 0.25)
        {
            GotoXParms.StuckTime += DeltaSeconds;
            // End:0x44
            if(GotoXParms.Range <= 0)
            {
                GotoXParms.Range = CollisionRadius;
            }            
        }
        else
        {
            GotoXParms.StuckTime = 0;
        }
        // End:0x125
        if(GotoXParms.bWaitingOnDynamicBlocker)
        {
            GotoXParms.bWaitTime += DeltaSeconds;
            // End:0x122
            if(GotoXParms.bWaitTime > 1)
            {
                // End:0xFD
                if(GotoXParms.bDebug)
                {
                    BroadcastLog(((string(self) @ "[tag=") $ string(Tag)) $ "] failed pathing. Reason: Dynamic Blocker is completely blocking path");
                }
                ExitAIState(3, "Path Failed: Dynamic Shit");
                return false;
            }            
        }
        else
        {
            GotoXParms.bWaitTime = 0;
            // End:0x1B1
            if((! GotoXParms.bWaitingOnDynamicBlocker && GotoXParms.StuckTime > 0.5) && GotoXParms.ConstraintStrengthOverride <= 0)
            {
                // End:0x193
                if(int(GetDynamicPathingPriority()) == int(7))
                {
                    GotoXParms.ConstraintStrengthOverride = 2025;                    
                }
                else
                {
                    GotoXParms.ConstraintStrengthOverride = 25;
                }
                Destroy(5, false, 'RestoreConstraintStrengthOverride');
            }
            // End:0x20D
            if((! GotoXParms.bWaitingOnDynamicBlocker && GotoXParms.StuckTime > 1) && ! PhysicsParms.bDisablePhysicsConstraints)
            {
                // End:0x20D
                if(CanDisablePhysicsConstraintsInStateGotoX())
                {
                    PhysicsParms.bDisablePhysicsConstraints = true;
                    Destroy(2.5, false, 'RestorePhysicsCollision');
                }
            }
        }
        return true;
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x2B
        if(RefId != GotoXParms.RefId)
        {
            return;
        }
        // End:0x70
        if(GotoXParms.MaxSteps > 0)
        {
            -- GotoXParms.MaxSteps;
            // End:0x70
            if(GotoXParms.MaxSteps == 0)
            {
                ExitAIState(3, "Max steps hit");
                return;
            }
        }
        switch(GotoXParms.Mode)
        {
            // End:0x85
            case 3:
                // End:0xAA
                break;
            // End:0x8D
            case 6:
                // End:0xAA
                break;
            // End:0xA7
            case 7:
                GotoXParms.MyDoorEx = none;
                ExecuteGotoX();
                // End:0xAA
                break;
            // End:0xFFFF
            default:
                break;
        }
        return;
    }

    event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector Position, Vector ImpactVelocity, Vector ImpactNormal)
    {
        local DoorMoverEx Door;

        global.KImpact(SelfBoneName, Other, OtherBoneName, Position, ImpactVelocity, ImpactNormal);
        // End:0x39
        if(int(GotoXParms.Mode) == int(12))
        {
            return;
        }
        Door = DoorMoverEx(Other);
        // End:0x14A
        if(Door == none)
        {
            // End:0x7F
            if((int(GotoXParms.Mode) == int(6)) || int(GotoXParms.Mode) == int(7))
            {
                return;
            }
            // End:0xA7
            if(! CanOpenDoors)
            {
                ExitAIState(3, "Cannot Open Door.");
                return;
            }
            GotoXParms.MyDoorEx = Door;
            // End:0xEA
            if(GotoXParms.MyDoorEx.bLocked)
            {
                ExitAIState(3, "Door is locked.");
                return;
            }
            // End:0x10B
            if(GotoXParms.MyDoorEx.IsClosed())
            {
                ExecuteOpenDoor();                
            }
            else
            {
                // End:0x12C
                if(GotoXParms.MyDoorEx.IsClosing())
                {
                    ExecuteMaybeOpenDoorEx();                    
                }
                else
                {
                    // End:0x14A
                    if(GotoXParms.MyDoorEx.IsOpening())
                    {
                        ExecuteWaitDoor();
                    }
                }
            }
        }
        return;
    }

    event bool ShouldOpenDoor(DoorMoverEx Door)
    {
        local Vector doorDirection, MyDir, FacingDir, DirToDoor;
        local float D;

        // End:0x0D
        if(! bAutoOpenDoors)
        {
            return false;
        }
        FacingDir = Normal(Vector(Rotation));
        DirToDoor = Normal(Door.DoorMidpoint - Location);
        D = FacingDir Dot DirToDoor;
        // End:0x5C
        if(D > 0.85)
        {
            return true;
        }
        // End:0x91
        if((VSize(Door.DoorMidpoint - Location) < 30) && D > 0.55)
        {
            return true;
        }
        return false;
        return;
    }

    event name GetWeaponIdleName()
    {
        return 'Anim_ShootIdle';
        return;
    }

    event bool ShouldDampenWhileTurning()
    {
        return false;
        return;
    }

    event float CalculateGroundConstraintStrengthScalar()
    {
        // End:0x1F
        if(GotoXParms.ConstraintStrengthOverride > 0)
        {
            return GotoXParms.ConstraintStrengthOverride;
        }
        return global.CalculateGroundConstraintStrengthScalar();
        return;
    }

    function RestoreConstraintStrengthOverride()
    {
        GotoXParms.ConstraintStrengthOverride = -1;
        return;
    }

    function RestorePhysicsCollision()
    {
        PhysicsParms.bDisablePhysicsConstraints = false;
        return;
    }

    event bool ShouldAlwaysBeDynamicallyPathedAround()
    {
        // End:0x25
        if(GotoXParms.bWaitingOnDynamicBlocker || int(GotoXParms.Mode) == int(6))
        {
            return true;
        }
        return false;
        return;
    }

    function float CalculateFlyContraintStrengthScalar(float DeltaTime)
    {
        // End:0x14
        if(bIsFlying)
        {
            return GotoXParms.FlyConstraintStrength;
        }
        return global.CalculateFlyContraintStrengthScalar(DeltaTime);
        return;
    }

    event Landed(Vector HitNormal, Actor LandedOnActor)
    {
        global.Landed(HitNormal, LandedOnActor);
        // End:0x3C
        if(GotoXParms.ExitOnLand && IsFlying())
        {
            ExitAIState(2, "Landed.");
            return;
        }
        return;
    }
Begin:

    ExecuteGotoX();
    stop;    
}

state Haywire
{
    event BeginState()
    {
        GetSpecialEventParms();
        FinishInterpolation();
        FindStairRotation(false);
        GetCameraViewRotation(false);
        SetRotation(18);
        KImpactThreshold = 0;
        TickStyle = 3;
        HaywireParms.HaywireStartTime = Level.GameTimeSeconds;
        return;
    }

    function ImpulseTowardsTarget()
    {
        // End:0x2F
        if(PrimaryTarget.IsValidTarget())
        {
            KPushGeneratedSimpleState(PrimaryTarget.GetDirTo() * 5000, 3);
        }
        return;
    }

    event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector Position, Vector ImpactVelocity, Vector ImpactNormal)
    {
        global.KImpact(SelfBoneName, Other, OtherBoneName, Position, ImpactVelocity, ImpactNormal);
        // End:0x34
        if(int(TickStyle) != int(3))
        {
            return;
        }
        // End:0x42
        if(Other != self)
        {
            return;
        }
        // End:0x56
        if(ShouldHaywireExplode())
        {
            ExecuteHaywireExplode(ImpactNormal);
        }
        ExitAIState(2, "Impacted.");
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x5E
        if(int(TickStyle) == int(3))
        {
            // End:0x5E
            if(Level.GameTimeSeconds >= HaywireParms.MaxTime)
            {
                // End:0x4C
                if(ShouldHaywireExplode())
                {
                    ExecuteHaywireExplode(Vect(0, 0, 1));
                }
                ExitAIState(2, "Expired.");
            }
        }
        return;
    }

    event TickState(float Secs)
    {
        // End:0x38
        if(int(TickStyle) == int(3))
        {
            KHurtRadiusActivity(HaywireParms.LinearAccel >> Rotation, 3);
            StopPersistantPhysicsEffects(HaywireParms.AngularAccel >> Rotation);
        }
        return;
    }

    function CalculatePhysics_Flying(float DeltaTime)
    {
        global.CalculatePhysics_Falling(DeltaTime);
        return;
    }
Begin:

    stop;            
}

state Hide
{
    event BeginState()
    {
        AnimCtrl.m_oController.EmptyAnimChannels_AllButGroup('None');
        GetZoneLastRenderTime(true);
        StoreCollision();
        ForceMountUpdate(false, false, false, false, false);
        return;
    }

    event EndState()
    {
        GetZoneLastRenderTime(false);
        RestoreCollision();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        return;
    }
Begin:

    stop;            
}

state Jump
{
    event BeginState()
    {
        local int i;

        JumpParms.Mode = 0;
        JumpParms.AppliedJumpVel = false;
        JumpParms.RefId = -1;
        GetLookTargetActor();
        SetAnimSync(1, 1, 0, 0, 0);
        WeaponManagerHoldFire(true);
        return;
    }

    event EndState()
    {
        local int i;

        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        AlignYaw = default.AlignYaw;
        // End:0x2F
        if(! JumpParms.bRestoreIKPreLand)
        {
            EnableIK();
        }
        KLinearDamping = default.KLinearDamping;
        WeaponManagerResumeFire();
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        local float DistSq;

        // End:0x4C
        if((JumpParms.ExitTime > 0) && JumpParms.ExitTime < Level.GameTimeSeconds)
        {
            ExitAIState(2, "Time Reached");
            return;
        }
        // End:0xAE
        if(((JumpParms.Mode != 4) && JumpParms.bTakeOffNoLand) && JumpParms.TargetPos.Z != 0)
        {
            // End:0xAE
            if(Location.Z >= JumpParms.TargetPos.Z)
            {
                ExecuteModeStop();
                return;
            }
        }
        // End:0xFD
        if(JumpParms.bTakeOffNoLand && JumpParms.Mode == 2)
        {
            // End:0xFD
            if(Velocity.Z < 0)
            {
                ExitAIState(2, "Peaked takeoff");
                return;
            }
        }
        switch(JumpParms.Mode)
        {
            // End:0x111
            case 0:
                // End:0x15F
                break;
            // End:0x123
            case 1:
                UpdateTakeOff(DeltaSecs);
                // End:0x15F
                break;
            // End:0x136
            case 2:
                UpdateFall(DeltaSecs);
                // End:0x15F
                break;
            // End:0x149
            case 3:
                UpdateLand(DeltaSecs);
                // End:0x15F
                break;
            // End:0x15C
            case 4:
                UpdateStop(DeltaSecs);
                // End:0x15F
                break;
            // End:0xFFFF
            default:
                break;
        }
        return;
    }

    function DisableIK()
    {
        // End:0x14
        if(JumpParms.bDisableIK)
        {
            AIDisableIK();
        }
        return;
    }

    function EnableIK()
    {
        // End:0x14
        if(JumpParms.bDisableIK)
        {
            AIEnableIK();
        }
        return;
    }

    function UpdateTakeOff(float DeltaSecs)
    {
        local float Speed;

        // End:0x9F
        if(JumpParms.bUseAccelaration)
        {
            Speed = VSize(Velocity);
            KHurtRadiusActivity((JumpParms.JumpVel * JumpParms.AccelerationScale) + JumpParms.Fudge, 3);
            // End:0x9F
            if(VSize(Velocity) > (VSize(JumpParms.JumpVel) * 0.5))
            {
                JumpParms.AppliedJumpVel = true;
                KHurtRadiusActivity(Vect(0, 0, 0), 1);
                ExecuteModeFall();
                JumpParms.FrameVelocity = JumpParms.JumpVel;
            }
        }
        return;
    }

    function UpdateLand(float DeltaSecs)
    {
        local Vector Delta;

        CheckSnapToTarget(DeltaSecs);
        // End:0xEE
        if(JumpParms.bRequireCompleteSnap && JumpParms.bLandAnimComplete)
        {
            Delta = JumpParms.TargetPos - Location;
            SetAnimSync(2, 2, 0, 0, 0);
            GetLookTargetLocation(JumpParms.TargetPos);
            MoveToEx(JumpParms.TargetPos, 1, 0);
            JumpParms.bSnapActive = true;
            Delta.Z = 0;
            // End:0xC4
            if(VSize(Delta) <= CollisionRadius)
            {
                ExitAIState(2, "Hit landing spot w00t");
            }
            ExitAIState(3, "Landed but not at destination");            
        }
        return;
    }

    function UpdateFall(float DeltaSecs)
    {
        CheckSnapToTarget(DeltaSecs);
        // End:0x47
        if(JumpParms.FaceTarget && PrimaryTargetActor == none)
        {
            ClearAimTarget(PrimaryTargetActor);
            SetAnimSync(0, 0, 2, 0, 0);
            AlignYaw = true;
        }
        return;
    }

    function UpdateStop(float DeltaSecs)
    {
        local Vector LinearVelocity;

        GetConstraintCount(LinearVelocity);
        // End:0x2A
        if(VSizeSquared(LinearVelocity) < 150)
        {
            ExitAIState(2, "Stopped");
        }
        return;
    }

    function CheckSnapToTargetJetPack(float DeltaSecs)
    {
        return;
    }

    function CheckSnapToTarget(float DeltaSecs)
    {
        local Vector Dir;
        local float Dist2DSq, DeltaHeight;

        // End:0x103
        if((JumpParms.Mode != 1) && ((Velocity.Z < float(0)) || JumpParms.Mode == 3) && JumpParms.bSnapToTargetDuringLand)
        {
            Dir = Location - JumpParms.TargetPos;
            DeltaHeight = Dir.Z;
            Dir.Z = 0;
            Dist2DSq = VSizeSquared(Dir);
            // End:0x103
            if((Dist2DSq < ((CollisionRadius * CollisionRadius) * float(16))) && Abs(DeltaHeight) < (CollisionHeight * 4))
            {
                SetAnimSync(2, 2, 0, 0, 0);
                GetLookTargetLocation(JumpParms.TargetPos);
                MoveToEx(JumpParms.TargetPos, 1, 0);
                JumpParms.bSnapActive = true;
            }
        }
        return;
    }

    animevent simulated function AnimEvent_ApplyJumpVelocity(optional EventInfo AnimEventInfo)
    {
        AlignYaw = false;
        // End:0x19
        if(JumpParms.bUseAccelaration)
        {            
        }
        else
        {
            // End:0x57
            if((int(Physics) == int(18)) && bPhysicsControllerActive)
            {
                JumpParms.FrameVelocity = JumpParms.JumpVel;
                JumpParms.AppliedJumpVel = true;                
            }
            else
            {
                Velocity += JumpParms.JumpVel;
                JumpParms.AppliedJumpVel = true;
            }
        }
        // End:0xD6
        if((JumpParms.Mode != 2) && JumpParms.bTakeOffNoLand)
        {
            NotifyTakeOff();
            // End:0xD6
            if(JumpParms.TakeOffIdleTime > 0)
            {
                JumpParms.ExitTime = Level.GameTimeSeconds + JumpParms.TakeOffIdleTime;
            }
        }
        DisableIK();
        NotifyJumpTakeOff();
        FindSoundAndSpeak('Sound_Jump');
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x2B
        if(RefId != JumpParms.RefId)
        {
            return;
        }
        switch(JumpParms.Mode)
        {
            // End:0x3F
            case 0:
                // End:0xD6
                break;
            // End:0x72
            case 1:
                // End:0x59
                if(! JumpParms.AppliedJumpVel)
                {
                    AnimEvent_ApplyJumpVelocity();
                }
                // End:0x6F
                if(! JumpParms.bUseAccelaration)
                {
                    ExecuteModeFall();
                }
                // End:0xD6
                break;
            // End:0x82
            case 2:
                ExecuteModeFall();
                return;
                // End:0xD6
                break;
            // End:0xC0
            case 3:
                // End:0xAB
                if(JumpParms.bRequireCompleteSnap)
                {
                    JumpParms.bLandAnimComplete = true;
                    Anim_Idle();                    
                }
                else
                {
                    ExitAIState(2, "Landed");
                }
                return;
                // End:0xD6
                break;
            // End:0xC8
            case 4:
                // End:0xD6
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0xD6
                break;
                break;
        }
        return;
    }

    event PhysicsChange(optional Engine.Object.EPhysics PreviousPhysics)
    {
        // End:0x4E
        if(((int(Physics) == int(2)) && JumpParms.Mode != 2) && JumpParms.Mode != 1)
        {
            JumpParms.StartZ = Location.Z;
            ExecuteModeFall();
        }
        return;
    }

    event Landed(Vector HitNormal, Actor LandedOnActor)
    {
        global.Landed(HitNormal, LandedOnActor);
        // End:0x2F
        if(JumpParms.AppliedJumpVel && XBoxIsSignedIn())
        {
            ExecuteModeLand();            
        }
        return;
        return;
    }

    event HitWall(Vector WallNormal, Actor WallActor)
    {
        return;
    }

    event bool ShouldAbortMovement()
    {
        return false;
        return;
    }

    function ExecuteModeTakeOff()
    {
        local Vector MyTargetPos;

        JumpParms.Mode = 1;
        JumpParms.StartZ = Location.Z;
        MyTargetPos = Location + (Vector(Rotation) * 10000);
        GetLookTargetActor();
        AlignYaw = true;
        Anim_JumpStart(JumpParms.AnimSet);
        JumpParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        // End:0x92
        if(int(JumpParms.JumpType) == int(1))
        {
            AnimEvent_ApplyJumpVelocity();            
        }
        return;
    }

    function ExecuteModeFall()
    {
        local Vector MyTargetPos;

        // End:0x55
        if(JumpParms.Mode != 2)
        {
            Anim_Fall(JumpParms.AnimSet);
            JumpParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
            // End:0x55
            if(JumpParms.bAllowProcFireDuringFall)
            {
                WeaponManagerResumeFire();
            }
        }
        JumpParms.Mode = 2;
        AlignYaw = default.AlignYaw;
        MyTargetPos = Location + (Vector(Rotation) * 10000);
        return;
    }

    function ExecuteModeLand()
    {
        // End:0xCC
        if(JumpParms.Mode != 3)
        {
            JumpParms.AccelerationScale = 3;
            JumpParms.Mode = 3;
            RestoreSavedAnimSync();
            // End:0x82
            if((JumpParms.HeavyLandingThresh > 0) && (JumpParms.StartZ - Location.Z) > JumpParms.HeavyLandingThresh)
            {
                Anim_HeavyLanding(JumpParms.AnimSet);                
            }
            else
            {
                Anim_Landing(JumpParms.AnimSet);
            }
            JumpParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
            // End:0xC6
            if(JumpParms.bRestoreIKPreLand)
            {
                EnableIK();
            }
            NotifyJumpLand();
        }
        return;
    }

    function ExecuteModeStop()
    {
        JumpParms.Mode = 4;
        KLinearDamping = JumpParms.StopLinearDamping;
        GravityScale = 0;
        return;
    }

    event ScriptCalcRotation(out Rotator OldRotation, out Rotator NewRotation, float DeltaTime)
    {
        local float Alpha;
        local int DesiredPitch, CurrentPitch;
        local float PitchRate;
        local Vector A, B, C;

        // End:0x12
        if(! JumpParms.AutoPitch)
        {
            return;
        }
        // End:0x76
        if(JumpParms.Mode != 3)
        {
            Alpha = FClamp(Velocity.Z / JumpParms.MaxVelocity, -1, 1);
            DesiredPitch = int(Alpha * JumpParms.MaxPitch);
            PitchRate = JumpParms.PitchRate;            
        }
        else
        {
            PitchRate = JumpParms.PitchRateLand;
            DesiredPitch = 0;
        }
        CurrentPitch = Rotation.Pitch;
        // End:0xB6
        if(CurrentPitch > 32768)
        {
            CurrentPitch -= 65536;
        }
        // End:0xF1
        if(DesiredPitch < CurrentPitch)
        {
            NewRotation.Pitch = Max(int(float(CurrentPitch) + (- PitchRate * DeltaTime)), DesiredPitch);            
        }
        else
        {
            // End:0x127
            if(DesiredPitch > CurrentPitch)
            {
                NewRotation.Pitch = Min(int(float(CurrentPitch) + (PitchRate * DeltaTime)), DesiredPitch);
            }
        }
        // End:0x253
        if(JumpParms.bDebug)
        {
            BroadcastLog((((("DCR DesiredPitch=" $ string(DesiredPitch)) @ "NewRotation.Pitch=") $ string(NewRotation.Pitch)) @ "CurrentPitch=") $ string(CurrentPitch));
            A = Vector(Rot(DesiredPitch, Rotation.Yaw, 0));
            B = Vector(Rotation);
            C = Vector(NewRotation);
            GetSlotVolume(Location, Location + (Normal(A) * 50), NewColorBytes(255, 0, 0), 1E-05);
            GetSlotVolume(Location, Location + (Normal(B) * 50), NewColorBytes(0, 255, 0), 1E-05);
            GetSlotVolume(Location, Location + (Normal(C) * 50), NewColorBytes(0, 0, 255), 1E-05);
        }
        return;
    }

    event bool ShouldEnableGroundFinder(float DeltaTime)
    {
        // End:0x26
        if(JumpParms.AppliedJumpVel && Velocity.Z > 0)
        {
            return false;
        }
        return global.ShouldEnableGroundFinder(DeltaTime);
        return;
    }

    event CalculatePhysics_OnGround(float DeltaTime)
    {
        // End:0x27
        if((JumpParms.Mode == 2) && JumpParms.AppliedJumpVel)
        {
            ExecuteModeLand();
        }
        // End:0xB6
        if(JumpParms.FrameVelocity != Vect(0, 0, 0))
        {
            PhysController_ScaleGroundHeight(JumpParms.FrameVelocity);
            PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
            PhysController_GetGroundContact(2.350298E+09);
            // End:0x91
            if(JumpParms.FrameVelocity.Z > 0)
            {
                PhysController_GetGroundConstraintType(0);
            }
            // End:0xB3
            if(ContinueCampaignInProgress())
            {
                JumpParms.FrameVelocity = Vect(0, 0, 0);
            }            
        }
        else
        {
            global.CalculatePhysics_OnGround(DeltaTime);
            PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
            PhysController_GetGroundContact(2.350298E+09);
        }
        return;
    }

    function CalculatePhysics_CutScene(float DeltaTime)
    {
        // End:0x8F
        if(JumpParms.FrameVelocity != Vect(0, 0, 0))
        {
            PhysController_ScaleGroundHeight(JumpParms.FrameVelocity);
            PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
            PhysController_GetGroundContact(2.350298E+09);
            // End:0x6A
            if(JumpParms.FrameVelocity.Z > 0)
            {
                PhysController_GetGroundConstraintType(0);
            }
            // End:0x8C
            if(ContinueCampaignInProgress())
            {
                JumpParms.FrameVelocity = Vect(0, 0, 0);
            }            
        }
        else
        {
            global.CalculatePhysics_OnGround(DeltaTime);
        }
        return;
    }

    function CalculatePhysics_Falling(float DeltaTime)
    {
        // End:0x6E
        if(JumpParms.FrameVelocity != Vect(0, 0, 0))
        {
            PhysController_ScaleGroundHeight(JumpParms.FrameVelocity);
            PhysController_GetGroundConstraintType(0);
            PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
            // End:0x6B
            if(ContinueCampaignInProgress())
            {
                JumpParms.FrameVelocity = Vect(0, 0, 0);
            }            
        }
        else
        {
            global.CalculatePhysics_Falling(DeltaTime);
        }
        return;
    }

    function CalculatePhysics_Flying(float DeltaTime)
    {
        // End:0x6E
        if(JumpParms.FrameVelocity != Vect(0, 0, 0))
        {
            PhysController_ScaleGroundHeight(JumpParms.FrameVelocity);
            PhysController_GetGroundConstraintType(0);
            PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
            // End:0x6B
            if(ContinueCampaignInProgress())
            {
                JumpParms.FrameVelocity = Vect(0, 0, 0);
            }            
        }
        else
        {
            global.CalculatePhysics_Flying(DeltaTime);
        }
        return;
    }

    event bool ShouldHaveFullCollisionInAir()
    {
        return false;
        return;
    }

    function float GetFlyingGravityScale()
    {
        // End:0x14
        if(int(FrozenState) != int(0))
        {
            return 1;
        }
        // End:0x2B
        if(JumpParms.Mode == 4)
        {
            return 0;
        }
        // End:0x44
        if(JumpParms.AppliedJumpVel)
        {
            return JumpParms.FlyingGravityScale;
        }
        return global.GetFlyingGravityScale();
        return;
    }

    event float GetGroundGravityScale()
    {
        // End:0x19
        if(JumpParms.AppliedJumpVel)
        {
            return JumpParms.FlyingGravityScale;
        }
        return global.GetGroundGravityScale();
        return;
    }

    function float GetFallingGravityScale()
    {
        // End:0x17
        if(JumpParms.Mode == 4)
        {
            return 0;
        }
        // End:0x30
        if(JumpParms.AppliedJumpVel)
        {
            return JumpParms.FlyingGravityScale;
        }
        return global.GetFallingGravityScale();
        return;
    }

    function float CalculateFlyContraintStrengthScalar(float DeltaTime)
    {
        global.CalculateFlyContraintStrengthScalar(DeltaTime);
        // End:0x1F
        if(JumpParms.bSnapActive)
        {
            return 2.350298E+11;
        }
        return 0;
        return;
    }

    function float CalculateFallingContraintStrengthScalar(float DeltaTime)
    {
        // End:0x14
        if(JumpParms.bSnapActive)
        {
            return 5000;
        }
        return 0;
        return;
    }

    function bool StateShouldProcFire()
    {
        // End:0x26
        if((JumpParms.Mode == 2) || JumpParms.Mode == 4)
        {
            return true;
        }
        return false;
        return;
    }

    event bool AllowZMovementWhenNotFlying()
    {
        return true;
        return;
    }

    event bool AIStateOverrideLinearDamping()
    {
        // End:0x23
        if(JumpParms.Mode == 4)
        {
            KLinearDamping = JumpParms.StopLinearDamping;
            return true;
        }
        return false;
        return;
    }
Begin:

    ExecuteModeTakeOff();
    stop;    
}

state JumpAttack
{
    event BeginState()
    {
        SaveAnimSync();
        JumpAttackParms.Mode = 0;
        JumpAttackParms.Attacked = false;
        JumpAttackParms.AttackSuccess = false;
        JumpAttackParms.AppliedJumpVel = false;
        JumpAttackParms.RefId = -1;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        AlignYaw = default.AlignYaw;
        return;
    }

    animevent simulated function AnimEvent_ApplyJumpVelocity(optional EventInfo AnimEventInfo)
    {
        local Vector MyJumpVel;

        // End:0x12
        if(JumpAttackParms.Mode != 1)
        {
            return;
        }
        // End:0x50
        if((JumpAttackParms.TargetActor != none) && ! JumpAttackParms.bInstantJump)
        {
            ExitAIState(3, "Invalid Target.");
            return;
        }
        SetAnimSync(2, 2, 2, 2, 0);
        // End:0x80
        if(! bCanFly && int(Physics) != int(18))
        {
            SetRotation(2);
        }
        StateJumpAttack_Apply(MyJumpVel);
        // End:0xD7
        if(JumpAttackParms.bInstantJump && JumpAttackParms.TargetActor != none)
        {
            GetAimTargetLocation(Location + ((Normal(MyJumpVel) * Vect(1, 1, 0)) * 1000));
        }
        // End:0xEE
        if(bUseAcceleration)
        {
            Velocity = MyJumpVel;            
        }
        else
        {
            Velocity += MyJumpVel;
        }
        // End:0x123
        if((int(Physics) == int(18)) && bPhysicsControllerActive)
        {
            JumpAttackParms.FrameVelocity = MyJumpVel;
        }
        JumpAttackParms.AppliedJumpVel = true;
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x2B
        if(RefId != JumpAttackParms.RefId)
        {
            return;
        }
        switch(JumpAttackParms.Mode)
        {
            // End:0x3F
            case 0:
                // End:0x108
                break;
            // End:0x7B
            case 1:
                // End:0x59
                if(! JumpAttackParms.AppliedJumpVel)
                {
                    AnimEvent_ApplyJumpVelocity();
                }
                // End:0x70
                if(JumpAttackParms.AttackOnTakeoff)
                {
                    ExecuteModeAttack();                    
                }
                else
                {
                    ExecuteModeFall();
                }
                return;
                // End:0x108
                break;
            // End:0xAD
            case 2:
                // End:0xA2
                if((int(Physics) == int(1)) || bCanFly)
                {
                    ExecuteModeLand();                    
                }
                else
                {
                    ExecuteModeFall();
                }
                return;
                // End:0x108
                break;
            // End:0xDF
            case 3:
                // End:0xD4
                if((int(Physics) == int(1)) || bCanFly)
                {
                    ExecuteModeLand();                    
                }
                else
                {
                    ExecuteModeFall();
                }
                return;
                // End:0x108
                break;
            // End:0xFA
            case 4:
                ExitAIState(2, "Landed.");
                return;
                // End:0x108
                break;
            // End:0xFFFF
            default:
                assert(2 < 1);
                // End:0x108
                break;
                break;
        }
        return;
    }

    event Landed(Vector HitNormal, Actor LandedOnActor)
    {
        // End:0x15
        if(ApplyJumpAttackDamage(HitNormal, LandedOnActor))
        {
            return;
        }
        // End:0x4B
        if((int(JumpAttackParms.JumpAttackType) != int(2)) || JumpAttackParms.bInstantJump)
        {
            ExitAIState(2, "Landed.");
            return;
        }
        // End:0x6E
        if(! bCanFly)
        {
            global.Landed(HitNormal, LandedOnActor);
            ExecuteModeLand();
            return;
        }
        return;
    }

    function bool ApplyJumpAttackDamage(Vector Normal, Actor HitActor)
    {
        // End:0xB0
        if(! JumpAttackParms.Attacked)
        {
            // End:0x22
            if(! JumpAttackParms.AppliedJumpVel)
            {
                return false;
            }
            // End:0x30
            if(HitActor != none)
            {
                return false;
            }
            JumpAttackParms.Attacked = true;
            // End:0x82
            if(! JumpAttackParms.bDontApplyDirectDamage)
            {
                HitActor.TakeDamage(self, BiteDamageAmount, Location, HitActor.Location, class'BiteDamage',, Location);
            }
            // End:0xAE
            if((int(JumpAttackParms.JumpAttackType) == int(2)) && JumpAttackParms.Mode != 3)
            {
                ExecuteModeAttack();
            }
            return true;
        }
        return false;
        return;
    }

    event HitWall(Vector WallNormal, Actor WallActor)
    {
        // End:0x15
        if(ApplyJumpAttackDamage(WallNormal, WallActor))
        {
            return;
        }
        return;
    }

    event bool ShouldAbortMovement()
    {
        return false;
        return;
    }

    function ExecuteModeTakeOff()
    {
        JumpAttackParms.Mode = 1;
        // End:0x2A
        if(JumpAttackParms.TargetActor == none)
        {
            ClearAimTarget(JumpAttackParms.TargetActor);
        }
        // End:0x8A
        if((int(JumpAttackParms.JumpAttackType) != int(2)) || JumpAttackParms.bInstantJump)
        {
            AnimEvent_ApplyJumpVelocity();
            // End:0x87
            if(int(JumpAttackParms.JumpAttackType) == int(1))
            {
                SetAnimSync(2, 2, 2, 2, 0);
                PlayAnim('Anim_JumpAttack');
                ExecuteModeAttack();
            }            
        }
        else
        {
            Anim_JumpStart(JumpAttackParms.Type);
            JumpAttackParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        }
        return;
    }

    function ExecuteModeFall()
    {
        JumpAttackParms.Mode = 2;
        GetAimTargetActor();
        Anim_Fall(JumpAttackParms.Type);
        JumpAttackParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        return;
    }

    function ExecuteModeAttack()
    {
        JumpAttackParms.Mode = 3;
        // End:0x2E
        if(JumpAttackParms.TargetActor == none)
        {
            ClearAimTarget(JumpAttackParms.TargetActor);            
        }
        else
        {
            GetAimTargetActor();
        }
        Anim_JumpAttack(JumpAttackParms.Type);
        JumpAttackParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        return;
    }

    function ExecuteModeLand()
    {
        local Vector MyTargetPos;

        // End:0x13
        if(JumpAttackParms.Mode == 4)
        {
            return;
        }
        JumpAttackParms.Mode = 4;
        MyTargetPos = Location + (Vector(Rotation) * 10000);
        GetAimTargetLocation(MyTargetPos);
        GetLookTargetLocation(MyTargetPos);
        RestoreSavedAnimSync();
        AlignYaw = default.AlignYaw;
        Anim_Landing(JumpAttackParms.Type);
        JumpAttackParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        // End:0xAB
        if(bCanFly && int(Physics) != int(18))
        {
            SetRotation(4);
        }
        return;
    }

    event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector Position, Vector ImpactVelocity, Vector ImpactNormal)
    {
        global.KImpact(SelfBoneName, Other, OtherBoneName, Position, ImpactVelocity, ImpactNormal);
        // End:0x4D
        if((int(Physics) == int(18)) && bPhysicsControllerActive)
        {
            HitWall(ImpactNormal, Other);
        }
        return;
    }

    event CalculatePhysics_OnGround(float DeltaTime)
    {
        // End:0x9D
        if(JumpAttackParms.GroundFinderGate < Level.GameTimeSeconds)
        {
            // End:0x69
            if(((int(JumpAttackParms.JumpAttackType) != int(2)) && JumpAttackParms.Mode != 1) && VSizeSquared(Velocity) < 10)
            {
                ExitAIState(2, "Landed.");
                return;
            }
            // End:0x9D
            if((JumpAttackParms.Mode == 2) && JumpAttackParms.AppliedJumpVel)
            {
                ExitAIState(2, "Landed.");
                return;
            }
        }
        // End:0xC6
        if(JumpAttackParms.FrameVelocity != Vect(0, 0, 0))
        {
            Physics_ApplyJumpVelocity();            
        }
        else
        {
            global.CalculatePhysics_OnGround(DeltaTime);
        }
        return;
    }

    function CalculatePhysics_Falling(float DeltaTime)
    {
        // End:0x29
        if(JumpAttackParms.FrameVelocity != Vect(0, 0, 0))
        {
            Physics_ApplyJumpVelocity();            
        }
        else
        {
            global.CalculatePhysics_Falling(DeltaTime);
        }
        return;
    }

    function CalculatePhysics_CutScene(float DeltaTime)
    {
        // End:0x29
        if(JumpAttackParms.FrameVelocity != Vect(0, 0, 0))
        {
            Physics_ApplyJumpVelocity();            
        }
        else
        {
            global.CalculatePhysics_CutScene(DeltaTime);
        }
        return;
    }

    function CalculatePhysics_Flying(float DeltaTime)
    {
        // End:0x29
        if(JumpAttackParms.FrameVelocity != Vect(0, 0, 0))
        {
            Physics_ApplyJumpVelocity();            
        }
        else
        {
            global.CalculatePhysics_Flying(DeltaTime);
        }
        return;
    }

    function Physics_ApplyJumpVelocity()
    {
        bWasInAir = true;
        PhysController_ScaleGroundHeight(JumpAttackParms.FrameVelocity);
        PhysController_GetGroundConstraintType(0);
        PhysController_GetGroundConstraintDirection(Vect(1E+09, 1E+09, 1E+09));
        JumpAttackParms.GroundFinderLockout = default.JumpAttackParms.GroundFinderLockout;
        // End:0x68
        if(ContinueCampaignInProgress())
        {
            JumpAttackParms.FrameVelocity = Vect(0, 0, 0);
        }
        return;
    }

    event bool ShouldEnableGroundFinder(float DeltaTime)
    {
        // End:0x34
        if(! JumpAttackParms.AppliedJumpVel || JumpAttackParms.FrameVelocity != Vect(0, 0, 0))
        {
            return true;
        }
        // End:0x44
        if(JumpAttackParms.bInstantJump)
        {
            return true;
        }
        // End:0x68
        if((JumpAttackParms.Mode == 1) || JumpAttackParms.Mode == 0)
        {
            return false;
        }
        // End:0xD9
        if((((JumpAttackParms.Mode == 2) || JumpAttackParms.Mode == 3) && JumpAttackParms.GroundFinderLockout > 0) && ! JumpAttackParms.Attacked)
        {
            JumpAttackParms.GroundFinderLockout = FMax(JumpAttackParms.GroundFinderLockout - DeltaTime, 0);
            return false;
        }
        return true;
        return;
    }
Begin:

    ExecuteModeTakeOff();
    stop;    
}

auto state Init
{
    event BeginState()
    {
        return;
    }

    event EndState()
    {
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        return;
    }
Begin:

    // End:0x13
    if(int(Physics) == int(1))
    {
        SetRotation(2);
    }
    // End:0x3F
    if(NameForString(InitAnim, 'None'))
    {
        PlayAnim(InitAnim);
        FinishAnims(AnimCtrl.m_oController, true);
    }
    PostInit();
    // End:0x55
    if(bAutoStartWeaponTargetEval)
    {
        SuspendWeaponTargetEvaluation(false);
    }
    // End:0x65
    if(bAutoStartLookTargetEval)
    {
        SuspendLookTargetEvaluation(false);
    }
    // End:0x76
    if(bAutoStartDecisionTree)
    {
        SetExecutive(2);
    }
    stop;    
}

state MoveUnderground
{
    event BeginState()
    {
        SaveAnimSync();
        AnimCtrl.m_oController.EmptyAnimChannels_AllButGroup('None');
        GetZoneLastRenderTime(true);
        StoreCollision();
        ForceMountUpdate(false, false, false, false, false);
        TickStyle = 3;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        GetZoneLastRenderTime(false);
        RestoreCollision();
        Spawn('ArrivedAtDest');
        TickStyle = default.TickStyle;
        return;
    }

    function ArrivedAtDest()
    {
        MoveToward(MoveUndergroundParms.DestLocation);
        DisableDesiredRotation_Roll(MoveUndergroundParms.DestRotation);
        ExitAIState(2, "Arrived at dest.");
        return;
    }

    function ExecuteMoveUnderground()
    {
        Destroy(MoveUndergroundParms.Duration, false, 'ArrivedAtDest');
        return;
    }
Begin:

    ExecuteMoveUnderground();
    stop;    
}

state Pause
{
    event BeginState()
    {
        return;
    }

    event EndState()
    {
        return;
    }
Begin:

    SpawnAmmoCasing(PauseParms.Time);
    ExitAIState(2);
    stop;        
}

state PlaceTripMine
{
    event BeginState()
    {
        SaveAnimSync();
        SetAnimSync(0, 1, 1, 0, 0);
        PlaceTripMineParms.Mode = 0;
        PlaceTripMineParms.ResumeLookEval = ! LookTargetEvalInfo.Suspended;
        SuspendLookTargetEvaluation(true);
        HeadAimerRemoveTarget(true, 0.35);
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        // End:0x27
        if(PlaceTripMineParms.ResumeLookEval)
        {
            SuspendLookTargetEvaluation(false);
        }
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x34
        if(PlaceTripMineParms.TargetActor != none)
        {
            ExitAIState(3, "Target no longer valid.");
            return;
        }
        // End:0x58
        if((PlaceTripMineParms.Mode == 2) && InShootAngleThresh)
        {
            Execute_Place();
            return;
        }
        return;
    }

    function NotifyAimState(Engine.BaseAI.EAIAim NewState)
    {
        switch(NewState)
        {
            // End:0x29
            case 0:
                SetRefPose();
                ExitAIState(2, "Finished.");
                // End:0x6D
                break;
            // End:0x6A
            case 1:
                PlayAnim('Anim_ShootIdle');
                // End:0x52
                if(! DisableAimGrids)
                {
                    PlayAnim('Anim_ShootRefPose');                    
                }
                else
                {
                    MaybeFadeChannelBlock('WeaponIdle', 1, 0.25);
                }
                // End:0x6D
                break;
            // End:0xFFFF
            default:
                break;
        }
        return;
    }

    function NotifyEndWeaponFireAnim()
    {
        Execute_EndAim();
        return;
    }

    function NotifyFired()
    {
        StopFiringWeapon();
        Execute_EndAim();
        return;
    }

    function Execute_Aim()
    {
        local Vector MyTargetPos;

        PlaceTripMineParms.Mode = 2;
        // End:0x47
        if(! PlayAnim('Anim_Idle'))
        {
            ExitAIState(3, "COULDNT PLAY Anim_IdleTripMine");
            return;
        }
        MyTargetPos = Location + (Vector(Rotation) * 1000);
        GetAimTargetLocation(MyTargetPos);
        GetLookTargetLocation(MyTargetPos);
        MoveToEx(MyTargetPos, 0, 0);
        WeaponAimerAddTargetActor(PlaceTripMineParms.TargetActor, 'None', 0, 0.2, true, 0.5, 80, false);
        return;
    }

    function Execute_Place()
    {
        PlaceTripMineParms.Mode = 3;
        AIActor_Weapon_Fire();
        return;
    }

    function Execute_EndAim()
    {
        PlaceTripMineParms.Mode = 4;
        WeaponAimerRemoveTarget(true, 0.2);
        return;
    }
Begin:

    Execute_Aim();
    stop;    
}

state PhysicsGotoX
{
    event UpdateState(float DeltaSecs)
    {
        // End:0x3D
        if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
        {
            ExitAIState(3, "Invalid Target");
            return;
        }
        return;
    }

    event TickState(float Secs)
    {
        local float DesiredMagAccel, MaxAccelRate, MagAccel;
        local Vector Accel;

        DesiredMagAccel = AccelRate;
        MaxAccelRate = DesiredMagAccel;
        MagAccel = AirSpeed;
        MagAccel = FMin(DesiredMagAccel, MagAccel + (MaxAccelRate * Secs));
        AirSpeed = MagAccel;
        Accel = Normal(PrimaryTarget.GetEyePos() - Location) * MagAccel;
        KHurtRadiusActivity(Accel);
        StopPersistantPhysicsEffects(Accel * 0.01);
        return;
    }
Begin:

    stop;            
}

state SelectWeapon
{
    event BeginState()
    {
        SaveAnimSync();
        SelectWeaponParms.Mode = 0;
        SelectWeaponParms.RefId = -1;
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        SelectWeaponParms.NewWeaponClass = none;
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x21
        if(SelectWeaponParms.Mode == 1)
        {
            // End:0x21
            if(WeaponManagerCompletelyOff())
            {
                ExecuteSelectWeapon();
                return;
            }
        }
        return;
    }

    animevent simulated function HolsterWeapon(optional EventInfo AnimEventInfo)
    {
        assert(SelectWeaponParms.Mode == 2);
        PutWeaponInHolster();
        return;
    }

    animevent simulated function DrawWeapon(optional EventInfo AnimEventInfo)
    {
        assert((SelectWeaponParms.Mode == 3) || SelectWeaponParms.Mode == 4);
        DrawWeaponFromHolster(SelectWeaponParms.NewWeaponClass);
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x2B
        if(RefId != SelectWeaponParms.RefId)
        {
            return;
        }
        // End:0x6B
        if(SelectWeaponParms.Mode == 2)
        {
            // End:0x60
            if(SelectWeaponParms.NewWeaponClass != none)
            {
                ExitAIState(2, "Done");
                return;                
            }
            else
            {
                ExecuteModeDrawWeapon();
                return;
            }            
        }
        else
        {
            // End:0x8F
            if(SelectWeaponParms.Mode == 3)
            {
                ExitAIState(2, "Done");
                return;                
            }
            else
            {
                // End:0xB0
                if(SelectWeaponParms.Mode == 4)
                {
                    ExitAIState(2, "Done");
                    return;
                }
            }
        }
        return;
    }

    function ExecuteSelectWeapon()
    {
        // End:0x2B
        if(WeaponIsActive())
        {
            // End:0x20
            if(SelectWeaponParms.QuickSwitch)
            {
                ExecuteModeQuickSwitchStart();                
            }
            else
            {
                ExecuteModeHolsterWeapon();
            }
            return;            
        }
        else
        {
            ExecuteModeDrawWeapon();
            return;
        }
        return;
    }

    function ExecuteModeWait()
    {
        SelectWeaponParms.Mode = 1;
        Anim_Idle();
        MovementFudge();
        return;
    }

    function ExecuteModeQuickSwitchStart()
    {
        Anim_QuickSwitchWeapon(SelectWeaponParms.NewWeaponClass);
        BroadcastLog(("DCR Quick switching =D" @ "SelectWeaponParms.NewWeaponClass=") $ string(SelectWeaponParms.NewWeaponClass));
        SelectWeaponParms.Mode = 4;
        SelectWeaponParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        MovementFudge();
        return;
    }

    function ExecuteModeHolsterWeapon()
    {
        SelectWeaponParms.Mode = 2;
        Anim_Idle();
        Anim_HolsterWeapon(GetWeapon());
        SelectWeaponParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        MovementFudge();
        return;
    }

    function ExecuteModeDrawWeapon()
    {
        SelectWeaponParms.Mode = 3;
        Anim_Idle();
        Anim_DrawWeapon(SelectWeaponParms.NewWeaponClass);
        SelectWeaponParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        MovementFudge();
        return;
    }

    function MovementFudge()
    {
        local Vector MyTargetPos;

        MyTargetPos = Location + (Vector(Rotation) * 1000);
        GetAimTargetLocation(MyTargetPos);
        GetLookTargetLocation(MyTargetPos);
        MoveToEx(MyTargetPos, 0, 0);
        return;
    }
Begin:

    ExecuteSelectWeapon();
    stop;    
}

state SetAim
{
    event BeginState()
    {
        SetAimParms.Mode = 0;
        return;
    }

    event EndState()
    {
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x21
        if(SetAimParms.Mode == 1)
        {
            // End:0x21
            if(WeaponManagerCompletelyOff())
            {
                ExecuteSetAim();
                return;
            }
        }
        return;
    }

    event NotifyWeaponAimState(Engine.BaseAI.EAIAim NewState)
    {
        global.NotifyWeaponAimState(NewState);
        // End:0x31
        if(int(NewState) == int(SetAimParms.DesiredState))
        {
            ExitAIState(2, "Done");
            return;
        }
        return;
    }

    function ExecuteSetAim()
    {
        // End:0x1E
        if(int(SetAimParms.DesiredState) == int(1))
        {
            ExecuteModeAimOn();
            return;            
        }
        else
        {
            ExecuteModeAimOff();
            return;
        }
        return;
    }

    function ExecuteModeWait()
    {
        SetAimParms.Mode = 1;
        Anim_Idle();
        return;
    }

    function ExecuteModeAimOn()
    {
        SetAimParms.Mode = 2;
        Anim_Idle();
        WeaponAimerAddTargetAITarget(0, -1, SetAimParms.Time, true, ShootAngleThresh, WeaponTrackRate, true);
        return;
    }

    function ExecuteModeAimOff()
    {
        SetAimParms.Mode = 3;
        Anim_Idle();
        WeaponAimerRemoveTarget(true, SetAimParms.Time);
        return;
    }
Begin:

    // End:0x12
    if(WeaponManagerCompletelyOff())
    {
        ExecuteSetAim();        
    }
    else
    {
        ExecuteModeWait();
    }
    stop;            
}

state SetFireMode
{
    event BeginState()
    {
        SetFireModeParms.AbortTime = Level.GameTimeSeconds + 3;
        return;
    }

    event EndState()
    {
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x3C
        if(Level.GameTimeSeconds >= SetFireModeParms.AbortTime)
        {
            ExitAIState(3, "SetFireMode FAILED");
            return;
        }
        // End:0x5A
        if(SetFireModeParms.Done)
        {
            ExitAIState(2, "Done");
            return;
        }
        return;
    }

    event NotifyWeaponManagerMode(Engine.BaseAI.EAIWeapManMode NewMode)
    {
        local bool IsHoldingFire, FireOff;

        global.NotifyWeaponManagerMode(NewMode);
        IsHoldingFire = WeaponManagerHoldingFire();
        FireOff = WeaponManagerCompletelyOff();
        // End:0x5B
        if(SetFireModeParms.On)
        {
            // End:0x58
            if(! IsHoldingFire && ! FireOff)
            {
                SetFireModeParms.Done = true;
            }            
        }
        else
        {
            // End:0x7C
            if(IsHoldingFire && FireOff)
            {
                SetFireModeParms.Done = true;
            }
        }
        return;
    }

    function ExecuteSetFireMode()
    {
        // End:0x39
        if(! HasWeaponManager)
        {
            // End:0x22
            if(SetFireModeParms.On)
            {
                WeaponManagerResumeFire();                
            }
            else
            {
                WeaponManagerHoldFire(true);
            }
            ExitAIState(2, "Done");
            return;
        }
        // End:0x50
        if(SetFireModeParms.On)
        {
            WeaponManagerResumeFire();            
        }
        else
        {
            WeaponManagerHoldFire(SetFireModeParms.Expedite);
        }
        // End:0x9B
        if(! SetFireModeParms.DontIdle)
        {
            SetFireModeParms.FinishTime = Level.GameTimeSeconds + 0.25;
            Anim_Idle();            
        }
        else
        {
            SetFireModeParms.FinishTime = 0;
            SetFireModeParms.DontIdle = false;
        }
        return;
    }
Begin:

    ExecuteSetFireMode();
    stop;    
}

state Stun
{
    event BeginState()
    {
        TraceFire(PauseParms.Time, false, 'StunTimer');
        return;
    }
Begin:

    stop;            
}

state TurnToX
{
    event BeginState()
    {
        SaveAnimSync();
        // End:0x32
        if(UseTurnAnimRot && TurnToXParms.PlayTurnAnim)
        {
            SetAnimSync(0, 0, 1, 0, 0);            
        }
        else
        {
            SetAnimSync(0, 0, 2, 0, 0);
        }
        GetAimTargetActor();
        GetLookTargetActor();
        TurnToXParms.TurnDir = -1;
        // End:0x87
        if(TurnToXParms.ExitTime > 0)
        {
            TurnToXParms.ExitTime += Level.GameTimeSeconds;
        }
        EnableMovement(true);
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        EnableMovement(false);
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x51
        if((TurnToXParms.ExitTime > 0) && Level.GameTimeSeconds >= TurnToXParms.ExitTime)
        {
            ExitAIState(3, "ExitTime expired.");
            return;
        }
        // End:0x91
        if((int(TurnToXParms.TargetType) == int(2)) && TurnToXParms.TargetActor != none)
        {
            ExitAIState(3, "Invalid Target");
            return;
        }
        // End:0xD5
        if((int(TurnToXParms.TargetType) == int(3)) && ! PrimaryTarget.IsValidTarget())
        {
            ExitAIState(3, "Invalid Target");
            return;
        }
        return;
    }

    event GetFaceTargetLocation(out Vector OutLocation)
    {
        // End:0x30
        if(int(TurnToXParms.TargetType) == int(2))
        {
            OutLocation = TurnToXParms.TargetActor.Location;            
        }
        else
        {
            // End:0x56
            if(int(TurnToXParms.TargetType) == int(1))
            {
                OutLocation = TurnToXParms.TargetPos;                
            }
            else
            {
                // End:0x92
                if(int(TurnToXParms.TargetType) == int(3))
                {
                    // End:0x92
                    if(PrimaryTarget.IsValidTarget())
                    {
                        OutLocation = PrimaryTarget.GetPos();
                    }
                }
            }
        }
        TurnToXParms.TargetPos = OutLocation;
        return;
    }

    event bool UpdateFaceTarget(Vector DirTo, Vector CurDir)
    {
        local bool FacingTarget;
        local Engine.BaseAI.EAICode Code;
        local name AnimName;
        local int TurnDir;

        // End:0x71
        if(DebugStateTurnToX)
        {
            DebugDrawBone('movement');
            GetSlotVolume(Location, Location + (DirTo * 200), NewColorBytes(255, 0, 0, 255), 0.1);
            GetSlotVolume(Location, Location + (Vector(Rotation) * 400), NewColorBytes(0, 0, 255, 255), 0.1);
        }
        Code = CanTurnToPos(TurnToXParms.TargetPos, TurnToXParms.FaceThreshold);
        // End:0x12D
        if(int(Code) == int(0))
        {
            FacingTarget = false;
            AnimName = CalcTurnAnim(TurnToXParms.TargetPos, TurnDir, false);
            // End:0x122
            if(TurnDir != TurnToXParms.TurnDir)
            {
                // End:0x10B
                if(TurnToXParms.PlayTurnAnim)
                {
                    // End:0x108
                    if(! IsPlayingOnChannel(AnimName, 0))
                    {
                        EnableMovement(false);
                        PlayAnim(AnimName);
                    }                    
                }
                else
                {
                    EnableMovement(false);
                }
                TurnToXParms.TurnDir = TurnDir;
            }
            FacingTarget = false;            
        }
        else
        {
            switch(Code)
            {
                // End:0x13A
                case 7:
                // End:0x14A
                case 8:
                    ExitAIState(2);
                    // End:0x158
                    break;
                // End:0xFFFF
                default:
                    ExitAIState(3);
                    // End:0x158
                    break;
                    break;
            }
            FacingTarget = true;
        }
        return FacingTarget;
        return;
    }
Begin:

    SetLookTargetActor();
    stop;                
}

state UseX
{
    event BeginState()
    {
        SaveAnimSync();
        DisablePhysics = true;
        UseXParms.RefId = -1;
        AIDisableIK();
        return;
    }

    event EndState()
    {
        local dnUsableSomething UseableSomething;

        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        // End:0x6D
        if(UseXParms.InputDispatcher == none)
        {
            // End:0x6D
            if((UseXParms.InputDispatcher.MyActor != self) && UseXParms.InputDispatcher.Dispatching)
            {
                UseXParms.InputDispatcher.EndDispatching();
            }
        }
        UseableSomething = dnUsableSomething(UseXParms.TargetActor);
        // End:0xC7
        if((UseableSomething == none) && UseableSomething.User != self)
        {
            UseableSomething.AIReserved = none;
            UseableSomething.NotePawnLost();
        }
        DisablePhysics = default.DisablePhysics;
        HandFocusActor = none;
        HandFocusActorClass = none;
        bGrabbing = false;
        UseXParms.TargetActor = none;
        AnimationController.EmptyAnimChannel('Weapon_Ref');
        AnimationController.EmptyAnimChannel('Weapon_Anim');
        AIEnableIK();
        return;
    }

    function AIActor_AnimEnd(int Channel, name AnimName, int RefId)
    {
        global.AIActor_AnimEnd(Channel, AnimName, RefId);
        // End:0x49
        if((UseXParms.RefId != -1) && RefId == UseXParms.RefId)
        {
            ExitAIState(2);
            return;
        }
        return;
    }

    event bool ShouldProceduralAim()
    {
        return UseXParms.AllowProceduralAim && global.ShouldProceduralAim();
        return;
    }

    event bool ShouldProceduralHeadAim()
    {
        return UseXParms.AllowProceduralAim && global.ShouldProceduralHeadAim();
        return;
    }

    simulated function AnimCallback_AttachedToDecoration()
    {
        // End:0x28
        if(UseXParms.InputDispatcher == none)
        {
            UseXParms.InputDispatcher.Trigger(self, self);
        }
        // End:0x4D
        if(NameForString(UseXParms.AttachedEvent, 'None'))
        {
            GlobalTrigger(UseXParms.AttachedEvent);
        }
        UpdateMatrix(class'IKSystemInfo_Walker', false);
        UseXParms.bAttached = true;
        super(Pawn).AnimCallback_AttachedToDecoration();
        return;
    }

    function DetachFromUsableSomething()
    {
        UseXParms.bDetaching = true;
        // End:0x31
        if(InteractiveDecoration == none)
        {
            InteractiveDecoration = none;
            UpdateMatrix(class'IKSystemInfo_Walker', true);
            ExitAIState(2);
        }
        return;
    }

    function bool SetUsableSomethingAnimation(name AnimStateName)
    {
        // End:0x16
        if(! UseXParms.Using)
        {
            SetUsing();
        }
        PlayAnim(AnimStateName);
        return;
    }

    simulated function HandQuickAction(name ActionName)
    {
        // End:0x16
        if(! UseXParms.Using)
        {
            SetUsing();
        }
        // End:0x28
        if(ActionName != 'None')
        {
            return;
        }
        PlayAnim(ActionName);
        UseXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        return;
    }

    simulated function GrabActor(InteractiveActor TargetActor)
    {
        // End:0x0E
        if(TargetActor != none)
        {
            return;
        }
        bGrabbing = true;
        HandFocusActor = TargetActor;
        HandFocusActorClass = TargetActor.Class;
        PlayAnim('HandGrab');
        UseXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
        // End:0x77
        if(! UseXParms.Using)
        {
            SetUsing();
        }
        return;
    }

    animevent simulated function GenericUse(optional EventInfo AnimEventInfo)
    {
        UseXParms.TargetActor.Used(self, self);
        return;
    }

    event Input(Engine.Actor.EControlRemapperKeyType KeyType, Engine.BaseAI.EAIInputAction ActionType)
    {
        local dnUsableSomething UseableItem;
        local ControlRemapperEx CREX;

        UseableItem = dnUsableSomething(InteractiveDecoration);
        // End:0x120
        if(UseableItem == none)
        {
            CREX = UseableItem.InternalControlRemapper;
            assert(CREX == none);
            // End:0x60
            if(int(KeyType) == int(11))
            {
                UseableItem.Used(self, self);                
            }
            else
            {
                switch(ActionType)
                {
                    // End:0x87
                    case 0:
                        CREX.HandleEvents(KeyType, 0);
                        // End:0x120
                        break;
                    // End:0xA6
                    case 2:
                        CREX.HandleEvents(KeyType, 1);
                        // End:0x120
                        break;
                    // End:0xC5
                    case 1:
                        CREX.HandleEvents(KeyType, 2);
                        // End:0x120
                        break;
                    // End:0x112
                    case 3:
                        CREX.HandleEvents(KeyType, 0);
                        CREX.HandleEvents(KeyType, 1);
                        CREX.HandleEvents(KeyType, 2);
                        // End:0x120
                        break;
                    // End:0xFFFF
                    default:
                        assert(2 < 1);
                        // End:0x120
                        break;
                        break;
                }
            }
        }
        return;
    }

    function ControlsStateChanged(name NewStateName)
    {
        // End:0x2B
        if(UseXParms.InputDispatcher == none)
        {
            UseXParms.InputDispatcher.ControlsStateChanged(NewStateName);
        }
        return;
    }

    function SetUsing()
    {
        UseXParms.Using = true;
        Spawn('ExecuteUseX');
        return;
    }

    function Failed()
    {
        ExitAIState(3, "Could not initiate use.  No attempts left.");
        return;
    }

    function ExecuteUseX()
    {
        local dnUsableSomething UsableSomething;

        // End:0x10
        if(UseXParms.Using)
        {
            return;
        }
        -- UseXParms.Attempts;
        UsableSomething = dnUsableSomething(UseXParms.TargetActor);
        // End:0x8E
        if(UsableSomething == none)
        {
            // End:0x74
            if(UseXParms.ForceAttach)
            {
                // End:0x71
                if(UsableSomething.CanAttachPawn(self))
                {
                    UsableSomething.AttachPawnSuccess(self, true);
                }                
            }
            else
            {
                UseXParms.TargetActor.Used(self, self);
            }            
        }
        else
        {
            // End:0xF2
            if((CarryingAnActor() && CarriedActor != UseXParms.TargetActor) && CarriedActor.CanBeGrabUsedBy(self))
            {
                CarriedActor.GrabUsed(self);
                // End:0xEF
                if(! UseXParms.Using)
                {
                    ExitAIState(2);
                    return;
                }                
            }
            else
            {
                // End:0x118
                if(CanGrabActor(UseXParms.TargetActor))
                {
                    Grab(UseXParms.TargetActor);                    
                }
                else
                {
                    // End:0x165
                    if(UseXParms.TargetActor.CanBeUsedBy(self))
                    {
                        // End:0x165
                        if(PlayAnim('Anim_GenUse'))
                        {
                            UseXParms.RefId = AnimCtrl.m_oController.GetLastPrimaryRefId();
                            SetUsing();
                        }
                    }
                }
            }
        }
        // End:0x1AE
        if(! UseXParms.Using)
        {
            // End:0x19B
            if(UseXParms.Attempts > 0)
            {
                Destroy(UseXParms.AttemptInterval, false, 'ExecuteUseX');                
            }
            else
            {
                Destroy(UseXParms.AttemptInterval, false, 'Failed');
            }
        }
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        local dnUsableSomething UseableItem;
        local ControlRemapperEx CREX;
        local float DotToTarget;

        UseableItem = dnUsableSomething(InteractiveDecoration);
        // End:0xCF
        if(((((((UseableItem == none) && UseableItem.CanDetachPawn(false)) && UseXParms.bAttached) && ! UseXParms.bDetaching) && UseXParms.Using) && UseableItem == none) && PrimaryTarget.IsValidTarget())
        {
            // End:0xCF
            if(! UseXParms.InputDispatcher.CanUse(UseXParms.TargetActor, self, PrimaryTargetActor))
            {
                UseableItem.DetachPawn(true);
                UseXParms.bDetaching = true;
            }
        }
        return;
    }
Begin:

    Anim_Idle();
    ExecuteUseX();
    SpawnAmmoCasing(9999);
    ExitAIState(2);
    stop;            
}

state FreeMove
{
    event BeginState()
    {
        SaveAnimSync();
        return;
    }

    event EndState()
    {
        RestoreSavedAnimSync();
        GetAimTargetActor();
        GetLookTargetActor();
        RestoreDefaultBodyAlignRate();
        AlignYaw = default.AlignYaw;
        AIAdditiveVelocity = Vect(0, 0, 0);
        return;
    }

    function ExecuteFreeMove()
    {
        switch(FreeMoveParms.Mode)
        {
            // End:0x1B
            case 3:
                ExecuteCharge();
                // End:0x43
                break;
            // End:0x29
            case 2:
                ExecuteFloat();
                // End:0x43
                break;
            // End:0x37
            case 4:
                ExecuteHover();
                // End:0x43
                break;
            // End:0xFFFF
            default:
                ExecuteDefault();
                // End:0x43
                break;
                break;
        }
        ClearAimTarget(PrimaryTargetActor);
        return;
    }

    function ExecuteCharge()
    {
        // End:0x45
        if(PrimaryTargetActor != none)
        {
            BroadcastLog("AI Charge FAILED NO TARGET");
            ExitAIState(2, "Lost Target");
            return;
        }
        ChargeParms.StartVelocity = default.ChargeParms.StartVelocity;
        ChargeParms.ChargeTarget = PrimaryTarget.GetAimPos() + Vect(0, 0, CollisionHeight / 2);
        ChargeParms.ChargeDir = Normal(ChargeParms.ChargeTarget - Location);
        ChargeParms.ChargeStartTime = Level.GameTimeSeconds;
        ChargeParms.ChargeState = 0;
        return;
    }

    function ExecuteFloat()
    {
        return;
    }

    function ExecuteHover()
    {
        FreeMoveParms.startLocation = Location;
        return;
    }

    function ExecuteDefault()
    {
        // End:0x17
        if(FRand() < 0.5)
        {
            Anim_MoveTo_StrafeRight(2);            
        }
        else
        {
            Anim_MoveTo_StrafeLeft(2);
        }
        return;
    }

    event UpdateState(float DeltaSecs)
    {
        // End:0x3A
        if(! PrimaryTarget.IsValidTarget() || PrimaryTargetActor != none)
        {
            ExitAIState(3, "Lost Target");
            return;
        }
        // End:0xA0
        if(((FreeMoveParms.ExitTime != 0) && FreeMoveParms.ExitTime < Level.GameTimeSeconds) && int(FreeMoveParms.Mode) != int(6))
        {
            ExitAIState(2, "Exit time reached");
            return;
        }
        switch(FreeMoveParms.Mode)
        {
            // End:0xBB
            case 5:
                UpdateGoto();
                // End:0x10A
                break;
            // End:0xCE
            case 6:
                UpdateStop(DeltaSecs);
                // End:0x10A
                break;
            // End:0xE1
            case 1:
                UpdateFlank(DeltaSecs);
                // End:0x10A
                break;
            // End:0xF4
            case 3:
                UpdateCharge(DeltaSecs);
                // End:0x10A
                break;
            // End:0x107
            case 4:
                UpdateHover(DeltaSecs);
                // End:0x10A
                break;
            // End:0xFFFF
            default:
                break;
        }
        return;
    }

    function EndFollowThrough()
    {
        ExitAIState(2, "Target Reached");
        return;
    }

    function UpdateGoto()
    {
        local Vector DirToTarget;
        local float Dist;

        DirToTarget = FreeMoveParms.FreeMoveTarget - Location;
        Dist = VSizeSquared(DirToTarget);
        // End:0x6D
        if(Dist < (((CollisionRadius * float(2)) * (CollisionRadius * float(2))) * (CollisionRadius * float(2))))
        {
            ExitAIState(2, "Target Reached");
            return;            
        }
        else
        {
            KHurtRadiusActivity(((DirToTarget / Sqrt(Dist)) * FreeMoveParms.FreeMoveVelocity) * float(10), 3);
        }
        return;
    }

    function UpdateStop(float DeltaTime)
    {
        // End:0x20
        if(FreeMoveParms.ExitTime > Level.GameTimeSeconds)
        {
            return;
        }
        // End:0x40
        if(XBoxIsSignedIn())
        {
            ExitAIState(2, "Target Reached");
            return;
        }
        return;
    }

    function UpdateFlank(float DeltaSecs)
    {
        local float DotToTarget;

        DotToTarget = Normal(- PrimaryTarget.GetDisp2D()) Dot Vector(PrimaryTargetActor.Rotation);
        // End:0x70
        if((DotToTarget >= FreeMoveParms.MinDotToTarget) && DotToTarget <= FreeMoveParms.MaxDotToTarget)
        {
            ExitAIState(2, "Target Flanked");
            return;
        }
        return;
    }

    function UpdateHover(float DeltaSecs)
    {
        local Vector Dir;
        local float AccelMag;

        Dir = FreeMoveParms.startLocation - Location;
        // End:0x74
        if(Dir.Z > 5)
        {
            AccelMag = CalcMapRange(Dir.Z, 5, 50, 0, 1);
            KHurtRadiusActivity((Normal(Dir) * FreeMoveParms.FreeMoveVelocity) * AccelMag, 3);
        }
        return;
    }

    function UpdateCharge(float DeltaSeconds)
    {
        local float Speed, DotToTarget;
        local Vector DirToTarget;

        // End:0xF4
        if(int(ChargeParms.ChargeState) == int(0))
        {
            Speed = CalcMapRange(Level.GameTimeSeconds - ChargeParms.ChargeStartTime, 0, ChargeParms.RampUpTime, ChargeParms.StartVelocity, ChargeParms.MaxVelocity);
            GameplayDesiredPhysicsVelocity = ChargeParms.ChargeDir * Speed;
            DotToTarget = Normal(ChargeParms.ChargeTarget - Location) Dot ChargeParms.ChargeDir;
            // End:0xF1
            if(DotToTarget < float(0))
            {
                ChargeParms.ChargeState = 1;
                ChargeParms.ChargeDir.Z = 0;
                ChargeParms.CoolDownStartSpeed = Speed;
                ChargeParms.ChargeStartTime = Level.GameTimeSeconds;
            }            
        }
        else
        {
            // End:0x1F0
            if(int(ChargeParms.ChargeState) == int(1))
            {
                Speed = CalcMapRange(Level.GameTimeSeconds - ChargeParms.ChargeStartTime, 0, ChargeParms.CoolDownTime, ChargeParms.CoolDownStartSpeed, 0);
                GameplayDesiredPhysicsVelocity = ChargeParms.ChargeDir * Speed;
                // End:0x1F0
                if(Speed <= 0.1)
                {
                    NotifyChargeEnd();
                    ChargeParms.ChargeState = 2;
                    FreeMoveParms.Mode = 5;
                    FreeMoveParms.FreeMoveTarget = ChargeParms.ChargeTarget + Vect(0, 0, CollisionHeight * 2);
                    FreeMoveParms.FreeMoveVelocity = ChargeParms.ReturnVelocity;
                    FreeMoveParms.ExitTime = Level.GameTimeSeconds;
                }
            }
        }
        return;
    }

    function float CalculateFlyContraintStrengthScalar(float DeltaTime)
    {
        return 0;
        return;
    }

    function float CalculateGameplayOverrideContraintStrengthScalar(float DeltaTime)
    {
        // End:0x1E
        if(int(FreeMoveParms.Mode) == int(3))
        {
            return ChargeParms.ConstraintStrength;
        }
        return global.CalculateGameplayOverrideContraintStrengthScalar(DeltaTime);
        return;
    }

    function float GetFlyingGravityScale()
    {
        // End:0x14
        if(int(FrozenState) != int(0))
        {
            return 1;
        }
        // End:0x2D
        if(int(FreeMoveParms.Mode) == int(4))
        {
            return 1;
        }
        return global.GetFlyingGravityScale();
        return;
    }

    event bool ForceGameplayOverridePhysics()
    {
        // End:0x15
        if(int(FreeMoveParms.Mode) == int(6))
        {
            return true;
        }
        return false;
        return;
    }
Begin:

    ExecuteFreeMove();
    stop;    
}

defaultproperties
{
    RandomActorColorGroupID=Generic0
    ExecutiveSuspended=true
    DecisionTreeInterval=0.2
    SquadChannel=(ChannelName=DefaultSquad,MaxDistance=2000)
    CurrentOp=85
    CanSeeTargets=true
    CanHearTargets=true
    ClearTargetTime=40
    TargetVisTestInt=0.2
    HasWeaponTargetEvaluator=true
    WeaponTargetEvalInfo=(MyOwner=none,EvalInterval=1.5,Suspended=false,bSuspendedWithNoTarget=false,Evaluator=1,ForceUpdate=false,MustBePawn=true,MustBeSighted=false,MustBeReachable=false,CanTargetProjectiles=false,CanAvoidTargetableProjectiles=false,LastTarget=none,LastTargetEndTime=0)
    WeaponConeAngle=90
    MinPlayerHate=1.15
    MaxPlayerHate=2
    PlayerHateRecoverRate=0.05
    LookTargetEvalInfo=(MyOwner=none,EvalInterval=2,Suspended=false,bSuspendedWithNoTarget=false,Evaluator=2,ForceUpdate=false,MustBePawn=false,MustBeSighted=false,MustBeReachable=false,CanTargetProjectiles=false,CanAvoidTargetableProjectiles=false,LastTarget=none,LastTargetEndTime=0)
    LookConeAngle=90
    BaseLookTargetString="Base"
    GlanceLookTargetString="Glance"
    MinGlanceTime=3
    RndGlanceTime=2
    SameGlanceTargetInterval=4.5
    ChanceTryGlanceAgain=0.2
    MinGlanceRest=2.5
    RndGlanceRest=4.5
    MuzzleAimerInfo=(MyOwner=none,NotifyStateFuncName=None,NotifyLostFuncName=None,NotifyThresholdFuncName=None,CurrentState=0,TargetStack=none,AngleToTarget=0,DeltaAngleToTarget=0,SolutionClamped=false,UseWeaponAimFromPos=true)
    WeaponTrackRate=60
    HeadTrackRate=100
    ShootAngleThresh=10
    WeaponConfig='WeaponCfg_Default'
    Weapons(0)=none
    SpawnWithWeaponDrawn=true
    WpnSteadyHorizError=200
    WpnSteadyVertError=150
    WpnMovingHorizError=400
    WpnMovingVertError=300
    AimAtTargetTimeThresh=5
    CanScan=true
    MinWeaponScanTrackRate=2
    RndWeaponScanTrackRate=2
    LookTrackRateK=8.5
    MinScanInterval=2
    RndScanInterval=6
    MinScanDuration=8
    RndScanDuration=12
    MinScanRefreshTime=2
    RndScanRefreshTime=2
    MinScanPitch=-1500
    MaxScanPitch=2000
    MinScanYaw=-5000
    MaxScanYaw=5000
    MinPipeBombInterval=6
    RightHandPipebombMount=mount_pipebomb_r
    LeftHandPipebombMount=mount_pipebomb_l
    MinPipeBombTime=1.5
    MaxPipeBombTime=10
    MinHorizDistPipeBomb=350
    MaxHorizDistPipeBomb=1600
    MinVertDistPipeBomb=-300
    MaxVertDistPipeBomb=300
    MinPipeBombArcHeight=40
    MaxPipeBombArcHeight=200
    PipeBombChance=0.5
    MinTargetVisibleTime=0.2
    GuardInf=(CanGuard=true,IsGuardingActor=false,IsGuardingPos=false,GuardedActor=none,GuardedPos=(X=0,Y=0,Z=0),InnerRange=0,OuterRange=0,BaseInnerRange=150,BaseOuterRange=300,bDontScaleRangeWithDrawScale=false,AlignWith=false,AlignmentOffset=0,AbortRange=0,MustBeVisible=false,AllowAvoidDanger=false,AllowDodge=false,bStaticGuardHack=false,bAvoidGuardedPlayer=false)
    ChanceStayAtActionPoint=0.8
    ActionPointMeleeK=1
    MinBlinkTime=0.5
    MaxBlinkTime=3
    EyesClosedAnim=s_eyes_close
    RollForwardInfo=(X=100,Y=0,Z=0)
    RollLeftInfo=(X=0,Y=-100,Z=0)
    RollRightInfo=(X=0,Y=100,Z=0)
    RollTime=1
    CloakRate=8
    CloakMaterial='dt_effects.FrameBuffers.TempCloak3_fake'
    TKShieldCollisionRadius=100
    TKShieldCollisionHeight=100
    NumSecondaryTKCatchAnims=2
    TKIgnoreClasses(0)=dnRocket_AssaultTrooper_Laser
    TKIgnoreClasses(1)=dnJizzBomb
    TKIgnoreClasses(2)=dnRocket_BrainBlast
    TKIgnoreClasses(3)=dnRocket_BrainBlastSmall
    PickupItemRange=24
    UseLatentMovement=true
    AIBaseMoveSpeed=200
    ZeroMoveSpeedEnabled=true
    AutoRollRate=10
    AutoUnrollRate=1
    AutoPitchRate=10
    AutoUnPitchRate=1
    bUseAnimDispSpeed=true
    bUseAnimDispDir=true
    BodyAlignRate=2.3562
    BodyAlignRateFlying=2.3562
    BodyAlignThresh=100
    BodyAlignScale=0.5
    AlignYaw=true
    AirSpeedScale=1
    GroundSpeedScale=1
    AnimDispSpeedScale=1
    BackupPathingCooldown=1
    JumpPreset=(JumpVel=(X=0,Y=0,Z=0),HeavyLandingThresh=0,FocusActor=none,GravityScale=0,JumpTime=0,FlyToTarget=false,TargetPos=(X=0,Y=0,Z=0),JumpType=0,bSnapToTarget=false,bUseAccelaration=false,DefGravityScale=1,bFaceTarget=false)
    AmbientSoundInfo=(bDebug=false,TargetAquiredMinInterval=3,NoTargetIdleInterval=3,NoTargetIdleRnd=1,BattleIdleInterval=3,BattleIdleRnd=4,TargetAquiredSoundName=Sound_Alert,TargetLostSoundName=Sound_TargetLost,NoTargetSoundName=Sound_NoTargetIdle,TargetVisibleSoundName=Sound_BattleIdle,TargetNotVisibleSoundName=Sound_NoTargetIdle)
    InitialAnimController=1
    ControlXParms=(ControlType=none,MyControl=none,AnimName=None,Time=0,IsControlled=false,DieOnTakeDamage=true,AssumeCanFit=false)
    FallParms=(Mode=0,LandingThresh=0,HeavyLandingThresh=0,StartZ=0,RefId=0,AnimSet=0,ToggleIK=true)
    GotoXParms=(TargetType=0,TargetActor=none,TargetPos=(X=0,Y=0,Z=0),RefActor=none,NextPos=(X=0,Y=0,Z=0),FinalDest=0,OffsetType=0,Range=0,Bearing=0,Height=0,ClipTolerance=0,Speed=0,SpeedScale=0,Focus=0,FocusActor=none,FacePos=(X=0,Y=0,Z=0),RefId=0,Mode=0,SideArcTurnSpeedThresh=0,StepBackwardsSpeedThresh=0,StartAngleSideSector=0,StartAngleBackSector=0,MoveBackwardsDistThresh=0,SideStepDistThresh=0,MaxSteps=0,PreVerified=false,TurnDir=0,MyDoorEx=none,ForceEval=false,ForceAnim=false,StuckTime=0,bStopToTurn=false,EvalCount=0,bDisableEvalGate=false,ConstraintStrengthOverride=0,PathFailMode=0,bWaitingOnDynamicBlocker=false,bWaitTime=0,TargetExtent=(X=0,Y=0,Z=0),bDebug=false,FlyConstraintStrength=5000,bUseAccelerationWhenFlying=false,ExitOnLand=false,ExitOnLandHeight=0,UseAnimDispDirMod=2)
    JumpAttackParms=(TargetActor=none,Mode=0,Type=0,AttackOnTakeoff=false,Attacked=false,AttackSuccess=false,AppliedJumpVel=false,RefId=0,FrameVelocity=(X=0,Y=0,Z=0),bCanJumpAttackShrunkTarget=false,ShrunkTargetHeightScale=1,ShrunkTargetDistanceScale=1,MinInterval=0,GroundFinderGate=0,GroundFinderInterval=0.5,PresetFrameVelocity=(X=0,Y=0,Z=0),DefaultPresetFrameVelocity=(X=0,Y=0,Z=0),JumpAttackType=2,ParabolaJumpHeight=0,ParabolaMinJumpHeight=0,ParabolaMaxJumpHeight=0,GroundFinderLockout=0,bInstantJump=false,bUsePresetVelocity=false,bCheckClearShot=false,bCheckHasPath=true,bCheckClearPath=false,bDontApplyDirectDamage=false,bDisabled=false)
    RangeParms=(ActionPointClosestMaxTravelDist=1000,ActionPointClosestMaxTargetDist=2000,ActionPointClosestJumpableMaxTravelDist=2000,ActionPointClosestFlyerMaxTravelDist=7500)
    ShrunkParms=(bRunFromBiggerEnemies=true,MinSafeDistanceFromBigEnemy=500)
    MultiAnimIndex=-1
    TeleportParms=(Destination=(X=0,Y=0,Z=0),DestinationRotation=(Pitch=0,Yaw=0,Roll=0),StartParticleSystem='p_Creatures.Teleport.Teleport_Spawner',EndParticleSystem='p_Creatures.Teleport.Teleport_Spawner',StartLight=none,EndLight=none,StartSound=TeleportStart,EndSound=TeleportEnd,EndActionPoint=none,StartAnimName=Anim_TeleportStart,EndAnimName=Anim_TeleportEnd,StartOverlay='dt_Effects2.Caustic.Caustic_FB',bFaceTarget=true,bValid=false,Mode=0,MinTeleportDist=250,MaxTeleportDist=1200,Delay=3,bCantDie=false,bForceLandOnFinish=false,bForceJetpackOnFinish=false,bSkipStartEffects=false)
    RappelParms=(StartAnimName=Anim_RappelStart,IdleAnimName=Anim_RappelIdle,EndAnimName=Anim_RappelEnd,BoneName=Root,GravityScale=0,bOverrideAttachToInfo=false,AttachToActor=none,AttachToBone=None,BeamSystemClass='AIRappelBeamSystem',MyBeamSystem=none,Mode=0)
    bPlayDeathSound=true
    ShowPain=true
    ThrownObjectDeathAnimChance=0.4
    FinishMeControlType='dnControl_FinishingMove'
    FaceDamage=true
    FaceDeath=true
    ExpandPopSound=(bAllowRepeats=false,bPlayAsAmbient=false,MixerGroupOverride=Creature,SimpleSingleSound=none,Sounds=('a_impact.body.Head_InfExplode_01'),SlotPriority=0,VolumePrefab=0,Slots=none,Volume=1,VolumeVariance=0,InnerRadius=512,InnerRadiusVariance=0,Radius=8192,RadiusVariance=0,Pitch=1,PitchVariance=0,Flags=(bNoOverride=false,bMenuSound=false,bNoFilter=false,bNoOcclude=false,bNoAIHear=false,bNoScale=false,bSpoken=false,bPlayThroughListener=false,bNoDoppler=false,bDialogSound=false,bNoReverb=false,bEnableVis=false,bSkipFlangePrevention=false,bSkipSoundRadiusTest=false,bIgnoreTimeDilation=false),SoundLocationOverride=(bMakeRelativeForLocalPlayer=false,bMakeAbsoluteForActor=false,OverrideType=0,Location3D=(X=0,Y=0,Z=0),Velocity3D=(X=0,Y=0,Z=0)),Offset=0,Delay=0,SlotIndex=0,ForcedIndex=0,SoundFadeInfo=(FadeInDuration=0,FadeOutStartTime=0,FadeOutDuration=0,FadeInEndCallback=None,FadeOutEndCallback=None),SoundEndCallback=None,PlayedSounds=none,Filters=none)
    bMeleeResetPainOpGate=true
    MinPainOpInterval=2
    RndPainOpInterval=2
    MaxConsecutivePainOp=3
    MaxConsecutivePainInterval=3
    PainImpulseMinDamage=-1
    ProcFireStates(0)=GotoX
    ProcFireOps(0)=85
    ProcFireOps(1)=86
    ProcFireOps(2)=100
    CanProcFire=true
    ProcFireMaxTimeSinceSeen=2.5
    MinMovingFireInterval=1.2
    RndMovingFireInterval=0.6
    StartTickDisabled=true
    TryGotoAttackTime=1
    MaxTravelDist=700
    MinIdleTime=-1
    RndIdleTime=-1
    MinAggressiveIdleTime=-1
    RndAggressiveIdleTime=-1
    MinPauseTime=1
    MinStunTime=1
    ShouldTurnThreshold=25
    FaceThreshold=2
    WalkSpeedScale=0.3
    RunSpeedScale=1
    StepBackwardsSpeedThresh=10
    StartAngleSideSector=45
    StartAngleBackSector=135
    MoveBackwardsDistThresh=6
    SideStepDistThresh=6
    WalkDistThresh=500
    GotoPosRange=0.5
    GotoPosHeight=100
    GotoPosFlyingRange=20
    GotoPosFlyingHeight=20
    MinDistToGoal=5
    MinMoveAroundDist=30
    RndMoveAroundDist=80
    MinBackOffDist=80
    RndBackOffDist=50
    MinMoveSideDist=40
    RndMoveSideDist=60
    MinSpreadOutTime=0.1
    RndSpreadOutTime=0.5
    RndMeleeRange=10
    RndMeleeHeight=30
    MaxGotoMeleeSteps=-1
    MeleeZone=100
    MeleeZoneHeight=100
    MinMeleeStrafeRange=20
    RndMeleeStrafeRange=20
    MinMeleeStrafeCycles=2
    RndMeleeStrafeCycles=2
    MeleeAttackRange=30
    MeleeAttackArc=0.35
    BiteDamageAmount=8
    BiteDamageVel=(X=350,Y=0,Z=0)
    ClawDamageAmount=8
    ClawDamageVel=(X=350,Y=0,Z=0)
    KickDamageAmount=20
    KickDamageVel=(X=350,Y=0,Z=0)
    ForcedStompIndex=-1
    DodgeInfo(0)=(AnimName=Anim_DodgeLeft,PhysicsFrameVelocity=(X=0,Y=0,Z=0),DodgeType=1)
    DodgeInfo(1)=(AnimName=Anim_DodgeRight,PhysicsFrameVelocity=(X=0,Y=0,Z=0),DodgeType=1)
    DodgeInterval=1
    PlayerShrunkFootstepViewShake=(bNoLerp=false,bToggleSign=true,Style=2,Function=1,FalloffActor=none,FalloffDistance=0,ShakeDuration=0.6,ShakeFrequency=0.08,ShakeMagnitude=150,ShakeFullMagnitude=0,ShakeFullMagnitudeTime=0,ShakeName=PlayerShrunkAIFootStep)
    MinChargeRange=120
    MaxChargeRange=250
    MaxChargeHeightDelta=50
    MinChargeAttackRange=30
    MaxChargeAttackRange=40
    MaxChargeSteps=5
    MinWeaponStrafeCycles=2
    RndWeaponStrafeCycles=3
    bShootProjectileRequireLOS=true
    bShootProjectileFaceTarget=true
    MaxAirAttackHeight=300
    MaxJumpAttackRange=180
    MaxJumpAttackHeight=100
    JumpVel=(X=150,Y=0,Z=200)
    FallDistThresh=6
    LandingThresh=50
    HeavyLandingThresh=170
    ChanceLand=1
    DoJetPackWobble=true
    CanOpenDoors=true
    MaxThreatAimAngle=1
    MoveAroundTime=1
    RndMoveAroundTime=7
    HaywireMinDuration=0.33
    HaywireMaxDuration=3
    HaywireLinearAccel=(X=600,Y=0,Z=75)
    HaywireLinearAccelVar=(X=300,Y=0,Z=50)
    HaywireAngularAccel=(X=400,Y=400,Z=100)
    HaywireAngularAccelVar=(X=100,Y=100,Z=50)
    ChanceSayPain=1
    PainSoundRndInterval=1
    DynamicPathingPriority=1
    GroundConstraintScalerOverride=-1
    EvalGateOverride=-99
    bAutoStartWeaponTargetEval=true
    bAutoStartLookTargetEval=true
    bAutoStartDecisionTree=true
    PathingHistoryMaxSize=5
    bPhysicsControllerActive=true
    bHideDeactivatedWeapons=false
    bWeaponsActive=true
    NoDecorationPain=true
    FootstepSimple=true
    bPlayPickupSounds=false
    FootprintType=6
    Faction='Engine.AIFactionAlien'
    FieldOfView=-0.7
    PawnRotationRate=(Pitch=16384,Yaw=32768,Roll=3072)
    EyeBone=nose
    PickupMountBone=mount_carryitem
    PissEffectClass='dnParticles.dnPissFX_Male'
    MaxStepHeightEx=20.08
    GroundSpeed=200
    AirSpeed=200
    ShrunkUseStyle=2
    AutoRegisterIKClasses(0)=none
    bNoDamage=true
    bStartEnabled=true
    bCanCrushOthers=false
    KRestitution=0
    KLinearDamping=0
    EnableDisableThreshold=0
    CrushResistance=-1
    Physics=18
    bIsAIActor=true
    bCanExistOutOfWorld=true
    bTickOnlyZoneRecent=true
    bLowerByCollision=true
    bAnimEarlyEnd=true
    CollisionRadius=17
    TickZoneRecentTime=5
    TickNearbyRadius=2000
    DrawType=2
    SoundVolume=225
    SoundRadius=2048
    SoundInnerRadius=512
    TransientSoundVolume=0.8
    TransientSoundRadius=2048
}