/*******************************************************************************
 * AIActor_Boss generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class AIActor_Boss extends AIActor
    config;

var bool bProcAimingEnabled;
var bool bProcAimingEnabledPitch;
var bool bProcAimingEnabledYaw;
var bool bProcAimingPaused;
var bool bProcAimingResetPitch;
var bool bProcAimingResetYaw;
var float ProcAimingStoredYaw;
var float ProcAimingStoredPitch;
var() float ProcAimingVelocityPitch;
var() float ProcAimingVelocityPitchRampTime;
var() float ProcAimingVelocityYaw;
var() float ProcAimingVelocityYawRampTime;
var() float ProcAimingMinPitch;
var() float ProcAimingMaxPitch;
var() float ProcAimingMinYaw;
var() float ProcAimingMaxYaw;
var() bool ProcAimingDebug;
var float FullProcAimingVelocityPitch;
var float FullProcAimingVelocityYaw;

simulated function PostBeginPlay()
{
    super.PostBeginPlay();
    FullProcAimingVelocityPitch = ProcAimingVelocityPitch;
    FullProcAimingVelocityYaw = ProcAimingVelocityYaw;
    // End:0x32
    if(! bProcAimingEnabledPitch)
    {
        ProcAimingVelocityPitch = 0;
    }
    // End:0x48
    if(! bProcAimingEnabledYaw)
    {
        ProcAimingVelocityYaw = 0;
    }
    return;
}

function Vector GetPitchAimFromLocation()
{
    return Location;
    return;
}

function Vector GetYawAimFromLocation()
{
    return Location;
    return;
}

final simulated function DoProcAiming(float DeltaSeconds)
{
    local Vector UpDir, RightDir, DirToTarget, AimFrom;
    local float DesiredAimYaw, DesiredAimPitch;
    local Rotator DesiredAimRot;
    local int i, NumBones;

    // End:0x1B
    if(! bProcAimingEnabled || string(BoneAim) <= 0)
    {
        return;
    }
    SetScaleModifier();
    UpDir = Vect(0, 0, 1);
    RightDir = Vector(Rotation) Cross UpDir;
    // End:0x244
    if(bProcAimingEnabledPitch)
    {
        AimFrom = GetPitchAimFromLocation();
        // End:0x92
        if(PrimaryTarget.IsValidTarget())
        {
            DirToTarget = Normal(PrimaryTarget.GetAimPos() - AimFrom);            
        }
        else
        {
            DirToTarget = Vector(Rotation);
        }
        // End:0xFB
        if(ProcAimingVelocityPitch < FullProcAimingVelocityPitch)
        {
            // End:0xC7
            if(ProcAimingVelocityPitchRampTime <= 0)
            {
                ProcAimingVelocityPitchRampTime = 0.0001;
            }
            ProcAimingVelocityPitch += ((FullProcAimingVelocityPitch * DeltaSeconds) / ProcAimingVelocityPitchRampTime);
            // End:0xFB
            if(ProcAimingVelocityPitch > FullProcAimingVelocityPitch)
            {
                ProcAimingVelocityPitch = FullProcAimingVelocityPitch;
            }
        }
        // End:0x127
        if(! bProcAimingResetPitch)
        {
            DesiredAimPitch = FClamp(float(Rotator(DirToTarget).Pitch), ProcAimingMinPitch, ProcAimingMaxPitch);            
        }
        else
        {
            DesiredAimPitch = 0;
        }
        // End:0x164
        if(DesiredAimPitch > ProcAimingStoredPitch)
        {
            DesiredAimPitch = FMin(ProcAimingStoredPitch + (ProcAimingVelocityPitch * DeltaSeconds), DesiredAimPitch);            
        }
        else
        {
            DesiredAimPitch = FMax(ProcAimingStoredPitch - (ProcAimingVelocityPitch * DeltaSeconds), DesiredAimPitch);
        }
        ProcAimingStoredPitch = DesiredAimPitch;
        NumBones = string(MuzzleBoneAim);
        i = 0;
        J0x1A2:

        // End:0x20F [Loop If]
        if(i < NumBones)
        {
            // End:0x205
            if(MuzzleBoneAim[i].Weight > 0)
            {
                MeshInstance.BoneSetScale(MuzzleBoneAim[i].BoneName, RightDir, int(DesiredAimPitch * MuzzleBoneAim[i].Weight));
            }
            ++ i;
            // [Loop Continue]
            goto J0x1A2;
        }
        // End:0x244
        if(bProcAimingResetPitch && 0 == ProcAimingStoredPitch)
        {
            bProcAimingResetPitch = false;
            bProcAimingEnabledPitch = false;
            ProcAimingVelocityPitch = 0;
        }
    }
    // End:0x4C9
    if(bProcAimingEnabledYaw)
    {
        // End:0x2AA
        if(ProcAimingVelocityYaw < FullProcAimingVelocityYaw)
        {
            // End:0x276
            if(ProcAimingVelocityYawRampTime <= 0)
            {
                ProcAimingVelocityYawRampTime = 0.0001;
            }
            ProcAimingVelocityYaw += ((FullProcAimingVelocityYaw * DeltaSeconds) / ProcAimingVelocityYawRampTime);
            // End:0x2AA
            if(ProcAimingVelocityYaw > FullProcAimingVelocityYaw)
            {
                ProcAimingVelocityYaw = FullProcAimingVelocityYaw;
            }
        }
        // End:0x2C1
        if(bProcAimingPaused)
        {
            DesiredAimYaw = ProcAimingStoredYaw;            
        }
        else
        {
            AimFrom = GetYawAimFromLocation();
            // End:0x2F9
            if(PrimaryTarget.IsValidTarget())
            {
                DirToTarget = PrimaryTarget.GetDirTo();                
            }
            else
            {
                DirToTarget = Vector(Rotation);
            }
            DesiredAimRot = Normalize(Rotator(DirToTarget) - Rotation);
            // End:0x347
            if(! bProcAimingResetYaw)
            {
                DesiredAimYaw = FClamp(float(DesiredAimRot.Yaw), ProcAimingMinYaw, ProcAimingMaxYaw);                
            }
            else
            {
                DesiredAimYaw = 0;
            }
            // End:0x392
            if(ProcAimingDebug)
            {
                BroadcastLog((string(self) @ "ProcAiming Current Yaw to target=") $ string(DesiredAimYaw));
            }
            DesiredAimRot = Rotation;
            DesiredAimRot.Yaw += int(DesiredAimYaw);
            // End:0x3E1
            if(DesiredAimYaw > ProcAimingStoredYaw)
            {
                DesiredAimYaw = FMin(ProcAimingStoredYaw + (ProcAimingVelocityYaw * DeltaSeconds), DesiredAimYaw);                
            }
            else
            {
                DesiredAimYaw = FMax(ProcAimingStoredYaw - (ProcAimingVelocityYaw * DeltaSeconds), DesiredAimYaw);
            }
            ProcAimingStoredYaw = DesiredAimYaw;
        }
        NumBones = string(BoneAim);
        i = 0;
        J0x41F:

        // End:0x48C [Loop If]
        if(i < NumBones)
        {
            // End:0x482
            if(BoneAim[i].Weight > 0)
            {
                MeshInstance.BoneSetScale(BoneAim[i].BoneName, UpDir, int(DesiredAimYaw * BoneAim[i].Weight));
            }
            ++ i;
            // [Loop Continue]
            goto J0x41F;
        }
        // End:0x4C9
        if(bProcAimingResetYaw && 0 == ProcAimingStoredYaw)
        {
            bProcAimingResetYaw = false;
            bProcAimingEnabledYaw = false;
            bProcAimingEnabled = false;
            ProcAimingVelocityYaw = 0;
        }
    }
    return;
}

final function StopProcAiming()
{
    // End:0x11
    if(bProcAimingEnabledYaw)
    {
        bProcAimingResetYaw = true;
    }
    return;
}

final function StartProcAiming()
{
    bProcAimingEnabled = true;
    bProcAimingEnabledYaw = true;
    bProcAimingPaused = false;
    return;
}

animevent simulated function pauseprocaiming(optional EventInfo EventParms)
{
    bProcAimingPaused = true;
    return;
}

animevent simulated function startheadaim(optional EventInfo EventParms)
{
    bProcAimingEnabledPitch = true;
    return;
}

animevent simulated function stopheadaim(optional EventInfo EventParms)
{
    // End:0x11
    if(bProcAimingEnabledPitch)
    {
        bProcAimingResetPitch = true;
    }
    return;
}

defaultproperties
{
    bProcAimingEnabledYaw=true
    ProcAimingVelocityPitch=20000
    ProcAimingVelocityPitchRampTime=1
    ProcAimingVelocityYaw=5000
    ProcAimingVelocityYawRampTime=1
    ProcAimingMinPitch=-32768
    ProcAimingMaxPitch=32768
    ProcAimingMinYaw=-16384
    ProcAimingMaxYaw=16384
    bIsBoss=true
    bShouldCauseKillSound=false
    bCanExistOutOfWorld=false
    bOverlayEffectUsedAsHint=true
    OverlayMaterial='dt_effects.OverlayMaterial.OverlayMaterial_Boss'
}