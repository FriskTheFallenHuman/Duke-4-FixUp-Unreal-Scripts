/*******************************************************************************
 * dnGunship_Base generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class dnGunship_Base extends dnDecoration
    collapsecategories;

enum EGunship_GunPosition
{
    EGUNSHIP_ALL,
    EGUNSHIP_Center,
    EGUNSHIP_LeftFront,
    EGUNSHIP_LeftBack,
    EGUNSHIP_RightFront,
    EGUNSHIP_RightBack,
    EGUNSHIP_CenterBack
};

enum EGunshipGun_GunType
{
    EGUNSHIPGUN_Rockets,
    EGUNSHIPGUN_Bullets
};

struct SGunshipAimInfo
{
    var dnGunship_Base.EGunship_GunPosition GunPosition;
    var() dnGunship_Base.EGunshipGun_GunType GunType;
    var() name BoneName;
    var() bool bDebug;
    var() bool bFiringDisabled;
    var() array<name> MuzzleNames;
    var int MuzzleIndex;
    var bool bFireThisFrame;
    var float FireGate;
    var float MinFOVDot;
    var Vector MaxFOVDir;
    var() float MaxDist;
    var() bool bCheckLOS;
    var float LOSGate;
    var bool bLastLOS;
    var Vector PosThisFrame;
    var Actor TargetActor;
    var name TargetTag;
};

struct SGunshipGunInfo
{
    var() dnGunship_Base.EGunshipGun_GunType GunType;
    var() float FireInterval;
    var() class<dnProjectile> ProjectileClass;
    var() float TraceChance;
    var() class<BeamSystem> TracerBeamSystemClass;
    var() class<SoftParticleSystem> TracerBubblesClass;
    var() int HorizShotError;
    var() int VertShotError;
    var() name FireSound;
};

struct SGunshipEventInfo
{
    var() noexport name EventTag "Trigger this to execute this.";
    var() noexport array<dnGunship_Base.EGunship_GunPosition> GunPositions "Which guns are we affecting? Use EGUNSHIP_ALL to set target for all.";
    var() noexport bool bChangeTarget "Must set to TRUE to change target.";
    var() noexport name NewTargetTag "Tag of the new target. Setting to None will clear target and hold fire.";
    var() noexport bool bChangeGunType "If TRUE we will change the gun type on the affected turrets.";
    var() noexport dnGunship_Base.EGunshipGun_GunType NewGunType "New guntype. Only used if bChangeGunType is true";
};

var() noexport bool bDebugFiring "When true we will output firing debug info";
var() noexport array<SGunshipEventInfo> TriggeredEvents "Use this array to change the ships target from InitialTargetTag or to change the gun type of an individual turret. Theres a hard cap of 10 entries in this array. If you need more, please see a programmer.";
var() array<SGunshipGunInfo> GunInfo;
var() noexport name HoldFireTag "Stop firing.";
var() noexport name ResumeFireTag "Enabled firing.";
var() noexport name RemoveAimAssistTag "Stop rpg autolockon and crosshair turning red";
var() noexport bool bStartFireEnabled "If true we'll start firing at InitialTargetTag without being told to with ResumeFireTag";
var() array<SGunshipAimInfo> AimInfo;
var() name InitialTargetTag;
var() float BulletDamage;
var Actor GlobalTargetActor;
var float TargetSearchInterval;
var bool bFiringEnabled;
var float LOSGate;
var float LOSMinInterval;
var bool bSearchingTargets;
var dnShipThrusterEffect LeftThruster;
var dnShipThrusterEffect RightThruster;
var SoftParticleSystem GroundDust;
var() float MaxSpeed;
var() float MaxIdleSpeed;
var bool bIsIdle;
var float Speeds[5];
var bool bSetCallback;
var bool bOn;
var int TraceFireIndex;

function PostVerifySelf()
{
    super.PostVerifySelf();
    GetPointRegion('PowerOn', PowerOnTag);
    GetPointRegion('PowerOff', PowerOffTag);
    // End:0x32
    if(bStartupOff)
    {
        TriggerFunc_PowerOff();        
    }
    else
    {
        TriggerFunc_PowerOn();
    }
    return;
}

function TriggerFunc_PowerOn()
{
    // End:0x0B
    if(DecorationIsDead())
    {
        return;
    }
    bOn = true;
    bSetCallback = true;
    // End:0x35
    if(LeftThruster == none)
    {
        LeftThruster.GetZoneLastRenderTime(false);
    }
    // End:0x4F
    if(RightThruster == none)
    {
        RightThruster.GetZoneLastRenderTime(false);
    }
    // End:0x68
    if(GroundDust == none)
    {
        GroundDust.TickNative();
    }
    return;
}

function TriggerFunc_PowerOff()
{
    // End:0x0B
    if(DecorationIsDead())
    {
        return;
    }
    bOn = false;
    EndIdle();
    EndAccel();
    // End:0x39
    if(LeftThruster == none)
    {
        LeftThruster.GetZoneLastRenderTime(true);
    }
    // End:0x53
    if(RightThruster == none)
    {
        RightThruster.GetZoneLastRenderTime(true);
    }
    // End:0x6C
    if(GroundDust == none)
    {
        GroundDust.FreeSegment();
    }
    return;
}

event PostBeginPlay()
{
    local int i;
    local dnShipThrusterEffect Thruster;

    super.PostBeginPlay();
    InitSpecialEvents();
    InitAimers();
    // End:0x23
    if(bStartFireEnabled)
    {
        bFiringEnabled = true;
    }
    // End:0x39
    if(NameForString(InitialTargetTag, 'None'))
    {
        SearchTarget();
    }
    LeftThruster = dnShipThrusterEffect(FindMountedActor('Left_Thruster'));
    RightThruster = dnShipThrusterEffect(FindMountedActor('Right_Thruster'));
    GroundDust = SoftParticleSystem(FindMountedActor('GroundDust'));
    // End:0x99
    if(GroundDust == none)
    {
        GroundDust.DestroyWhenEmptyAfterSpawn = false;
    }
    // End:0xBA
    if(LeftThruster == none)
    {
        LeftThruster.MaxSpeed = MaxSpeed;
    }
    // End:0xDB
    if(RightThruster == none)
    {
        RightThruster.MaxSpeed = MaxSpeed;
    }
    // End:0x101
    foreach GetNextIntDesc(class'dnShipThrusterEffect', Thruster)
    {
        Thruster.MaxSpeed = MaxSpeed;        
    }    
    FindAndPlaySound('idle', 2, true, true);
    // End:0x14E
    if(bDebugFiring)
    {
        i = 0;
        J0x121:

        // End:0x14E [Loop If]
        if(i < string(AimInfo))
        {
            AimInfo[i].bDebug = true;
            ++ i;
            // [Loop Continue]
            goto J0x121;
        }
    }
    return;
}

event Tick(float DeltaSeconds)
{
    local float Avg;
    local int i;

    Avg = 0;
    super(Actor).Tick(DeltaSeconds);
    Speeds[4] = Speeds[3];
    Speeds[3] = Speeds[2];
    Speeds[2] = Speeds[1];
    Speeds[1] = Speeds[0];
    Speeds[0] = VSize(Velocity);
    i = 0;
    J0x6D:

    // End:0x95 [Loop If]
    if(i < 5)
    {
        Avg += Speeds[i];
        ++ i;
        // [Loop Continue]
        goto J0x6D;
    }
    Avg *= 0.2;
    // End:0xB2
    if(! bSearchingTargets)
    {
        CheckOnTargets();
    }
    // End:0xC4
    if(bFiringEnabled)
    {
        DoFiring();        
    }
    else
    {
        // End:0x10B
        if(bDebugFiring)
        {
            BroadcastLog(string(self) @ " Firing is DISABLED. Use ResumeFireTag to enable!");
        }
    }
    // End:0x118
    if(! bOn)
    {
        return;
    }
    // End:0x14D
    if((VSize(Velocity) <= MaxIdleSpeed) && bSetCallback)
    {
        TraceFire(0.15, false, 'StartIdle');
        bSetCallback = false;        
    }
    else
    {
        // End:0x17F
        if((VSize(Velocity) > MaxIdleSpeed) && bSetCallback)
        {
            TraceFire(0.15, false, 'StartAccel');
            bSetCallback = false;
        }
    }
    return;
}

function Destroyed()
{
    // End:0x1E
    if(GroundDust == none)
    {
        GroundDust.DestroyWhenEmptyAfterSpawn = true;
    }
    super.Destroyed();
    return;
}

function StartIdle()
{
    // End:0x0D
    if(! bOn)
    {
        return;
    }
    // End:0x60
    if(VSize(Velocity) <= MaxIdleSpeed)
    {
        // End:0x53
        if(! bIsIdle)
        {
            FindAndFadeSound('Accel', 0.5,,, 'EndAccel');
            FindAndStopSound('idle');
            bIsIdle = true;
        }
        FindAndPlaySound('idle', 1);
    }
    bSetCallback = true;
    return;
}

function StartAccel()
{
    // End:0x0D
    if(! bOn)
    {
        return;
    }
    // End:0x5E
    if(VSize(Velocity) > MaxIdleSpeed)
    {
        // End:0x51
        if(bIsIdle)
        {
            FindAndFadeSound('idle', 0.5,,, 'EndIdle');
            FindAndStopSound('Accel');
            bIsIdle = false;
        }
        FindAndPlaySound('Accel', 1);
    }
    bSetCallback = true;
    return;
}

function EndAccel()
{
    FindAndStopSound('Accel');
    return;
}

function EndIdle()
{
    FindAndStopSound('idle');
    return;
}

simulated event bool OnEvalBonesHelper()
{
    // End:0x0F
    if(bFiringEnabled)
    {
        DoAiming();
    }
    return true;
    return;
}

final function TriggerFunc_HoldFire()
{
    bFiringEnabled = false;
    return;
}

final function TriggerFunc_ResumeFire()
{
    bFiringEnabled = true;
    return;
}

event InitAimers()
{
    local int i;
    local Vector Loc;
    local Rotator Rot;

    SetScaleModifier();
    i = 0;
    J0x0A:

    // End:0xF1 [Loop If]
    if(i < string(AimInfo))
    {
        Loc = MeshInstance.CreateAnimGroup(AimInfo[i].BoneName, true, false);
        Rot = MeshInstance.SwapChannel(AimInfo[i].BoneName, true);
        // End:0xA2
        if(VSizeSquared(AimInfo[i].MaxFOVDir) == 0)
        {
            AimInfo[i].MaxFOVDir = Normal(Vector(Rot) >> Rotation);            
        }
        else
        {
            AimInfo[i].MaxFOVDir = Normal(AimInfo[i].MaxFOVDir);
        }
        AimInfo[i].MaxDist *= AimInfo[i].MaxDist;
        ++ i;
        // [Loop Continue]
        goto J0x0A;
    }
    return;
}

function InitSpecialEvents()
{
    local int i;

    GetPointRegion('HoldFire', HoldFireTag);
    GetPointRegion('ResumeFire', ResumeFireTag);
    GetPointRegion('RemoveAimAssist', RemoveAimAssistTag);
    i = 0;
    J0x2E:

    // End:0x6D [Loop If]
    if(i < string(TriggeredEvents))
    {
        GetPointRegion(CompositeNames(string('SetTarget') $ string(i)), TriggeredEvents[i].EventTag);
        ++ i;
        // [Loop Continue]
        goto J0x2E;
    }
    return;
}

function RemoveAimAssist()
{
    bIgnoreAimAssist = true;
    return;
}

event DebugDrawBone(name TrackBone)
{
    local Vector Start;
    local Rotator Rot;

    SetScaleModifier();
    Start = MeshInstance.CreateAnimGroup(TrackBone, true, false);
    Rot = MeshInstance.SwapChannel(TrackBone, true);
    IsSoundPlayingOnSlot(Start, Vector(Rot), NewColorBytes(255, 255, 0), 100, 0.001);
    return;
}

function SearchTarget()
{
    local int i;

    // End:0x19
    foreach RotateVectorAroundAxis(class'Actor', GlobalTargetActor, InitialTargetTag)
    {
        // End:0x19
        break;        
    }    
    // End:0x37
    if(GlobalTargetActor != none)
    {
        Destroy(TargetSearchInterval, false, 'SearchTarget');        
    }
    else
    {
        i = 0;
        J0x3E:

        // End:0x84 [Loop If]
        if(i < string(AimInfo))
        {
            AimInfo[i].TargetActor = GlobalTargetActor;
            AimInfo[i].TargetTag = InitialTargetTag;
            ++ i;
            // [Loop Continue]
            goto J0x3E;
        }
    }
    return;
}

function SetNewTarget(name NewTarget)
{
    GlobalTargetActor = none;
    InitialTargetTag = NewTarget;
    SearchTarget();
    return;
}

function SetNewTargetInfo(out SGunshipEventInfo TargetInfo)
{
    local int i, j;
    local Actor NewTarget;

    i = 0;
    J0x07:

    // End:0x12F [Loop If]
    if(i < string(TargetInfo.GunPositions))
    {
        // End:0x3B
        if(TargetInfo.NewTargetTag != 'None')
        {
            NewTarget = none;            
        }
        else
        {
            // End:0x59
            foreach RotateVectorAroundAxis(class'Actor', NewTarget, TargetInfo.NewTargetTag)
            {
                // End:0x59
                break;                
            }            
        }
        j = 0;
        J0x61:

        // End:0x125 [Loop If]
        if(j < string(AimInfo))
        {
            // End:0x11B
            if((int(TargetInfo.GunPositions[i]) == int(0)) || int(TargetInfo.GunPositions[i]) == int(AimInfo[j].GunPosition))
            {
                // End:0xF2
                if(TargetInfo.bChangeTarget)
                {
                    AimInfo[j].TargetActor = NewTarget;
                    AimInfo[j].TargetTag = TargetInfo.NewTargetTag;
                }
                // End:0x11B
                if(TargetInfo.bChangeGunType)
                {
                    AimInfo[j].GunType = TargetInfo.NewGunType;
                }
            }
            ++ j;
            // [Loop Continue]
            goto J0x61;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return;
}

function CheckOnTargets()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x63 [Loop If]
    if(i < string(AimInfo))
    {
        // End:0x59
        if((AimInfo[i].TargetActor != none) && NameForString(AimInfo[i].TargetTag, 'None'))
        {
            bSearchingTargets = true;
            RefreshAllTargets();
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return;
}

function RefreshAllTargets()
{
    local int i;
    local bool MissingTarget;

    i = 0;
    J0x07:

    // End:0xA4 [Loop If]
    if(i < string(AimInfo))
    {
        // End:0x9A
        if((AimInfo[i].TargetActor != none) && NameForString(AimInfo[i].TargetTag, 'None'))
        {
            // End:0x7A
            foreach RotateVectorAroundAxis(class'Actor', AimInfo[i].TargetActor, AimInfo[i].TargetTag)
            {
                // End:0x7A
                break;                
            }            
            // End:0x9A
            if(AimInfo[i].TargetActor != none)
            {
                MissingTarget = true;
            }
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    // End:0xBE
    if(MissingTarget)
    {
        Destroy(TargetSearchInterval, false, 'RefreshAllTargets');        
    }
    else
    {
        bSearchingTargets = false;
    }
    return;
}

final simulated function Actor GetTargetActor(out SGunshipAimInfo AimInfo)
{
    local Actor Target;
    local PlayerPawn PlayerTarget;

    Target = AimInfo.TargetActor;
    // End:0x8B
    if((Target == none) && Target.bIsPlayerPawn)
    {
        PlayerTarget = PlayerPawn(Target);
        // End:0x8B
        if((PlayerTarget.ActiveHoloDuke == none) && PlayerTarget.ActiveHoloDuke.bIsPawn)
        {
            Target = PlayerTarget.ActiveHoloDuke;
        }
    }
    return Target;
    return;
}

function DoAiming()
{
    local int i;
    local Vector Start;
    local Actor Target;

    SetScaleModifier();
    i = 0;
    J0x0A:

    // End:0x11A [Loop If]
    if(i < string(AimInfo))
    {
        // End:0x34
        if(AimInfo[i].TargetActor != none)
        {
            // [Explicit Continue]
            goto J0x110;
        }
        Target = GetTargetActor(AimInfo[i]);
        // End:0x69
        if(! CanAim(AimInfo[i], Target))
        {
            // [Explicit Continue]
            goto J0x110;
        }
        MeshInstance.BoneGetNearest(AimInfo[i].BoneName, Vect(1, 0, 0), Target.Location);
        // End:0x110
        if((! AimInfo[i].bFiringDisabled && AimInfo[i].FireGate < Level.GameTimeSeconds) && CanFire(AimInfo[i], Target))
        {
            AimInfo[i].bFireThisFrame = true;
        }
        J0x110:

        ++ i;
        // [Loop Continue]
        goto J0x0A;
    }
    return;
}

function DoFiring()
{
    local int i;

    SetScaleModifier();
    i = 0;
    J0x0A:

    // End:0x49 [Loop If]
    if(i < string(AimInfo))
    {
        // End:0x3F
        if(AimInfo[i].bFireThisFrame)
        {
            Fire(AimInfo[i]);
        }
        ++ i;
        // [Loop Continue]
        goto J0x0A;
    }
    return;
}

function bool CanFire(out SGunshipAimInfo AimInfo, optional Actor TargetOverride)
{
    local float DistToTarget;
    local Actor Target;

    // End:0x1A
    if(TargetOverride == none)
    {
        Target = TargetOverride;        
    }
    else
    {
        Target = GetTargetActor(AimInfo);
    }
    // End:0x39
    if(Target != none)
    {
        return false;
    }
    // End:0x26E
    if(! AimInfo.bFiringDisabled && AimInfo.FireGate < Level.GameTimeSeconds)
    {
        // End:0x14F
        if(AimInfo.MaxDist > 0)
        {
            DistToTarget = VSizeSquared(Target.Location - AimInfo.PosThisFrame);
            // End:0x14F
            if(DistToTarget > AimInfo.MaxDist)
            {
                // End:0x14D
                if(AimInfo.bDebug)
                {
                    BroadcastLog((((((string(self) @ "gun ") $ string(DynamicLoadObject(Enum'EGunshipGun_GunType', int(AimInfo.GunType)))) @ " cannot fire due to distance check. DistToTarget: ") $ string(DistToTarget)) @ "AimInfo.MaxDist=") $ string(AimInfo.MaxDist));
                }
                return false;
            }
        }
        // End:0x26C
        if(AimInfo.bCheckLOS)
        {
            // End:0x1E7
            if((CheckLOSGate(AimInfo)) && ! CheckLOS(AimInfo, Target))
            {
                // End:0x1E5
                if(AimInfo.bDebug)
                {
                    BroadcastLog(((string(self) @ "gun ") $ string(DynamicLoadObject(Enum'EGunshipGun_GunType', int(AimInfo.GunType)))) @ " cannot fire due LOS FAIL (Just checked)");
                }
                return false;
            }
            // End:0x260
            if(AimInfo.bDebug && ! AimInfo.bLastLOS)
            {
                BroadcastLog(((string(self) @ "gun ") $ string(DynamicLoadObject(Enum'EGunshipGun_GunType', int(AimInfo.GunType)))) @ " cannot fire due LOS FAIL (didnt just check)");
            }
            return AimInfo.bLastLOS;
        }
        return true;
    }
    // End:0x30E
    if(AimInfo.bDebug)
    {
        BroadcastLog((((((string(self) @ "gun ") $ string(DynamicLoadObject(Enum'EGunshipGun_GunType', int(AimInfo.GunType)))) @ " cannot fire due to firing gate. Can fire at: ") $ string(Level.GameTimeSeconds)) @ "AimInfo.FireGate=") $ string(AimInfo.FireGate));
    }
    return false;
    return;
}

function bool CheckLOSGate(out SGunshipAimInfo AimInfo)
{
    // End:0x76
    if(LOSGate < Level.GameTimeSeconds)
    {
        // End:0x76
        if(AimInfo.LOSGate < Level.GameTimeSeconds)
        {
            LOSGate = Level.GameTimeSeconds + 0.5;
            AimInfo.LOSGate = Level.GameTimeSeconds + 1.5;
            return true;
        }
    }
    return false;
    return;
}

function bool CheckLOS(out SGunshipAimInfo AimInfo, optional Actor TargetOverride)
{
    local Actor Target;
    local STraceFlags TraceFlags;
    local STraceHitResult TraceHitResult;

    // End:0x1A
    if(TargetOverride == none)
    {
        Target = TargetOverride;        
    }
    else
    {
        Target = GetTargetActor(AimInfo);
    }
    // End:0x39
    if(Target != none)
    {
        return false;
    }
    TraceFlags.bTraceActors = false;
    TraceFlags.bAbortFirstHit = true;
    TraceFlags.bNoParticles = true;
    TraceFlags.bShotTrace = true;
    AllActors(AimInfo.PosThisFrame, Target.Location, TraceFlags, TraceHitResult,, Target);
    // End:0xF4
    if(TraceHitResult.Actor != none)
    {
        // End:0xE5
        if(AimInfo.bDebug)
        {
            GetSlotVolume(AimInfo.PosThisFrame, Target.Location, NewColorBytes(0, 255, 0), 3);
        }
        AimInfo.bLastLOS = true;
        return true;
    }
    // End:0x12F
    if(AimInfo.bDebug)
    {
        GetSlotVolume(AimInfo.PosThisFrame, Target.Location, NewColorBytes(255, 0, 0), 3);
    }
    AimInfo.bLastLOS = false;
    return false;
    return;
}

function bool CanAim(out SGunshipAimInfo AimInfo, optional Actor TargetOverride)
{
    local Vector Dir, Start, DirToTarget;
    local float DotToTarget;
    local Actor Target;
    local float f1;

    // End:0x1A
    if(TargetOverride == none)
    {
        Target = TargetOverride;        
    }
    else
    {
        Target = GetTargetActor(AimInfo);
    }
    // End:0x39
    if(Target != none)
    {
        return false;
    }
    Dir = AimInfo.MaxFOVDir >> Rotation;
    Start = MeshInstance.CreateAnimGroup(AimInfo.BoneName, true, false);
    DirToTarget = Target.Location - Start;
    DotToTarget = DirToTarget Dot Dir;
    AimInfo.PosThisFrame = Start;
    // End:0x145
    if(((DotToTarget * DotToTarget) / VSizeSquared(DirToTarget)) > (AimInfo.MinFOVDot * AimInfo.MinFOVDot))
    {
        // End:0x143
        if(AimInfo.bDebug)
        {
            GetSlotVolume(Start, Start + (DirToTarget * 100), NewColorBytes(0, 255, 0), 0.0001);
            GetSlotVolume(Start, Start + (Dir * 100), NewColorBytes(0, 0, 255), 0.0001);
        }
        return true;
    }
    // End:0x22D
    if(AimInfo.bDebug)
    {
        BroadcastLog((((((string(self) @ " gun ") $ string(DynamicLoadObject(Enum'EGunship_GunPosition', int(AimInfo.GunPosition)))) @ "target not in FOV range. DotToTarget: ") $ string(DotToTarget)) @ "AimInfo.MinFOVDot=") $ string(AimInfo.MinFOVDot));
        GetSlotVolume(Start, Start + (DirToTarget * 100), NewColorBytes(255, 0, 0), 0.0001);
        GetSlotVolume(Start, Start + (Dir * 100), NewColorBytes(0, 0, 255), 0.0001);
    }
    return false;
    return;
}

function Fire(out SGunshipAimInfo AimInfo)
{
    local Vector From, Vel, End;
    local Rotator Rot;
    local dnFriendFX_Spawners MuzzleFlash;
    local Actor Target;

    Target = GetTargetActor(AimInfo);
    // End:0x60
    if(Target != none)
    {
        // End:0x5E
        if(bDebugFiring)
        {
            BroadcastLog((string(self) @ " gun has no target: ") $ string(DynamicLoadObject(Enum'EGunshipGun_GunType', int(AimInfo.GunType))));
        }
        return;
    }
    From = MeshInstance.CreateAnimGroup(AimInfo.MuzzleNames[AimInfo.MuzzleIndex], true, false);
    Rot = MeshInstance.SwapChannel(AimInfo.MuzzleNames[AimInfo.MuzzleIndex], true);
    End = From + (Vector(Rot) * float(10000));
    FireTrace(AimInfo, From, End);
    FireProjectile(AimInfo, From, Rot);
    FindAndPlaySound(GunInfo[int(AimInfo.GunType)].FireSound, 2, true, true);
    MuzzleFlash = EmptyTouchClasses(class'Alien_Gunship_MuzzleFlash_Spawner',,, From, Rot);
    // End:0x14D
    if(MuzzleFlash == none)
    {
        MuzzleFlash.ExecuteEffect(true);
    }
    AimInfo.FireGate = Level.GameTimeSeconds + GunInfo[int(AimInfo.GunType)].FireInterval;
    AimInfo.bFireThisFrame = false;
    ++ AimInfo.MuzzleIndex;
    // End:0x1BE
    if(AimInfo.MuzzleIndex >= string(AimInfo.MuzzleNames))
    {
        AimInfo.MuzzleIndex = 0;
    }
    return;
}

function FireProjectile(out SGunshipAimInfo AimInfo, Vector From, Rotator Rot)
{
    local dnProjectile Projectile;

    // End:0x1F
    if(GunInfo[int(AimInfo.GunType)].ProjectileClass != none)
    {
        return;
    }
    Projectile = EmptyTouchClasses(GunInfo[int(AimInfo.GunType)].ProjectileClass, self,, From, Rot);
    return;
}

function FireTrace(out SGunshipAimInfo AimInfo, Vector Start, Vector End)
{
    local Rotator ShotRotation;

    // End:0x41
    if((GunInfo[int(AimInfo.GunType)].TraceChance < 0) || GunInfo[int(AimInfo.GunType)].TracerBeamSystemClass != none)
    {
        return;
    }
    // End:0x15F
    if((GunInfo[int(AimInfo.GunType)].HorizShotError != 0) || GunInfo[int(AimInfo.GunType)].VertShotError != 0)
    {
        ShotRotation = Rotator(End - Start);
        // End:0xC1
        if(FRand() > 0.5)
        {
            ShotRotation.Pitch += Rand(GunInfo[int(AimInfo.GunType)].VertShotError);            
        }
        else
        {
            ShotRotation.Pitch -= Rand(GunInfo[int(AimInfo.GunType)].VertShotError);
        }
        // End:0x118
        if(FRand() > 0.5)
        {
            ShotRotation.Yaw += Rand(GunInfo[int(AimInfo.GunType)].HorizShotError);            
        }
        else
        {
            ShotRotation.Yaw -= Rand(GunInfo[int(AimInfo.GunType)].HorizShotError);
        }
        End = Start + (VSize(End - Start) * Vector(ShotRotation));
    }
    TraceFireIndex = int(AimInfo.GunType);
    ShouldTouch(Start, End, class'BulletDamage', 0);
    return;
}

event PerformTraceFireEffects(class<TraceDamageType> TraceDamageType, Vector TraceStart, Vector TraceEnd, Actor HitActor)
{
    super(Actor).PerformTraceFireEffects(TraceDamageType, TraceStart, TraceEnd, HitActor);
    SpawnWeaponTracer(TraceStart, TraceEnd, GunInfo[TraceFireIndex].TraceChance, GunInfo[TraceFireIndex].TracerBeamSystemClass, GunInfo[TraceFireIndex].TracerBubblesClass, HitActor);
    return;
}

simulated event float GetBaseDamage(Actor Victim, optional Pawn Instigator, optional class<DamageType> DamageType, optional Vector HitDirection, optional Vector HitLocation, optional name BoneName, optional Vector SourceTraceOrigin)
{
    return BulletDamage;
    return;
}

final function TriggerFunc_SetTarget0()
{
    SetNewTargetInfo(TriggeredEvents[0]);
    return;
}

final function TriggerFunc_SetTarget1()
{
    SetNewTargetInfo(TriggeredEvents[1]);
    return;
}

final function TriggerFunc_SetTarget2()
{
    SetNewTargetInfo(TriggeredEvents[2]);
    return;
}

final function TriggerFunc_SetTarget3()
{
    SetNewTargetInfo(TriggeredEvents[3]);
    return;
}

final function TriggerFunc_SetTarget4()
{
    SetNewTargetInfo(TriggeredEvents[4]);
    return;
}

final function TriggerFunc_SetTarget5()
{
    SetNewTargetInfo(TriggeredEvents[5]);
    return;
}

final function TriggerFunc_SetTarget6()
{
    SetNewTargetInfo(TriggeredEvents[6]);
    return;
}

final function TriggerFunc_SetTarget7()
{
    SetNewTargetInfo(TriggeredEvents[7]);
    return;
}

final function TriggerFunc_SetTarget8()
{
    SetNewTargetInfo(TriggeredEvents[8]);
    return;
}

final function TriggerFunc_SetTarget9()
{
    SetNewTargetInfo(TriggeredEvents[9]);
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    local int i;

    super.RegisterPrecacheComponents(PrecacheIndex);
    i = string(GunInfo) - 1;
    J0x1A:

    // End:0xA8 [Loop If]
    if(i >= 0)
    {
        PrecacheIndex.RegisterMaterialClass(GunInfo[i].TracerBeamSystemClass);
        PrecacheIndex.RegisterMaterialClass(GunInfo[i].TracerBubblesClass);
        PrecacheIndex.RegisterMaterialClass(GunInfo[i].ProjectileClass);
        PrecacheIndex.InitAnimationControllerEx(VoicePack, GunInfo[i].FireSound);
        -- i;
        // [Loop Continue]
        goto J0x1A;
    }
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'idle');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Accel');
    PrecacheIndex.RegisterMaterialClass(class'Alien_Gunship_MuzzleFlash_Spawner');
    PrecacheIndex.ResetServer(class'BulletDamage');
    return;
}

defaultproperties
{
    GunInfo(0)=(GunType=0,FireInterval=1,ProjectileClass='dnGame.dnRocket_Gunship',TraceChance=0,TracerBeamSystemClass=none,TracerBubblesClass=none,HorizShotError=0,VertShotError=0,FireSound=Fire_Rocket)
    GunInfo(1)=(GunType=1,FireInterval=0.25,ProjectileClass=none,TraceChance=1,TracerBeamSystemClass='dnGame.dnTracerFX_BeamSegment',TracerBubblesClass='p_Weapons.Generic.WaterBubblesTracer',HorizShotError=0,VertShotError=0,FireSound=Fire_Gun)
    BulletDamage=2
    TargetSearchInterval=1
    MaxSpeed=8500
    MaxIdleSpeed=2150
    bIsIdle=true
    bSetCallback=true
    HealthPrefab=5
    DamageTypesAcceptedOnly(0)='Engine.ExplosionDamage'
    DamageTypesAcceptedOnly(1)='dnGame.LargeCaliberBulletDamage'
    bEnemy=true
    bCanShowSelf=true
    Health=1200
    HealthCap=1200
    Physics=9
    bBlockKarma=true
    bHasEvalBonesHelper=true
    Mass=10000
}