/*******************************************************************************
 * Lights_Generic generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Lights_Generic extends aFinalDecoration
    abstract
    collapsecategories
    dependson(Details_Generic_SwingingLight_Node)
    dependson(Details_Generic_SwingingLight_Support);

enum ELightState
{
    LIGHT_On,
    LIGHT_Off,
    LIGHT_Disabled
};

struct SLightSupport
{
    var() Details_Generic_SwingingLight_Support Support;
    var() Vector AttachPoint;
    var() float Length;
    var() Details_Generic_SwingingLight_Node Node;
    var() KBSJoint Joint;
    var() KAngularJointLimit Limit;
    var() KAngularMotorAffector motor;
    var() KAngularMotorAffector SwingingMotor;
};

var() noexport bool bIgnoreLightShadows "If set to true, then the light fixture will *not* cast shadows from the lights it is controlling. It will still cast shadows from other lights.";
var() noexport name ForceOffTag "Tag to trigger to force this light to turn it (and it's light) off.";
var() noexport name DefaultBoneMount "Bone to mount to";
var() noexport bool bMountLightsOnStartup "Flag to mount LightEXs to this Lights_Generic on startup";
var(Swinging) noexport bool bAllowSupports "If true, this actor will try to spawn swinging light supports to attach to the ceiling.";
var(Swinging) noexport array<Vector> SupportPoints "Relative offsets from the origin of the light fixture to the support points.";
var int SupportLength;
var(Swinging) bool bAutoSwing;
var(Swinging) int AutoSwingRotation;
var bool bBroken;
var Lights_Generic.ELightState LightState;
var array<LightEx> LightList;
var array<SLightSupport> LightSupports;

function PostVerifySelf()
{
    local LightEx LEx;
    local name lightName;

    lightName = CompositeNames(string(Tag) $ "Light");
    GetPointRegion('ForceLightOff', ForceOffTag);
    FindLights(lightName);
    DecoActivity(0, 'LightInit');
    super(dnDecoration).PostVerifySelf();
    return;
}

final function FindLights(name lightName)
{
    local LightEx LEx;

    // End:0x9F
    foreach RotateVectorAroundAxis(class'LightEx', LEx, lightName)
    {
        // End:0x2C
        if(bIgnoreLightShadows)
        {
            LEx.CreateDesiredLocationEx(self);
        }
        // End:0x7D
        if(bMountLightsOnStartup)
        {
            // End:0x6C
            if(NameForString(DefaultBoneMount, 'None'))
            {
                LEx.MountType = 2;
                LEx.MountMeshItem = DefaultBoneMount;
            }
            LEx.MoveActor(self,,, true);
        }
        LightList[LightList.Add(1)] = LEx;
        Sleep('Generic0',, LEx);        
    }    
    return;
}

simulated function PostBeginPlay()
{
    local int i;
    local Vector AttachLocation, CeilingNormal;
    local Actor HitActor;
    local Vector Fwd, Right, Up;
    local Rotator CapRotation;

    super(dnDecoration).PostBeginPlay();
    // End:0x19
    if(SupportLength > 0)
    {
        bAllowSupports = true;
    }
    // End:0x5C4
    if(bAllowSupports && string(SupportPoints) > 0)
    {
        TickStyle = 2;
        // End:0x4B
        if(int(Physics) != int(18))
        {
            SetRotation(18);
        }
        string(LightSupports) = string(SupportPoints);
        i = string(SupportPoints) - 1;
        J0x67:

        // End:0x5BE [Loop If]
        if(i >= 0)
        {
            AttachLocation = Location + TransformVectorByRot((SupportPoints[i] * DrawScale) * DrawScale3D, Rotation);
            HitActor = AllProperties(LightSupports[i].AttachPoint, CeilingNormal, AttachLocation + Vect(0, 0, 2048), AttachLocation, true,, true);
            // End:0x12A
            if(HitActor != none)
            {
                LightSupports[i].AttachPoint = AttachLocation + Vect(0, 0, 2048);
                CeilingNormal = Vect(0, 0, -1);
            }
            LightSupports[i].Length = VSize(LightSupports[i].AttachPoint - AttachLocation);
            Up = - CeilingNormal;
            Fwd = Vect(1, 0, 0);
            Right = Up Cross Fwd;
            Fwd = Right Cross Up;
            CapRotation = OrthoRotation(Fwd, Right, Up);
            EmptyTouchClasses(class'Details_Generic_SwingingLight_Cap', self,, LightSupports[i].AttachPoint, CapRotation, false, true);
            LightSupports[i].Support = EmptyTouchClasses(class'Details_Generic_SwingingLight_Support', self,, Location,, false, true);
            // End:0x24A
            if(LightSupports[i].Support == none)
            {
                LightSupports[i].Support.SetActorColor(Vect(LightSupports[i].Length / 64, 0.02, 0.02));
            }
            LightSupports[i].Node = EmptyTouchClasses(class'Details_Generic_SwingingLight_Node', self,, LightSupports[i].AttachPoint, Rotation, false, true);
            LightSupports[i].Joint = EmptyTouchClasses(class'KBSJoint', self,, AttachLocation,, false, true);
            // End:0x317
            if(LightSupports[i].Joint == none)
            {
                LightSupports[i].Joint.KConstraintActor1 = self;
                LightSupports[i].Joint.KConstraintActor2 = LightSupports[i].Node;
                LightSupports[i].Joint.SetRotation(18);
            }
            LightSupports[i].Limit = EmptyTouchClasses(class'KAngularJointLimit', self,, AttachLocation, Rot(-16384, 0, 0), false, true);
            // End:0x3D6
            if(LightSupports[i].Limit == none)
            {
                LightSupports[i].Limit.KConstraintActor1 = self;
                LightSupports[i].Limit.KConstraintActor2 = LightSupports[i].Node;
                LightSupports[i].Limit.DetachOscillator(8192);
                LightSupports[i].Limit.SetRotation(18);
            }
            LightSupports[i].motor = EmptyTouchClasses(class'KAngularMotorAffector', self,, AttachLocation, Rot(-16384, 0, 0), false, true);
            // End:0x4B4
            if(LightSupports[i].motor == none)
            {
                LightSupports[i].motor.KConstraintActor1 = self;
                LightSupports[i].motor.KConstraintActor2 = LightSupports[i].Node;
                LightSupports[i].motor.GetSensedActors(0);
                LightSupports[i].motor.SetSensorRadius(1E+07);
                LightSupports[i].motor.SetRotation(18);
            }
            // End:0x5B4
            if(bAutoSwing)
            {
                LightSupports[i].SwingingMotor = EmptyTouchClasses(class'KAngularMotorAffector', self,, AttachLocation, Rot(0, AutoSwingRotation, 0), false, true);
                // End:0x5B4
                if(LightSupports[i].SwingingMotor == none)
                {
                    LightSupports[i].SwingingMotor.KConstraintActor1 = LightSupports[i].Node;
                    LightSupports[i].SwingingMotor.KConstraintActor2 = none;
                    LightSupports[i].SwingingMotor.GetSensedActors(800);
                    LightSupports[i].SwingingMotor.SetSensorRadius(10);
                    LightSupports[i].SwingingMotor.SetRotation(18);
                    Destroy(0.9, true, 'ReverseSwing');
                    KRemoveBelowNamed(0);
                    KGetCollidingActors();
                }
            }
            -- i;
            // [Loop Continue]
            goto J0x67;
        }
        UpdateSupports();
    }
    return;
}

simulated event PostPhysMeqon(float DeltaTime)
{
    super(KarmaActor).PostPhysMeqon(DeltaTime);
    UpdateSupports();
    return;
}

final simulated function UpdateSupports()
{
    local int i;
    local Vector SupportPoint, Offset;

    i = string(LightSupports) - 1;
    J0x0F:

    // End:0x12F [Loop If]
    if(i >= 0)
    {
        // End:0x125
        if(LightSupports[i].Support == none)
        {
            SupportPoint = Location + TransformVectorByRot((SupportPoints[i] * DrawScale) * DrawScale3D, Rotation);
            Offset = SupportPoint - LightSupports[i].AttachPoint;
            LightSupports[i].Length = VSize(Offset);
            LightSupports[i].Support.DisableDesiredRotation_Roll(Rotator(Normal(Offset)));
            LightSupports[i].Support.SetDesiredRotation(LightSupports[i].AttachPoint + (0.5 * Offset));
            LightSupports[i].Support.SetActorColor(Vect(LightSupports[i].Length / 64, 0.02, 0.02));
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return;
}

simulated function bool CanBeUsedBy(Pawn User)
{
    // End:0x20
    if(super(InteractiveActor).CanBeUsedBy(User) && ! bEMPulsed)
    {
        return true;        
    }
    else
    {
        return false;
    }
    return;
}

function HitByEMP(optional float Duration, optional Pawn Instigator)
{
    local Lights_Generic.ELightState OldLightState;

    OldLightState = LightState;
    super(dnDecoration).HitByEMP(Duration, Instigator);
    // End:0x3C
    if(bEMPulsed && int(OldLightState) == int(0))
    {
        bPoweredBeforeEMP = true;
    }
    return;
}

function ForcePowerOn()
{
    super(dnDecoration).ForcePowerOn();
    // End:0x1A
    if(int(LightState) == int(1))
    {
        TurnLightOn();
    }
    return;
}

function ForcePowerOff()
{
    super(dnDecoration).ForcePowerOff();
    // End:0x1A
    if(int(LightState) == int(0))
    {
        TurnLightOff();
    }
    return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
    super(dnDecoration).Trigger(Other, EventInstigator);
    switch(LightState)
    {
        // End:0x26
        case 0:
            TurnLightOff();
            // End:0x37
            break;
        // End:0x34
        case 1:
            TurnLightOn();
            // End:0x37
            break;
        // End:0xFFFF
        default:
            break;
    }
    return;
}

final function TurnLightOn()
{
    // End:0x10
    if(int(LightState) == int(2))
    {
        return;
    }
    LightState = 0;
    DecoActivity(0, 'LightOn');
    return;
}

final function TurnLightOff()
{
    // End:0x10
    if(int(LightState) == int(2))
    {
        return;
    }
    LightState = 1;
    DecoActivity(0, 'LightOff');
    return;
}

final function TriggerFunc_ForceLightOff()
{
    // End:0x10
    if(int(LightState) == int(2))
    {
        return;
    }
    // End:0x24
    if(int(LightState) == int(0))
    {
        TurnLightOff();
    }
    LightState = 2;
    return;
}

function Destroyed()
{
    local int i;

    super(dnDecoration).Destroyed();
    // End:0x47
    if(bSurviveDeath)
    {
        // End:0x44
        if(! bBroken && string(LightSupports) > 1)
        {
            bBroken = true;
            CleanupLightSupport(LightSupports[Rand(string(LightSupports))]);
        }        
    }
    else
    {
        i = string(LightSupports) - 1;
        J0x56:

        // End:0x7C [Loop If]
        if(i >= 0)
        {
            CleanupLightSupport(LightSupports[i]);
            -- i;
            // [Loop Continue]
            goto J0x56;
        }
        LightSupports.Empty();
        i = string(LightList) - 1;
        J0x91:

        // End:0xB9 [Loop If]
        if(i >= 0)
        {
            LightList[i].RemoveTouchClass();
            -- i;
            // [Loop Continue]
            goto J0x91;
        }
        LightList.Empty();
    }
    LightState = 2;
    return;
}

final simulated function CleanupLightSupport(out SLightSupport LightSupport)
{
    // End:0x23
    if(LightSupport.Joint == none)
    {
        LightSupport.Joint.RemoveTouchClass();
    }
    // End:0x46
    if(LightSupport.motor == none)
    {
        LightSupport.motor.RemoveTouchClass();
    }
    // End:0x69
    if(LightSupport.SwingingMotor == none)
    {
        LightSupport.SwingingMotor.RemoveTouchClass();
    }
    // End:0x8C
    if(LightSupport.Limit == none)
    {
        LightSupport.Limit.RemoveTouchClass();
    }
    // End:0xAF
    if(LightSupport.Node == none)
    {
        LightSupport.Node.RemoveTouchClass();
    }
    // End:0xD2
    if(LightSupport.Support == none)
    {
        LightSupport.Support.RemoveTouchClass();
    }
    return;
}

function ReverseSwing()
{
    local int i;

    i = string(LightSupports) - 1;
    J0x0F:

    // End:0x5D [Loop If]
    if(i >= 0)
    {
        LightSupports[i].SwingingMotor.GetSensedActors(-1 * LightSupports[i].SwingingMotor.DesiredAngularVelocity);
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    KGetCollidingActors();
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(dnDecoration).RegisterPrecacheComponents(PrecacheIndex);
    // End:0x57
    if(bAllowSupports || SupportLength > 0)
    {
        PrecacheIndex.RegisterMaterialClass(class'Details_Generic_SwingingLight_Cap');
        PrecacheIndex.RegisterMaterialClass(class'Details_Generic_SwingingLight_Support');
        PrecacheIndex.RegisterMaterialClass(class'Details_Generic_SwingingLight_Node');
    }
    return;
}

defaultproperties
{
    bIgnoreLightShadows=true
    bMountLightsOnStartup=true
    DecoActivities_Default(0)=(ActivityData=(bInitialized=false,CurrentIndex=0,NextPerformTime=0,NextPerformTime_Failure=0),ActivityIDScript=(LightOn),ActivityID=none,ActivityMethod=0,ActivityStates_Success=none,ActivityStates_Failure=none,ActivityDebugID="",Activities=((ActivityRules=none,ActivityElements=(DecoActivities_Events'Lights_Generic.DA_Events_Lights_Generic_Toggled'),ActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0),FailureActivityElements=none,FailureActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0))),bDisabled=false)
    DecoActivities_Default(1)=(ActivityData=(bInitialized=false,CurrentIndex=0,NextPerformTime=0,NextPerformTime_Failure=0),ActivityIDScript=(LightOff),ActivityID=none,ActivityMethod=0,ActivityStates_Success=none,ActivityStates_Failure=none,ActivityDebugID="",Activities=((ActivityRules=none,ActivityElements=(DecoActivities_Events'Lights_Generic.DA_Events_Lights_Generic_Toggled'),ActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0),FailureActivityElements=none,FailureActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0))),bDisabled=false)
    bSurviveDeath=true
    FlickerLight=(FlickerLightActor=none,FlickerLightExActor=none,bUseFlickerLight=true,bUseFlickerLightEx=true,bInitialEffect=true,bInitialEffectOnly=false,FlickerLightMounting=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=0,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),FlickerLightExRadius=0,FlickerLightExRadius3D=(X=0,Y=0,Z=0),FlickerLightExColor=(R=0,G=0,B=0,A=0),FlickerLightExMounting=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=0,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),FlickerLightExIntensity=2)
    DestroyedActivities(0)=none
    DestroyedActivities(1)='dnGame.DecoActivityDeclarations.DA_Sound_Destroyed_Glass_Large'
    begin object name=DA_Events_Lights_Generic_Destroyed class=DecoActivities_Events
        Event=LightOff
        EventPrependTag=true
    object end
    // Reference: DecoActivities_Events'Lights_Generic.DA_Events_Lights_Generic_Destroyed'
    DestroyedActivities(2)=DA_Events_Lights_Generic_Destroyed
    HealthPrefab=5
    Health=28
    HealthCap=28
    SpawnOnDestroyedSimple(0)='dnParticles.dnDebris_Glass1'
    SpawnOnDestroyedSimple(1)='dnParticles.dnDebris_Smoke'
    bModifyTickOnPhysicsChange=false
    bTickOnlyWhenPhysicsAwake=true
    PhysicsMaterial='dnMaterial.dnPhysicsMaterial_Metal_Solid'
    PhysicsMassType=1
    KLinearDamping=0.3
    KAngularDamping=0.5
    CollisionRadius=0
    VoicePack='SoundConfig.Effects.VoicePack_Lights'
}