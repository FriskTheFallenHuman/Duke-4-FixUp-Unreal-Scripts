/*******************************************************************************
 * Biology_Generic_Tentacle generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Biology_Generic_Tentacle extends Biology_Generic
    collapsecategories;

enum ETentacleState
{
    ETS_Idle,
    ETS_Inspecting,
    ETS_Tracking,
    ETS_Swiping
};

var() noexport float TrackingRate "Speed that this tentacle can track enemies.";
var() noexport float DamageDisableTime "Amount of time to be disabled when damaged.";
var() noexport float DamageDisableTimeVariance "By now, you know it's true... I vary you.";
var() noexport float SwipeDamage "Base damage to apply per swipe.";
var() noexport float SwipeDamageVariance "Variance on swipe damage.";
var() noexport float SwipeDamageRadius "Radius of swipe damage.";
var() noexport float SwipeDamageFalloffStart "Falloff start of the radius damage of the swipe.";
var() noexport float IdleInspectTime "Time to be idle before doing an inspection.";
var() noexport float IdleInspectTimeVariance "Variance on idle inspect time.";
var name PassiveIdleName;
var name ActiveIdleName;
var name SwipeAttackBoneName;
var() array<name> InspectAnimNames;
var() array<name> SwipeAnimNames;
var() noexport float DetectionRadius "Becomes the SensorRadius for the Pod's KSphereSensor.  If zero, sensor will be disabled.";
var() noexport float AttackRadius "Distance the target must be before an attack can occur. Should be less than DetectionRadius.";
var() noexport name ForceInspectTag "Trigger this event to make the tentacle inspect the area.";
var() noexport name ForceExtendTag "Trigger this event to make the tentacle become active.";
var() noexport name ForceRetractTag "Trigger this event to make the tentacle become inactive.";
var() noexport name ForceSwipeTag "Trigger this event to make the tentacle swipe.";
var() noexport name InspectedEvent "Event that is triggered when this tentacle has completed an inspection.";
var() noexport name ExtendedEvent "Event that is triggered when this tentacle is fully extended.";
var() noexport name RetractedEvent "Event that is triggered when this tentacle is fully retracted.";
var() noexport name SwipedEvent "Event that is triggered when this tentacle has completed a swipe.";
var() noexport int MaxAttackAngle "Max angle from target to attack. 0=only straight ahead. 16384=approx 90 degrees";
var() float ImpulseLift;
var() float ImpulseMag;
var() noexport bool EnableCollision "Use invisible collision hull to prevent player from passing through tentacle while active.";
var() Color StunnedActorColor;
var() Color DefaultActorColor;
var Biology_Generic_Tentacle.ETentacleState TentacleState;
var bool bStunned;
var bool bForceRetract;
var float AimGridX;
var float AimGridY;
var Biology_Generic_AlienSensor Sensor;
var float AimGridMin;
var float AimGridMax;
var int NumTripMines;
var Biology_Generic_Tentacle_Collision CollisionHelper;

event PostBeginPlay()
{
    super(dnDecoration).PostBeginPlay();
    Sensor = Biology_Generic_AlienSensor(FindMountedActor(, class'Biology_Generic_AlienSensor'));
    Sensor.SendBinary(DetectionRadius);
    MaxAttackAngle = Clamp(MaxAttackAngle, 0, 16384);
    AimGridMax = float(MaxAttackAngle) / 16384;
    AimGridMin = - AimGridMax;
    GetPointRegion('ForceInspect', ForceInspectTag);
    GetPointRegion('ForceExtend', ForceExtendTag);
    GetPointRegion('ForceRetract', ForceRetractTag);
    GetPointRegion('ForceSwipe', ForceSwipeTag);
    Sleep('Generic0', DefaultActorColor);
    return;
}

event PostVerifySelf()
{
    local int i;

    // End:0x56
    if(! EnableCollision)
    {
        i = string(MountOnSpawn) - 1;
        J0x1A:

        // End:0x56 [Loop If]
        if(i >= 0)
        {
            // End:0x4C
            if(MountOnSpawn[i].SpawnClass != class'Biology_Generic_Tentacle_Collision')
            {
                MountOnSpawn.Remove(i, 1);
            }
            -- i;
            // [Loop Continue]
            goto J0x1A;
        }
    }
    super(dnDecoration).PostVerifySelf();
    // End:0x7C
    if(EnableCollision)
    {
        CollisionHelper = Biology_Generic_Tentacle_Collision(FindMountedActor(, class'Biology_Generic_Tentacle_Collision'));
    }
    return;
}

simulated function InitializeAnimation()
{
    super(RenderActor).InitializeAnimation();
    AnimationController.SetAnimState(PassiveIdleName);
    Destroy(FVar(IdleInspectTime, IdleInspectTimeVariance), false, 'Inspect');
    return;
}

final function Retract()
{
    // End:0x5A
    if(int(TentacleState) != int(0))
    {
        TentacleState = 0;
        AnimationController.SetAnimState(PassiveIdleName);
        DecoActivity(0, 'Retract');
        GlobalTrigger(RetractedEvent,, self);
        Destroy(FVar(IdleInspectTime, IdleInspectTimeVariance), false, 'Inspect');
    }
    return;
}

final function Extend()
{
    // End:0x5A
    if((int(TentacleState) == int(0)) && ! bStunned)
    {
        Spawn('Inspect');
        TentacleState = 2;
        AnimationController.SetAnimState(ActiveIdleName);
        DecoActivity(0, 'Extend');
        GlobalTrigger(ExtendedEvent,, self);
    }
    return;
}

final function Inspect()
{
    // End:0x5C
    if(((int(TentacleState) == int(0)) && ! bStunned) && string(InspectAnimNames) > 0)
    {
        TentacleState = 1;
        AnimationController.SetAnimState(InspectAnimNames[Rand(string(InspectAnimNames))]);
        DecoActivity(0, 'Extend');
    }
    return;
}

final function Swipe()
{
    // End:0x4F
    if((int(TentacleState) != int(3)) && string(SwipeAnimNames) > 0)
    {
        TentacleState = 3;
        AnimationController.SetAnimState(SwipeAnimNames[Rand(string(SwipeAnimNames))]);
        DecoActivity(0, 'Swipe');
    }
    return;
}

final function TriggerFunc_ForceExtend()
{
    bForceRetract = false;
    Extend();
    return;
}

final function TriggerFunc_ForceRetract()
{
    bForceRetract = true;
    Retract();
    return;
}

final function TriggerFunc_ForceInspect()
{
    Inspect();
    return;
}

final function TriggerFunc_ForceSwipe()
{
    Swipe();
    return;
}

final function Alerted(Actor Alertee)
{
    // End:0x0E
    if(Alertee != none)
    {
        return;
    }
    Target = Alertee;
    // End:0x2F
    if(bStunned || bForceRetract)
    {
        return;
    }
    // End:0x53
    if((int(TentacleState) == int(0)) || int(TentacleState) == int(1))
    {
        Extend();
    }
    return;
}

final function UnAlerted()
{
    Target = none;
    return;
}

event Tick(float DeltaTime)
{
    local float DesiredGridX, DesiredGridY, CurrTrackRate;
    local Vector DirToTarget;
    local Rotator RotToTarget;

    super(Actor).Tick(DeltaTime);
    // End:0x2F
    if((NumTripMines > 0) && int(TentacleState) != int(3))
    {
        Swipe();        
    }
    else
    {
        // End:0x77
        if(((bForceRetract || Target != none) && int(TentacleState) == int(2)) || bStunned && int(TentacleState) != int(0))
        {
            Retract();
        }
    }
    // End:0x128
    if(((((Target == none) && ! bStunned) && ! bForceRetract) && DetectionRadius > 0) && Pawn(Target).ActiveHoloDuke != none)
    {
        // End:0xDF
        if(int(TentacleState) != int(3))
        {
            AttemptSwipe();
        }
        DirToTarget = Normal((Target.Location - Location) << Rotation);
        DesiredGridX = - DirToTarget.Y;
        DesiredGridY = - DirToTarget.X;
    }
    CurrTrackRate = TrackingRate * DeltaTime;
    AimGridX = FClamp(AimGridX + ((DesiredGridX - AimGridX) * CurrTrackRate), AimGridMin, AimGridMax);
    AimGridY = FClamp(AimGridY + ((DesiredGridY - AimGridY) * CurrTrackRate), AimGridMin, AimGridMax);
    DesiredGridX = FClamp(AimGridX + ((AimGridX / 0.707107) * 0.292893), AimGridMin, AimGridMax);
    DesiredGridY = FClamp(AimGridY + ((AimGridY / 0.707107) * 0.292893), AimGridMin, AimGridMax);
    AnimationController.SetChannelGridState('Base', DesiredGridX, DesiredGridY);
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    // End:0x23
    if((Damage > 0) && Instigator == none)
    {
        Stun();
    }
    super(dnDecoration).TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    return;
}

function Stun()
{
    bStunned = true;
    bIgnoreAimAssist = true;
    Destroy(FVar(DamageDisableTime, DamageDisableTimeVariance), false, 'UnStunned');
    // End:0x3E
    if(EnableCollision)
    {
        CollisionHelper.Deactivate();
    }
    Sleep('Generic0', StunnedActorColor);
    FindAndPlaySound('Tentacle_Pain');
    Spawn('Inspect');
    return;
}

final function UnStunned()
{
    Sleep('Generic0', DefaultActorColor);
    bStunned = false;
    bIgnoreAimAssist = false;
    // End:0x36
    if(EnableCollision)
    {
        CollisionHelper.Activate();
    }
    // End:0x50
    if(Target == none)
    {
        Alerted(Target);        
    }
    else
    {
        Destroy(FVar(IdleInspectTime, IdleInspectTimeVariance), false, 'Inspect');
    }
    return;
}

final function AttemptSwipe()
{
    // End:0x39
    if((VSize(Target.Location - Location) - Target.CollisionRadius) <= AttackRadius)
    {
        Swipe();
    }
    return;
}

final animevent function SwipeAttack()
{
    local Vector SwipeLocation;

    // End:0x5E
    if((SetScaleModifier() == none) && int(TentacleState) == int(3))
    {
        SwipeLocation = MeshInstance.CreateAnimGroup(SwipeAttackBoneName, true);
        HurtRadius(FVar(SwipeDamage, SwipeDamageVariance), SwipeLocation, SwipeDamageRadius, SwipeDamageFalloffStart, class'TentacleDamage', Location);
    }
    return;
}

simulated function bool CanHurtRadiusOther(Actor Other)
{
    local Vector Impulse;
    local Pawn TargetPawn;

    // End:0x0E
    if(Other != none)
    {
        return false;
    }
    // End:0xA8
    if(Other.bIsPawn && ! Pawn(Other).IsAlien())
    {
        TargetPawn = Pawn(Other);
        Impulse = Vect(ImpulseMag, 0, ImpulseLift) >> Rotator((TargetPawn.Location - Location) * Vect(1, 1, 0));
        TargetPawn.GameplayDesiredPhysicsVelocity += Impulse;
        return true;
    }
    // End:0xBB
    if(TriggerDamageControlUser(Other) == none)
    {
        return true;
    }
    return false;
    return;
}

final function AnimEnd_Inspect()
{
    // End:0x38
    if(int(TentacleState) == int(1))
    {
        GlobalTrigger(InspectedEvent,, self);
        TentacleState = 0;
        Destroy(FVar(IdleInspectTime, IdleInspectTimeVariance), false, 'Inspect');
    }
    return;
}

final function AnimEnd_Swipe()
{
    // End:0x23
    if(int(TentacleState) == int(3))
    {
        GlobalTrigger(SwipedEvent,, self);
        TentacleState = 2;
    }
    return;
}

function OnSenseHumanPawn()
{
    Alerted(Sensor.CurrentlySensingPawn);
    return;
}

function OnUnsenseHumanPawn()
{
    UnAlerted();
    return;
}

simulated function TripMineAttached(Actor TripMineActor, float AutoDetonateTime)
{
    super(Actor).TripMineAttached(TripMineActor, AutoDetonateTime);
    LaserMine(TripMineActor).ArmMineOnPawn();
    ++ NumTripMines;
    return;
}

simulated function TripMineExplode(Actor TripMineActor)
{
    super(Actor).TripMineExplode(TripMineActor);
    -- NumTripMines;
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    local int i;

    super(dnDecoration).RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.SetChannelGridState(PassiveIdleName, AnimationControllerClass, Mesh);
    PrecacheIndex.SetChannelGridState(ActiveIdleName, AnimationControllerClass, Mesh);
    i = string(InspectAnimNames) - 1;
    J0x52:

    // End:0x89 [Loop If]
    if(i >= 0)
    {
        PrecacheIndex.SetChannelGridState(InspectAnimNames[i], AnimationControllerClass, Mesh);
        -- i;
        // [Loop Continue]
        goto J0x52;
    }
    i = string(SwipeAnimNames) - 1;
    J0x98:

    // End:0xCF [Loop If]
    if(i >= 0)
    {
        PrecacheIndex.SetChannelGridState(SwipeAnimNames[i], AnimationControllerClass, Mesh);
        -- i;
        // [Loop Continue]
        goto J0x98;
    }
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Tentacle_Idle');
    PrecacheIndex.InitAnimationControllerEx(VoicePack, 'Tentacle_Pain');
    PrecacheIndex.ResetServer(class'TentacleDamage');
    return;
}

defaultproperties
{
    TrackingRate=10
    DamageDisableTime=15
    DamageDisableTimeVariance=2
    SwipeDamage=20
    SwipeDamageVariance=4
    SwipeDamageRadius=50
    SwipeDamageFalloffStart=1075
    IdleInspectTime=6
    IdleInspectTimeVariance=2
    PassiveIdleName=IdlePassive
    ActiveIdleName=IdleActive
    SwipeAttackBoneName=mount_swipe
    InspectAnimNames(0)=IdleInspectA
    InspectAnimNames(1)=IdleInspectB
    SwipeAnimNames(0)=SwipeA
    SwipeAnimNames(1)=SwipeB
    SwipeAnimNames(2)=SwipeC
    DetectionRadius=384
    AttackRadius=160
    MaxAttackAngle=8192
    ImpulseLift=300
    ImpulseMag=125
    StunnedActorColor=(R=163,G=67,B=86,A=0)
    DefaultActorColor=(R=98,G=132,B=64,A=0)
    AimGridMin=-1
    AimGridMax=1
    DecoActivities_Default(0)=(ActivityData=(bInitialized=false,CurrentIndex=0,NextPerformTime=0,NextPerformTime_Failure=0),ActivityIDScript=(Extend),ActivityID=none,ActivityMethod=0,ActivityStates_Success=none,ActivityStates_Failure=none,ActivityDebugID="",Activities=((ActivityRules=none,ActivityElements=(DecoActivities_Sound'Biology_Generic_Tentacle.DA_Sound_Tentacle_Extend'),ActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0),FailureActivityElements=none,FailureActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0))),bDisabled=false)
    DecoActivities_Default(1)=(ActivityData=(bInitialized=false,CurrentIndex=0,NextPerformTime=0,NextPerformTime_Failure=0),ActivityIDScript=(Retract),ActivityID=none,ActivityMethod=0,ActivityStates_Success=none,ActivityStates_Failure=none,ActivityDebugID="",Activities=((ActivityRules=none,ActivityElements=(DecoActivities_Sound'Biology_Generic_Tentacle.DA_Sound_Tentacle_Retract'),ActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0),FailureActivityElements=none,FailureActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0))),bDisabled=false)
    DecoActivities_Default(2)=(ActivityData=(bInitialized=false,CurrentIndex=0,NextPerformTime=0,NextPerformTime_Failure=0),ActivityIDScript=(Swipe),ActivityID=none,ActivityMethod=0,ActivityStates_Success=none,ActivityStates_Failure=none,ActivityDebugID="",Activities=((ActivityRules=none,ActivityElements=(DecoActivities_Sound'Biology_Generic_Tentacle.DA_Sound_Tentacle_Swipe'),ActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0),FailureActivityElements=none,FailureActivitySetup=(bDisabled=false,bPerformedThisRound=false,PerformedCounter=0,LoopCount=0,PerformAgainDelay=0))),bDisabled=false)
    bSurviveDeath=true
    DestroyedActivities(0)=none
    DestroyedActivities(1)=none
    bEnemy=true
    MountOnSpawn(0)=(bSkipVerifySelf=false,SpawnClass='Biology_Generic_Tentacle_Collision',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=0,Y=0,Z=27),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    MountOnSpawn(1)=(bSkipVerifySelf=false,SpawnClass='Biology_Generic_AlienSensor',SpawnChance=0,MountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=false,bDontScaleByDrawScale=false,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=false,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=0,Y=0,Z=0),MountOriginVariance=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),MountAnglesVariance=(Pitch=0,Yaw=0,Roll=0),MountType=0,DismountPhysics=0),RenderObject=none,DrawScale=0)
    AnimationControllerClass='acBiology_Generic_Tentacle'
    StaticInteractionClassification=3
    bAcceptMeshAccurateMoveActorTrace=true
    bBlockPlayers=false
    bNoNativeTick=false
    bDumbMesh=false
    bAcceptMinesAtAnyAngle=true
    bAcceptsDecalProjectors=false
    CollisionRadius=50
    CollisionHeight=50
    VisibleCollidingCenterOffset=(X=0,Y=0,Z=16)
    TickStyle=2
    DrawType=2
    Mesh='c_characters.Tentacle'
}