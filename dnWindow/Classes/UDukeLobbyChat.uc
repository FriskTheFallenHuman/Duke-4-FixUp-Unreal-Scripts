/*******************************************************************************
 * UDukeLobbyChat generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class UDukeLobbyChat extends UWindowDialogControl;

enum MoveDirs
{
    MD_None,
    MD_Left,
    MD_Right
};

struct LobbyMessageStruct
{
    var string msg;
    var string id;
};

var string TypedStr;
var int SelectionPos;
var array<LobbyMessageStruct> Messages;
var localized string SayStr;
var float cursorBlinkTime;
var float curBlinkTime;
var bool bDrawCursor;
var bool bTyping;
var int maxDisplayLines;
var int maxBuffer;
var int maxStringLength;
var int showPos;
var int showEndPos;
var float sideBuffer;
var UDukeLobbyChat.MoveDirs moveDir;
var Color StringColour;
var float fTextScale;
var float LineSpacingY;
var bool bCtrldown;

function Paint(Canvas C, float X, float Y)
{
    C.Font = C.TallFont;
    fTextScale = 0.7 * class'UWindowScene'.default.TTFontScale;
    // End:0x57
    if(true)
    {
        DrawBottomPlacement(C, X, Y);        
    }
    else
    {
        DrawSidePlacement(C, X, Y);
    }
    super(UWindowWindow).Paint(C, X, Y);
    return;
}

function DrawBottomPlacement(Canvas C, float X, float Y)
{
    local int i, j, K;
    local string tempstr;
    local array<string> strBuffer;
    local float XL, YL, saystrLen, WrapXL;
    local int startLine, endLine;
    local float fChatTextScale;
    local array<string> Parts;

    fChatTextScale = fTextScale;
    // End:0x2E
    if(! bTyping)
    {
        C.DrawColor = StringColour;        
    }
    else
    {
        C.DrawColor = WhiteColor;
    }
    UWindowScene(ParentWindow).DrawBackgroundBox(C, 0, 0, WinWidth, WinHeight);
    UWindowScene(ParentWindow).DrawBackgroundBox(C, 0, WinHeight * 0.9, WinWidth, WinHeight * 0.1);
    showPos = FindShowPosition(C);
    tempstr = Mid(TypedStr, showPos, showEndPos - showPos);
    TextSize(C, SayStr, saystrLen, YL, fChatTextScale, fChatTextScale);
    TextSize(C, Left(tempstr, SelectionPos - showPos), XL, YL, fChatTextScale, fChatTextScale);
    // End:0x18D
    if(bDrawCursor && bTyping)
    {
        ClipText(C, ((WinWidth * 0.02) + XL) + saystrLen, WinHeight * 0.9, "|",, fChatTextScale, fChatTextScale,, 2);
    }
    ClipText(C, WinWidth * 0.02, WinHeight * 0.9, SayStr,, fChatTextScale, fChatTextScale,, 2);
    C.DrawColor = StringColour;
    ClipText(C, (WinWidth * 0.02) + saystrLen, WinHeight * 0.9, tempstr,, fChatTextScale, fChatTextScale,, 2);
    // End:0x23E
    if(! bTyping)
    {
        C.DrawColor = StringColour;        
    }
    else
    {
        C.DrawColor = WhiteColor;
    }
    startLine = Max(string(Messages) - maxDisplayLines, 0);
    endLine = Min(string(Messages), maxDisplayLines + startLine);
    WrapXL = WinWidth - (sideBuffer * WinWidth);
    i = startLine;
    J0x2A7:

    // End:0x50B [Loop If]
    if(i < endLine)
    {
        tempstr = (Messages[i].id $ ": ") $ Messages[i].msg;
        TextSize(C, tempstr, XL, YL, fChatTextScale, fChatTextScale);
        // End:0x4EE
        if(XL > WrapXL)
        {
            Split(tempstr, " ", Parts);
            strBuffer[strBuffer.Add(1)] = Parts[0];
            j = 1;
            J0x345:

            // End:0x4EB [Loop If]
            if(j < string(Parts))
            {
                tempstr = strBuffer[string(strBuffer) - 1] @ Parts[j];
                TextSize(C, tempstr, XL, YL, fChatTextScale, fChatTextScale);
                // End:0x4CC
                if(XL > WrapXL)
                {
                    TextSize(C, Parts[j], XL, YL, fChatTextScale, fChatTextScale);
                    // End:0x4B0
                    if(XL > WrapXL)
                    {
                        K = Len(Parts[j]) - 1;
                        J0x3FB:

                        // End:0x45A [Loop If]
                        if(K > 0)
                        {
                            TextSize(C, Left(Parts[j], K) $ "-", XL, YL, fChatTextScale, fChatTextScale);
                            // End:0x450
                            if(XL <= WrapXL)
                            {
                                // [Explicit Break]
                                goto J0x45A;
                            }
                            -- K;
                            // [Loop Continue]
                            goto J0x3FB;
                        }
                        J0x45A:

                        Parts.Insert(j + 1, 1);
                        Parts[j + 1] = Mid(Parts[j], K);
                        Parts[j] = Left(Parts[j], K) $ "-";
                    }
                    strBuffer[strBuffer.Add(1)] = Parts[j];
                    // [Explicit Continue]
                    goto J0x4E1;
                }
                strBuffer[string(strBuffer) - 1] = tempstr;
                J0x4E1:

                ++ j;
                // [Loop Continue]
                goto J0x345;
            }
            // [Explicit Continue]
            goto J0x501;
        }
        strBuffer[strBuffer.Add(1)] = tempstr;
        J0x501:

        ++ i;
        // [Loop Continue]
        goto J0x2A7;
    }
    i = 0;
    J0x512:

    // End:0x593 [Loop If]
    if(i < Min(string(strBuffer), maxDisplayLines))
    {
        ClipText(C, WinWidth * 0.02, WinHeight * (0.01 + (float(i) * LineSpacingY)), strBuffer[Max(string(strBuffer) - maxDisplayLines, 0) + i],, fChatTextScale, fChatTextScale,, 2);
        ++ i;
        // [Loop Continue]
        goto J0x512;
    }
    return;
}

function DrawSidePlacement(Canvas C, float X, float Y)
{
    return;
}

function int FindShowPosition(Canvas C)
{
    local string tempstr;
    local float XL, YL;
    local int iTemp, newShowPos;
    local float saystrWidth;
    local bool bMiddleMoving;

    // End:0x14
    if(int(moveDir) == int(0))
    {
        return showPos;
    }
    tempstr = SayStr $ TypedStr;
    TextSize(C, Left(tempstr, SelectionPos + Len(SayStr)), XL, YL, fTextScale, fTextScale);
    // End:0x92
    if(XL < (WinWidth - (sideBuffer * WinWidth)))
    {
        moveDir = 0;
        showEndPos = Len(TypedStr);
        return 0;
    }
    TextSize(C, SayStr, XL, YL, fTextScale, fTextScale);
    saystrWidth = XL;
    // End:0x1D1
    if(int(moveDir) == int(2))
    {
        XL = 1E+08;
        iTemp = 0;
        J0xE1:

        // End:0x1CE [Loop If]
        if((XL + saystrWidth) > (WinWidth - (sideBuffer * WinWidth)))
        {
            // End:0x181
            if(SelectionPos >= showEndPos)
            {
                TextSize(C, Mid(TypedStr, showPos + iTemp, SelectionPos - (showPos + iTemp)), XL, YL, fTextScale, fTextScale);
                newShowPos = showPos + iTemp;
                showEndPos = SelectionPos;
                ++ iTemp;                
            }
            else
            {
                TextSize(C, Mid(TypedStr, showPos, showEndPos - showPos), XL, YL, fTextScale, fTextScale);
                -- showEndPos;
                newShowPos = showPos;
            }
            // [Loop Continue]
            goto J0xE1;
        }        
    }
    else
    {
        // End:0x28D
        if(showEndPos >= Len(TypedStr))
        {
            XL = -1E+08;
            iTemp = 0;
            newShowPos = showPos;
            J0x200:

            // End:0x283 [Loop If]
            if((XL + saystrWidth) <= (WinWidth - (sideBuffer * WinWidth)))
            {
                TextSize(C, Mid(TypedStr, newShowPos, showEndPos), XL, YL, fTextScale, fTextScale);
                // End:0x280
                if((XL + saystrWidth) <= (WinWidth - (sideBuffer * WinWidth)))
                {
                    -- newShowPos;
                }
                // [Loop Continue]
                goto J0x200;
            }
            ++ newShowPos;            
        }
        else
        {
            XL = 1E+08;
            iTemp = 0;
            J0x29F:

            // End:0x336 [Loop If]
            if((XL + saystrWidth) > (WinWidth - (sideBuffer * WinWidth)))
            {
                // End:0x330
                if((SelectionPos < showPos) && showEndPos > SelectionPos)
                {
                    TextSize(C, Mid(TypedStr, SelectionPos, showEndPos - SelectionPos), XL, YL, fTextScale, fTextScale);
                    newShowPos = SelectionPos;
                    -- showEndPos;                    
                }
                else
                {
                    // [Explicit Break]
                    goto J0x336;
                }
                // [Loop Continue]
                goto J0x29F;
            }
        }
    }
    J0x336:

    moveDir = 0;
    return newShowPos;
    return;
}

function KeyType(int Key, float X, float Y)
{
    // End:0x0D
    if(! bTyping)
    {
        return;
    }
    // End:0x26
    if((Key == 9) || bCtrldown)
    {
        return;
    }
    curBlinkTime = 0;
    bDrawCursor = true;
    // End:0x91
    if(Key == 8)
    {
        // End:0x8F
        if(SelectionPos != 0)
        {
            TypedStr = Left(TypedStr, SelectionPos - 1) $ Mid(TypedStr, SelectionPos);
            SelectionPos = Max(0, SelectionPos - 1);
            moveDir = 1;
        }
        return;
    }
    // End:0xA5
    if(Len(TypedStr) >= maxStringLength)
    {
        return;
    }
    TypedStr = (Left(TypedStr, SelectionPos) $ Chr(Key)) $ Mid(TypedStr, SelectionPos);
    SelectionPos += 1;
    moveDir = 2;
    return;
}

function bool KeyEvent(int Key)
{
    local string temp;

    // End:0x0D
    if(! bTyping)
    {
        return false;
    }
    // End:0x24
    if(Key == 27)
    {
        TypedStr = "";        
    }
    else
    {
        // End:0x60
        if(Key == 13)
        {
            // End:0x5D
            if(TypedStr != "")
            {
                UWindowScene(ParentWindow).SendMSG(TypedStr);
                ClearTypedStr();
            }            
        }
        else
        {
            // End:0x76
            if(Key == 36)
            {
                SelectionPos = 0;                
            }
            else
            {
                // End:0x93
                if(Key == 35)
                {
                    SelectionPos = Len(TypedStr);                    
                }
                else
                {
                    // End:0xC8
                    if(Key == 46)
                    {
                        TypedStr = Left(TypedStr, SelectionPos) $ Mid(TypedStr, SelectionPos + 1);                        
                    }
                    else
                    {
                        // End:0xF0
                        if(Key == 37)
                        {
                            SelectionPos = Max(0, SelectionPos - 1);
                            moveDir = 1;                            
                        }
                        else
                        {
                            // End:0x11C
                            if(Key == 39)
                            {
                                SelectionPos = Min(Len(TypedStr), SelectionPos + 1);
                                moveDir = 2;
                            }
                        }
                    }
                }
            }
        }
    }
    return true;
    return;
}

function KeyUp(int Key, float X, float Y)
{
    super.KeyUp(Key, X, Y);
    // End:0x29
    if(Key == 17)
    {
        bCtrldown = false;
    }
    return;
}

function KeyDown(int Key, float X, float Y)
{
    super.KeyDown(Key, X, Y);
    // End:0x29
    if(Key == 17)
    {
        bCtrldown = true;
    }
    return;
}

function AddMessage(string msg, string senderName)
{
    local LobbyMessageStruct temp;

    temp.id = senderName;
    temp.msg = msg;
    // End:0x38
    if(string(Messages) >= maxBuffer)
    {
        Messages.Remove(0, 1);
    }
    Messages[Messages.Add(1)] = temp;
    return;
}

function ClearMsgs()
{
    Messages.Empty();
    ClearTypedStr();
    return;
}

function Reset()
{
    ClearMsgs();
    bTyping = false;
    return;
}

function ClearTypedStr()
{
    SelectionPos = 0;
    showPos = 0;
    showEndPos = 0;
    TypedStr = "";
    moveDir = 0;
    return;
}

function Tick(float Delta)
{
    curBlinkTime += Delta;
    // End:0x35
    if(curBlinkTime >= cursorBlinkTime)
    {
        curBlinkTime = 0;
        bDrawCursor = ! bDrawCursor;
    }
    super(UWindowWindow).Tick(Delta);
    return;
}

defaultproperties
{
    SayStr="<?int?dnWindow.UDukeLobbyChat.SayStr?>"
    cursorBlinkTime=1
    maxDisplayLines=9
    maxBuffer=64
    maxStringLength=128
    sideBuffer=0.1
    StringColour=(R=170,G=170,B=170,A=0)
    fTextScale=0.7
    LineSpacingY=0.098
}