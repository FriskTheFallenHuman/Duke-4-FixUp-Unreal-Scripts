/*******************************************************************************
 * CurvedStairBuilder generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CurvedStairBuilder extends BrushBuilder;

var() int InnerRadius;
var() int StepHeight;
var() int StepWidth;
var() int AngleOfCurve;
var() int NumSteps;
var() int AddToFirstStep;
var() name GroupName;
var() bool CounterClockwise;

function BuildCurvedStair(int Direction)
{
    local Rotator RotStep;
    local Vector vtx, NewVtx;
    local int X, Z, InnerStart, OuterStart, BottomInnerStart, BottomOuterStart,
	    Adjustment;

    RotStep.Yaw = int(float(65536) * (float(AngleOfCurve) / 360)) / NumSteps;
    // End:0x50
    if(CounterClockwise)
    {
        RotStep.Yaw *= float(-1);
        Direction *= float(-1);
    }
    InnerStart = GetVertexCount();
    vtx.X = float(InnerRadius);
    X = 0;
    J0x74:

    // End:0x12D [Loop If]
    if(X < (NumSteps + 1))
    {
        // End:0x9F
        if(X == 0)
        {
            Adjustment = AddToFirstStep;            
        }
        else
        {
            Adjustment = 0;
        }
        NewVtx = vtx >> (RotStep * float(X));
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z - float(Adjustment));
        vtx.Z += float(StepHeight);
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
        ++ X;
        // [Loop Continue]
        goto J0x74;
    }
    OuterStart = GetVertexCount();
    vtx.X = float(InnerRadius + StepWidth);
    vtx.Z = 0;
    X = 0;
    J0x168:

    // End:0x221 [Loop If]
    if(X < (NumSteps + 1))
    {
        // End:0x193
        if(X == 0)
        {
            Adjustment = AddToFirstStep;            
        }
        else
        {
            Adjustment = 0;
        }
        NewVtx = vtx >> (RotStep * float(X));
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z - float(Adjustment));
        vtx.Z += float(StepHeight);
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
        ++ X;
        // [Loop Continue]
        goto J0x168;
    }
    BottomInnerStart = GetVertexCount();
    vtx.X = float(InnerRadius);
    vtx.Z = 0;
    X = 0;
    J0x255:

    // End:0x2B8 [Loop If]
    if(X < (NumSteps + 1))
    {
        NewVtx = vtx >> (RotStep * float(X));
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z - float(AddToFirstStep));
        ++ X;
        // [Loop Continue]
        goto J0x255;
    }
    BottomOuterStart = GetVertexCount();
    vtx.X = float(InnerRadius + StepWidth);
    X = 0;
    J0x2E3:

    // End:0x346 [Loop If]
    if(X < (NumSteps + 1))
    {
        NewVtx = vtx >> (RotStep * float(X));
        Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z - float(AddToFirstStep));
        ++ X;
        // [Loop Continue]
        goto J0x2E3;
    }
    X = 0;
    J0x34D:

    // End:0x504 [Loop If]
    if(X < NumSteps)
    {
        Poly4i(Direction, (InnerStart + (X * 2)) + 2, (InnerStart + (X * 2)) + 1, (OuterStart + (X * 2)) + 1, (OuterStart + (X * 2)) + 2, 'steptop');
        Poly4i(Direction, (InnerStart + (X * 2)) + 1, InnerStart + (X * 2), OuterStart + (X * 2), (OuterStart + (X * 2)) + 1, 'stepfront');
        Poly4i(Direction, BottomInnerStart + X, (InnerStart + (X * 2)) + 1, (InnerStart + (X * 2)) + 2, (BottomInnerStart + X) + 1, 'innercurve');
        Poly4i(Direction, (OuterStart + (X * 2)) + 1, BottomOuterStart + X, (BottomOuterStart + X) + 1, (OuterStart + (X * 2)) + 2, 'outercurve');
        Poly4i(Direction, BottomInnerStart + X, (BottomInnerStart + X) + 1, (BottomOuterStart + X) + 1, BottomOuterStart + X, 'Bottom');
        ++ X;
        // [Loop Continue]
        goto J0x34D;
    }
    Poly4i(Direction, BottomInnerStart + NumSteps, InnerStart + (NumSteps * 2), OuterStart + (NumSteps * 2), BottomOuterStart + NumSteps, 'Back');
    return;
}

function bool Build()
{
    local int i, j, K;

    // End:0x39
    if((AngleOfCurve < 1) || AngleOfCurve > 360)
    {
        return BadParameters("Angle is out of range.");
    }
    // End:0x65
    if(((InnerRadius < 1) || StepWidth < 1) || NumSteps < 1)
    {
        return BadParameters();
    }
    BeginBrush(false, GroupName);
    BuildCurvedStair(1);
    return EndBrush();
    return;
}

defaultproperties
{
    InnerRadius=240
    StepHeight=16
    StepWidth=256
    AngleOfCurve=90
    NumSteps=4
    GroupName=CStair
    BitmapFilename="BBCurvedStair"
    ToolTip="Curved Staircase"
}