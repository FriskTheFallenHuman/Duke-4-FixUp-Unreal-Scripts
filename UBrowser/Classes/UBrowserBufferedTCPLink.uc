/*******************************************************************************
 * UBrowserBufferedTCPLink generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class UBrowserBufferedTCPLink extends TcpLink
    transient
    collapsecategories
    hidecategories(movement,Collision,Lighting,LightColor);

var string InputBuffer;
var string OutputBuffer;
var string CRLF;
var string CR;
var string LF;
var bool bWaiting;
var float WaitTimeoutTime;
var string WaitingFor;
var int WaitForCountChars;
var string WaitResult;
var int WaitMatchData;

function ResetBuffer()
{
    InputBuffer = "";
    OutputBuffer = "";
    bWaiting = false;
    CRLF = Chr(10) $ Chr(13);
    CR = Chr(13);
    LF = Chr(10);
    return;
}

function WaitFor(string What, float TimeOut, int MatchData)
{
    bWaiting = true;
    WaitingFor = What;
    WaitForCountChars = 0;
    WaitTimeoutTime = Level.TimeSeconds + TimeOut;
    WaitMatchData = MatchData;
    WaitResult = "";
    return;
}

function WaitForCount(int Count, float TimeOut, int MatchData)
{
    bWaiting = true;
    WaitingFor = "";
    WaitForCountChars = Count;
    WaitTimeoutTime = Level.TimeSeconds + TimeOut;
    WaitMatchData = MatchData;
    WaitResult = "";
    return;
}

function GotMatch(int MatchData)
{
    return;
}

function GotMatchTimeout(int MatchData)
{
    return;
}

function string ParseDelimited(string Text, string Delimiter, int Count, optional bool bToEndOfLine)
{
    local string Result;
    local int Found, i;
    local string S;

    Result = "";
    Found = 1;
    i = 0;
    J0x16:

    // End:0xC0 [Loop If]
    if(i < Len(Text))
    {
        S = Mid(Text, i, 1);
        // End:0x94
        if(InStr(Delimiter, S) != -1)
        {
            // End:0x8A
            if(Found == Count)
            {
                // End:0x84
                if(bToEndOfLine)
                {
                    return Result $ Mid(Text, i);                    
                }
                else
                {
                    return Result;
                }
            }
            ++ Found;
            // [Explicit Continue]
            goto J0xB6;
        }
        // End:0xB6
        if(Found >= Count)
        {
            Result = Result $ S;
        }
        J0xB6:

        ++ i;
        // [Loop Continue]
        goto J0x16;
    }
    return Result;
    return;
}

function int ReadChar()
{
    local int C;

    // End:0x0F
    if(InputBuffer == "")
    {
        return 0;
    }
    C = Asc(Left(InputBuffer, 1));
    InputBuffer = Mid(InputBuffer, 1);
    return C;
    return;
}

function int PeekChar()
{
    local int C;

    // End:0x0F
    if(InputBuffer == "")
    {
        return 0;
    }
    return Asc(Left(InputBuffer, 1));
    return;
}

function bool ReadBufferedLine(out string Text)
{
    local int i;

    i = InStr(InputBuffer, Chr(13));
    // End:0x24
    if(i == -1)
    {
        return false;
    }
    Text = Left(InputBuffer, i);
    // End:0x5A
    if(Mid(InputBuffer, i + 1, 1) == Chr(10))
    {
        ++ i;
    }
    InputBuffer = Mid(InputBuffer, i + 1);
    return true;
    return;
}

function SendBufferedData(string Text)
{
    OutputBuffer = OutputBuffer $ Text;
    return;
}

event ReceivedText(string Text)
{
    InputBuffer = InputBuffer $ Text;
    return;
}

function DoBufferQueueIO()
{
    local int i;

    J0x00:
    // End:0x13D [Loop If]
    if(bWaiting)
    {
        // End:0x35
        if(Level.TimeSeconds > WaitTimeoutTime)
        {
            bWaiting = false;
            GotMatchTimeout(WaitMatchData);
        }
        // End:0x91
        if(WaitForCountChars > 0)
        {
            // End:0x55
            if(Len(InputBuffer) < WaitForCountChars)
            {
                // [Explicit Break]
                goto J0x13D;
            }
            WaitResult = Left(InputBuffer, WaitForCountChars);
            InputBuffer = Mid(InputBuffer, WaitForCountChars);
            bWaiting = false;
            GotMatch(WaitMatchData);            
        }
        else
        {
            i = InStr(InputBuffer, WaitingFor);
            // End:0xD8
            if((i == -1) && WaitingFor == CR)
            {
                i = InStr(InputBuffer, LF);
            }
            // End:0x137
            if(i != -1)
            {
                WaitResult = Left(InputBuffer, i + Len(WaitingFor));
                InputBuffer = Mid(InputBuffer, i + Len(WaitingFor));
                bWaiting = false;
                GotMatch(WaitMatchData);                
            }
            else
            {
                // [Explicit Break]
                goto J0x13D;
            }
        }
        // [Loop Continue]
        goto J0x00;
    }
    J0x13D:

    // End:0x164
    if(CheckAIGate())
    {
        i = UpdateAIGate(OutputBuffer);
        OutputBuffer = Mid(OutputBuffer, i);
    }
    return;
}

defaultproperties
{
    ReceiveMode=1
}