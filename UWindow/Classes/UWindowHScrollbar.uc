/*******************************************************************************
 * UWindowHScrollbar generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class UWindowHScrollbar extends UWindowWindow
    dependson(UWindowSBLeftButton)
    dependson(UWindowSBRightButton);

var UWindowSBLeftButton LeftButton;
var UWindowSBRightButton RightButton;
var bool bDisabled;
var float MinPos;
var float MaxPos;
var float MaxVisible;
var float pos;
var float ThumbStart;
var float ThumbWidth;
var float NextClickTime;
var float DragX;
var bool bDragging;
var float ScrollAmount;

function Show(float P)
{
    // End:0x0E
    if(P < float(0))
    {
        return;
    }
    // End:0x26
    if(P > (MaxPos + MaxVisible))
    {
        return;
    }
    J0x26:

    // End:0x4B [Loop If]
    if(P < pos)
    {
        // End:0x48
        if(! Scroll(-1))
        {
            // [Explicit Break]
            goto J0x4B;
        }
        // [Loop Continue]
        goto J0x26;
    }
    J0x4B:

    // End:0x7B [Loop If]
    if((P - pos) > (MaxVisible - float(1)))
    {
        // End:0x78
        if(! Scroll(1))
        {
            // [Explicit Break]
            goto J0x7B;
        }
        // [Loop Continue]
        goto J0x4B;
    }
    J0x7B:

    return;
}

function bool Scroll(float Delta)
{
    local float OldPos;

    OldPos = pos;
    pos = pos + Delta;
    CheckRange();
    return pos == (OldPos + Delta);
    return;
}

function SetRange(float NewMinPos, float NewMaxPos, float NewMaxVisible, optional float NewScrollAmount)
{
    // End:0x17
    if(NewScrollAmount == float(0))
    {
        NewScrollAmount = 1;
    }
    ScrollAmount = NewScrollAmount;
    MinPos = NewMinPos;
    MaxPos = NewMaxPos - NewMaxVisible;
    MaxVisible = NewMaxVisible;
    CheckRange();
    return;
}

function CheckRange()
{
    // End:0x1D
    if(pos < MinPos)
    {
        pos = MinPos;        
    }
    else
    {
        // End:0x37
        if(pos > MaxPos)
        {
            pos = MaxPos;
        }
    }
    bDisabled = MaxPos <= MinPos;
    LeftButton.bDisabled = bDisabled;
    RightButton.bDisabled = bDisabled;
    // End:0x8F
    if(bDisabled)
    {
        pos = 0;        
    }
    else
    {
        ThumbStart = ((pos - MinPos) * (WinWidth - float(2 * LookAndFeel.SBPosIndicator.W))) / ((MaxPos + MaxVisible) - MinPos);
        ThumbWidth = float(LookAndFeel.SBPosIndicator.h);
        // End:0x12D
        if(ThumbWidth < float(LookAndFeel.SBPosIndicator.W))
        {
            ThumbWidth = float(LookAndFeel.SBPosIndicator.W);
        }
        // End:0x18B
        if((ThumbWidth + ThumbStart) > (WinWidth - float(2 * LookAndFeel.SBPosIndicator.W)))
        {
            ThumbStart = (WinWidth - float(2 * LookAndFeel.SBPosIndicator.W)) - ThumbWidth;
        }
        ThumbStart = ThumbStart + float(LookAndFeel.SBPosIndicator.h);
    }
    return;
}

function Created()
{
    super.Created();
    LeftButton = UWindowSBLeftButton(CreateWindow(class'UWindowSBLeftButton', 0, 0, float(LookAndFeel.SBLeftUp.W), float(LookAndFeel.SBLeftUp.h)));
    RightButton = UWindowSBRightButton(CreateWindow(class'UWindowSBRightButton', WinWidth - float(10), 0, float(LookAndFeel.SBRightUp.W), float(LookAndFeel.SBRightUp.h)));
    return;
}

function BeforePaint(Canvas C, float X, float Y)
{
    LeftButton.WinTop = 1;
    LeftButton.WinLeft = -1;
    RightButton.WinTop = 1;
    RightButton.WinLeft = (WinWidth - float(LookAndFeel.SBRightUp.W)) + float(1);
    CheckRange();
    return;
}

function Paint(Canvas C, float X, float Y)
{
    LookAndFeel.SB_HDraw(self, C);
    return;
}

function LMouseDown(float X, float Y)
{
    super.LMouseDown(X, Y);
    // End:0x1B
    if(bDisabled)
    {
        return;
    }
    // End:0x5A
    if(X < ThumbStart)
    {
        Scroll(- MaxVisible - float(1));
        NextClickTime = GetLevel().TimeSeconds + 0.5;
        return;
    }
    // End:0x9E
    if(X > (ThumbStart + ThumbWidth))
    {
        Scroll(MaxVisible - float(1));
        NextClickTime = GetLevel().TimeSeconds + 0.5;
        return;
    }
    // End:0xF1
    if((X >= ThumbStart) && X <= (ThumbStart + ThumbWidth))
    {
        DragX = X - ThumbStart;
        bDragging = true;
        Root.CaptureMouse();
        return;
    }
    return;
}

function Tick(float Delta)
{
    local bool bLeft, bRight;
    local float X, Y;

    // End:0x0B
    if(bDragging)
    {
        return;
    }
    bLeft = false;
    bRight = false;
    // End:0x61
    if(bMouseDown)
    {
        GetMouseXY(X, Y);
        bLeft = X < ThumbStart;
        bRight = X > (ThumbStart + ThumbWidth);
    }
    // End:0xCD
    if(((bMouseDown && NextClickTime > float(0)) && NextClickTime < GetLevel().TimeSeconds) && bLeft)
    {
        Scroll(- MaxVisible - float(1));
        NextClickTime = GetLevel().TimeSeconds + 0.1;
    }
    // End:0x137
    if(((bMouseDown && NextClickTime > float(0)) && NextClickTime < GetLevel().TimeSeconds) && bRight)
    {
        Scroll(MaxVisible - float(1));
        NextClickTime = GetLevel().TimeSeconds + 0.1;
    }
    // End:0x167
    if(! bMouseDown || ! bLeft && ! bRight)
    {
        NextClickTime = 0;
    }
    return;
}

function MouseMove(float X, float Y)
{
    // End:0x8E
    if((bDragging && bMouseDown) && ! bDisabled)
    {
        J0x21:

        // End:0x56 [Loop If]
        if((X < (ThumbStart + DragX)) && pos > MinPos)
        {
            Scroll(-1);
            // [Loop Continue]
            goto J0x21;
        }
        J0x56:

        // End:0x8B [Loop If]
        if((X > (ThumbStart + DragX)) && pos < MaxPos)
        {
            Scroll(1);
            // [Loop Continue]
            goto J0x56;
        }        
    }
    else
    {
        bDragging = false;
    }
    return;
}
