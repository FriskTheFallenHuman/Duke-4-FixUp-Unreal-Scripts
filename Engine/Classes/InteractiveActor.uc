/*******************************************************************************
 * InteractiveActor generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class InteractiveActor extends RenderActor
    abstract
    native
    nativereplication
    collapsecategories
    notplaceable
    dependson(PrecacheIndex)
    dependson(LevelInfo)
    dependson(SoftParticleSystem)
    dependson(BeamSystem)
    dependson(PhysicsAction_ConstVel)
    dependson(PhysicsAction_ConstAccel)
    dependson(MeshInstance)
    dependson(GameReplicationInfo)
    dependson(PhysicsVolume)
    dependson(GearboxEngineGlobals);

const CarriedActor_MaxNoPenaltyMass = 100.0;
const CarriedActor_PenaltyScaleMass = 100.0;

enum EFlushStyle
{
    FLUSH_None,
    FLUSH_Down,
    FLUSH_Shrink,
    FLUSH_Clog
};

enum EShrunkUseStyle
{
    SHRUNKUSE_Never,
    SHRUNKUSE_Always,
    SHRUNKUSE_SameSize,
    SHRUNKUSE_OnlyShrunk
};

struct SGrabInfo
{
    var() noexport bool bCanDuckWhileHeld "Whether the pawn holding us can duck while carrying us.";
    var() noexport name MountItemOverride "Special case override of the MountMeshItem we want to be mounted to, instead of the one the Pawn picking us up specifies. If the bone doesn't exist, falls back to the Pawn specified one.";
    var() noexport Vector MountOrigin "Positional offset from MountMeshItem for mounting this Actor.";
    var() noexport Rotator MountAngles "Rotational offset from MountMeshItem for mounting this Actor.";
    var() noexport name GrabAnimName "Animation to play on this InteractiveActor when it is grabbed. Type LeaveAsIs_ if you wish the InteractiveActor to simply be left in whatever position it was found in.";
    var() noexport name CarrierAnimName "Animation to play on the pawn that is carrying us.";
    var() noexport name CarrierMountPose "Animation to play on the pawn to position the carried item mount.";
    var() noexport name GrabSoundName "VoicePack entry to play when this Actor is grabbed.";
    var() noexport name ThrowSoundName "VoicePack entry to play when this Actor is thrown.";
    var SSoundInfo GrabSoundInfo;
    var SSoundInfo ThrowSoundInfo;
};

struct SMicrowaveInfo
{
    var() noexport float TimeToMicrowave "How long it takes for this item to get microwaved. Set to > 0 to enable micrwavability.";
    var InteractiveActor MicrowaveActor;
    var float LastMicrowaveTime;
};

struct SExitWoundInfo
{
    var() noexport class<DamageType> DamageType "Which damagetype should cause this sort of exit wound? (If None, will accept all damagetypes.)";
    var() noexport float MinimumDamage "We must take at least this much damage before we consider spawning our effects for an exit wound.";
    var() noexport float RandomChance "If non-zero, this is the change (0.0 - 1.0) that if our other criteria are met, we'll spawn this decal.";
    var() noexport class<Decal> ExitWoundDecalClass "Spawn this type decal type (facing the direction the damage would exit the actor from) when damage of the correct type is taken.";
};

var(Challenges) noexport name ChallengeTag "A challenge tag name.";
var(Challenges) const noexport bool ShowWhenChallengeLocked "When true the item will be shown when the challenge is locked and hidden when it is unlocked";
var(Challenges) name ShowComponentEvent;
var(Challenges) name HideComponentEvent;
var(Challenges) noexport float ProximityDistance "Used to teleport player away when object is unhidden within this radius distance";
var(Challenges) noexport float GlowDistance "The distance at which the object will start glowing";
var(Challenges) noexport bool bChallengeGlow "If the object should glow in MyDigs";
var(Challenges) noexport name ChallengeTurnOnGlowTag "Tag for event to turn on glow";
var(Challenges) noexport name ChallengeTurnOffGlowTag "Tag for event to turn off glow";
var(InteractHUDInfo) noexport bool bLookWhenHidden "If true, the HUD can see this actor even when it's hidden.";
var(InteractHUDInfo) noexport bool bDrawHUDInfo "If true, then when a player is looking at the object, it will display the information bar on the HUD.";
var(InteractHUDInfo) noexport bool bDrawUsePhrase "Whether to display the Use Phrase or not.";
var(InteractHUDInfo) noexport bool bNoUseKeyInfo "If true, then it will only display the Use Phrase, not the 'Press 'E' to ' type of information";
var(InteractHUDInfo) noexport bool bForceUsePhrase "If true, this will force it to always use the use phrase, instead of autogenerating the 'use' and 'grab' properties.";
var(InteractHUDInfo) noexport bool bUnUseOnLookChange "Cause an UnUse to fire off when this actor is looked away from in the HUD.";
var(InteractUsing) noexport bool bUsable "When this is true, then when a PlayerPawn presses 'use' on the actor it will execute the Used code.";
var(InteractUsing) noexport bool bUnUsable "When this is true, then when the PlayerPawn lets go of the 'use' key, it will perform the UnUsed code.";
var(InteractUsing) noexport bool bUseTriggered "Triggered by player use.";
var(InteractUsing) noexport bool bGrabUsable "Actor is capable of being used while it is being held.";
var(InteractUsing) noexport bool bGrabUnusable "Actor is capable of being un-used while it is being held.";
var(InteractUsing) noexport bool bCheckUseAngle "Set this to true to force checking UseAngleThreshold. This is an optimization to prevent some math from being calculated on things that don't need to check angles.";
var(InteractUsing) noexport bool bMimicOwner "When this is true, pass all interaction checks to the owner of this actor.  If owner is None or not an InteractiveActor, this flag is ignored.";
var(InteractUsing) noexport bool bPassUseToOwner "When this is true, pass Used to the owner of this actor.  If owner is None or not an InteractiveActor, this flag is ignored.";
var(InteractGrabbing) noexport bool bGrabbable "This object is able to be grabbed and carried.";
var bool SavedbGrabbable;
var bool BeingThrown;
var bool WasThrownByPlayer;
var bool ReservedForPickup;
var bool UnderTelekineticControl;
var bool BeingTelekineticThrown;
var(InteractTeleKinesis) const noexport bool bTelekineticable "This object is able to be moved by Telekinetic creatures.";
var(InteractTeleKinesis) noexport bool bTelekineticableSingleOnly "This cant be TKd if we are already TKing something else";
var(InteractMisc) noexport bool bShowUpOnRadar "If true, then if a radar is looking for an actor of this class, it will show up on it.";
var(InteractEMP) noexport bool bShielded "Should this actor spawn a shield whenever it takes damage? (This will probably be silly for killable actors.";
var bool bEMPulsed;
var bool bMultiEMPulse;
var bool bAbsorbDamage;
var bool bIgnoreTestCanSeeMe;
var(Advanced) const noexport bool bCanShowSelf "If true, will exist in the AIInterests list for use as a look target.";
var(InteractUsing) noexport InteractiveActor.EShrunkUseStyle ShrunkUseStyle "How pawns can interact with this actor when they are shrunken.";
var(InteractGrabbing) noexport InteractiveActor.EShrunkUseStyle ShrunkGrabStyle "Controls when pawns can grab this actor.  Same as ShrunkUseStyle, but for grabbing.";
var(InteractGrabbing) noexport Object.EPhysics ThrowPhysics "Physics to assign when the actor is thrown.";
var Object.EPhysics PostTKPhysics;
var(InteractHUDInfo) noexport localized string UsePhrase "Phrase placed in the hud when you are looking at an object. Indicates the action taken when it's used.";
var(InteractHUDInfo) noexport localized string GrabUsePhrase "Phrase placed in the hud when you are holding an object and it can be grab used.";
var(InteractHUDInfo) noexport localized string GrabUseCombinePhrase "Phrase placed in the hud when you are holding an object, but looking at this object, and they can be combined together.";
var(InteractHUDInfo) string IconGrab;
var(InteractHUDInfo) string IconUse;
var(InteractUsing) noexport array<Actor.EPostureStateEx> UsePostureSuccess "Player must be in one of these posture states to succeed a use call.";
var(InteractUsing) noexport array<Actor.EPostureStateEx> UsePostureFailure "Player can not be in any of these posture states to succeed a use call.";
var(InteractUsing) noexport array<Object.EPhysics> UsePhysicsSuccess "Player must be in one of these physics modes to succeed a use call.";
var(InteractUsing) noexport array<Object.EPhysics> UsePhysicsFailure "Player can not be in any of these physics states to succeed a use call.";
var(InteractUsing) noexport float UseAngleThreshold "Player must be within this angle to use the specified item. This is only for PlayerPawns, AI can use it from any angle.";
var float EndViewingAngleMinDiff;
var Pawn CarriedBy;
var(InteractGrabbing) noexport SGrabInfo GrabInfo "Information for how this actor carried when it gets grabbed.";
var(InteractGrabbing) noexport float ThrowForce "Force with which to throw the actor if non-zero";
var(InteractGrabbing) noexport name ThrowBone "Apply the force to throw the object at this bone.";
var(InteractGrabbing) noexport Rotator ThrowBaseRotation "Base rotation when thrown.";
var(InteractGrabbing) noexport Rotator ThrowBaseRotationVariance "Amount to vary the base rotation when thrown by.";
var(InteractGrabbing) noexport Rotator ThrowDropBaseRotation "Base rotation when dropped.";
var(InteractGrabbing) noexport float ThrowForceScale "Scale normal throwing velocity by this amount.";
var(InteractGrabbing) noexport float ThrowForceScaleAI "Scale normal throwing velocity by this amount.";
var(InteractTeleKinesis) noexport string TelekinesisChargeClassName "Class to use for the Telekinesis effects.";
var(InteractTeleKinesis) noexport string TelekinesisBeamSystemClassName "Class to use for the Telekinesis Beam system";
var(InteractTeleKinesis) noexport Vector TelekinesisAngularVel "Angular Velocity when being controlled by Telekinesis.";
var(InteractTeleKinesis) noexport float TelekinesisThrowVel "Velocity we get thrown at when TK'd";
var SoftParticleSystem TelekinesisCharge;
var BeamSystem TelekinesisBeamSystem;
var(InteractMisc) noexport SMicrowaveInfo MicrowaveInfo "Information relating to microwaving this object.";
var(InteractMisc) array<SExitWoundInfo> ExitWoundInfo;
var InteractiveActor VendOwner;
var VendItemInfo VendInfo;
var(InteractEMP) noexport class<RenderActor> ShieldClass "What type of class should the shield be if [bShielded] is set?";
var(InteractEMP) float ShieldLifetime;
var(InteractEMP) float ShieldScaleFactor;
var(InteractEMP) MaterialEx ShieldTex;
var(InteractEMP) noexport name ForceEMPTag "Trigger this tag to force this InteractiveActor to start acting like it was hit by an EMP blast.";
var(InteractEMP) noexport name ForceUnEMPTag "Trigger this tag to force this InteractiveActor to stop acting like it was hit by an EMP blast.";
var(InteractEMP) noexport float ForcedEMPDisableTime "Same as EMPDisableTime, but used for Forced EMP when non-zero.";
var(InteractEMP) noexport float EMPDisableTime "Less than 0.0 means none, 0.0 means forever, and greater than 0.0 is the disable time.";
var RenderActor ShieldActor;
var float LastEMPTime;
var float DamageAbsorbAmount;
var float DamageAbsorbPct;
var float AvoidRange;
var(Startup) noexport anim name StartAnimSequence "Animation to start this Actor with";
var(Startup) noexport float StartAnimFrame "Frame to start actor in";

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        CarriedBy, bEMPulsed;

    // Pos:0x00B
    reliable if(int(Role) == int(ROLE_Authority))
        bGrabUsable;

    // Pos:0x016
    reliable if((int(Role) == int(ROLE_Authority)) && bNetInitial)
        bGrabbable;

    // Pos:0x02C
    reliable if(int(Role) == int(ROLE_Authority))
        ClientGrabbed, ClientUnGrabbed;
}

simulated event PostBeginPlay()
{
    local Inventory Inv;

    super.PostBeginPlay();
    // End:0x1D
    if(bBlockKarma)
    {
        SetPhysicsTimeScale(StartAnimSequence, StartAnimFrame, true);
    }
    // End:0x5E
    if(bShowUpOnRadar)
    {
        // End:0x5D
        foreach RotateVectorAroundAxis(class'Inventory', Inv)
        {
            // End:0x5C
            if(Inv.ClassForName('Upgrade_Radar'))
            {
                Inv.SpawnNotify(self);
            }            
        }        
    }
    // End:0x77
    if(int(ThrowPhysics) == int(11))
    {
        ThrowPhysics = Physics;
    }
    // End:0x90
    if(ShouldMimicOwner())
    {
        MimicOwner(InteractiveActor(Owner));
    }
    // End:0xF4
    if((bPassUseToOwner && Owner == none) && Owner.bIsInteractiveActor)
    {
        bUsable = InteractiveActor(Owner).bUsable;
        bUnUsable = InteractiveActor(Owner).bUnUsable;
    }
    GetPointRegion('ForceEMP', ForceEMPTag);
    GetPointRegion('ForceUnEMP', ForceUnEMPTag);
    GetPointRegion('ChallengeGlowOn', ChallengeTurnOnGlowTag);
    GetPointRegion('ChallengeGlowOff', ChallengeTurnOffGlowTag);
    // End:0x161
    if(bTelekineticable && ! bIsProjectile)
    {
        Level.TKObjects[Level.TKObjects.Add(1)] = self;
    }
    return;
}

// Export UInteractiveActor::execSetTelekineticable(FFrame&, void* const)
native simulated function SetTelekineticable(bool bCanTK);

function ShowComponents()
{
    GlobalTrigger(ShowComponentEvent, none);
    return;
}

function HideComponents()
{
    GlobalTrigger(HideComponentEvent, none);
    return;
}

event bool CarrierFireUp()
{
    return;
}

simulated event bool CarrierFireDown()
{
    CarriedBy.DropCarriedActor();
    return true;
    return;
}

event bool CarrierMeleeUp()
{
    return;
}

simulated event bool CarrierMeleeDown()
{
    return true;
    return;
}

function float AbsorbDamage(float Damage, class<DamageType> DamageType)
{
    local float damageAbsorbed;

    // End:0x11
    if(! bAbsorbDamage)
    {
        return Damage;
    }
    damageAbsorbed = FMin(DamageAbsorbPct * Damage, DamageAbsorbAmount);
    DamageAbsorbAmount -= damageAbsorbed;
    // End:0x4A
    if(DamageAbsorbAmount <= float(0))
    {
        bAbsorbDamage = false;
    }
    return FMax(0, Damage - damageAbsorbed);
    return;
}

function bool CanAbsorbDamage()
{
    return bAbsorbDamage;
    return;
}

function bool ShouldDoExitWound(Pawn DamageInstigator)
{
    local GearboxEngineGlobals Globals;

    // End:0x23
    if((PhysicsVolume == none) && PhysicsVolume.bWaterVolume)
    {
        return false;
    }
    Globals = IsPS3InstallNeeded();
    // End:0x61
    if(((Globals == none) && string(ExitWoundInfo) > 0) && Globals.CanDoExitWoundNow(self))
    {
        return true;        
    }
    else
    {
        return false;
    }
    return;
}

// Export UInteractiveActor::execDoExitWound(FFrame&, void* const)
native(857) final function DoExitWound(Pawn DamageInstigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType);

event TakeHitDamage(Pawn HitInstigator, float HitDamage, Vector HitOrigin, Vector HitDirection, name HitMeshBone, class<TraceDamageType> HitDamageType, Vector HitDamageStart)
{
    super(Actor).TakeHitDamage(HitInstigator, HitDamage, HitOrigin, HitDirection, HitMeshBone, HitDamageType, HitDamageStart);
    // End:0x53
    if(ShouldDoExitWound(HitInstigator))
    {
        AddPawn(HitInstigator, HitDamage, HitOrigin, HitDirection, HitDamageType);
    }
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    // End:0x18
    if((MPRoundNotInProgress()) && ! bIsPlayerPawn)
    {
        return;
    }
    super.TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    // End:0x5E
    if(bShielded)
    {
        CreateShield();
        Destroy(ShieldLifetime, false, 'HideShield');
    }
    return;
}

simulated function bool MPRoundNotInProgress()
{
    local Pawn P;

    // End:0x6D
    if(IsMP())
    {
        P = Level.PawnList;
        J0x1E:

        // End:0x6D [Loop If]
        if(P == none)
        {
            // End:0x55
            if(P.bIsPlayerPawn)
            {
                return ! PlayerPawn(P).IsRoundInProgress();
            }
            P = P.NextPawn;
            // [Loop Continue]
            goto J0x1E;
        }
    }
    return false;
    return;
}

event FellOutOfWorld()
{
    // End:0x0E
    if(CarriedBy == none)
    {
        return;
    }
    super(Actor).FellOutOfWorld();
    return;
}

simulated function Destroyed()
{
    local Inventory Inv;

    super.Destroyed();
    // End:0x47
    if(bShowUpOnRadar)
    {
        // End:0x46
        foreach RotateVectorAroundAxis(class'Inventory', Inv)
        {
            // End:0x45
            if(Inv.ClassForName('Upgrade_Radar'))
            {
                Inv.DestroyedNotify(self);
            }            
        }        
    }
    // End:0x67
    if(CarriedBy == none)
    {
        CarriedBy.DropCarriedActor(, true,, true);
    }
    StopTelekinesis();
    GlobalTrigger(Event);
    return;
}

simulated function InteractiveEvent(name Ev)
{
    return;
}

simulated event bool ShouldDrawHUDInfoUsePhrase(Pawn TestPawn)
{
    // End:0x24
    if(ShouldMimicOwner())
    {
        return InteractiveActor(Owner).ShouldDrawHUDInfoUsePhrase(TestPawn);
    }
    // End:0x68
    if(((IsMP()) && TestPawn.bIsPlayerPawn) && PlayerPawn(TestPawn).GameReplicationInfo.bWaitingForPlayers)
    {
        return false;
    }
    return bDrawUsePhrase && (bUsable && CanBeUsedBy(TestPawn)) || bGrabbable && TestPawn.CanGrabActor(self);
    return;
}

function bool ShouldDrawHUDInfoHealth()
{
    return ! bNoDamage;
    return;
}

simulated function bool CanBeUsedBy(Pawn User)
{
    // End:0x2D
    if(bPassUseToOwner && Owner == none)
    {
        return Owner.CanBeUsedBy(User);
    }
    // End:0x48
    if(! bUsable || User != none)
    {
        return false;
    }
    return ((((CheckUserPostureStateEx(User) && CheckUserPhysics(User)) && CheckUserUseAngle(User)) && CheckUserShrunkUse(User, ShrunkUseStyle)) && ! CheckUserSwitchingWeapons(User)) && ! User.IsFrozen();
    return;
}

// Export UInteractiveActor::execCanBeGrabbedBy(FFrame&, void* const)
native simulated event bool CanBeGrabbedBy(Pawn User);

simulated function bool CanBeGrabUsedBy(Pawn User)
{
    return bGrabUsable;
    return;
}

final simulated function bool CheckUserPostureStateEx(Pawn User)
{
    local int i;

    // End:0x17
    if(User.ClassForName('BaseAI'))
    {
        return true;
    }
    // End:0x6B
    if(string(UsePostureSuccess) > 0)
    {
        i = string(UsePostureSuccess) - 1;
        J0x32:

        // End:0x6B [Loop If]
        if(i >= 0)
        {
            // End:0x61
            if(int(User.PostureStateEx) == int(UsePostureSuccess[i]))
            {
                // [Explicit Break]
                goto J0x6B;
            }
            -- i;
            // [Loop Continue]
            goto J0x32;
        }
    }
    J0x6B:

    // End:0x78
    if(i < 0)
    {
        return false;
    }
    i = string(UsePostureFailure) - 1;
    J0x87:

    // End:0xBF [Loop If]
    if(i >= 0)
    {
        // End:0xB5
        if(int(User.PostureStateEx) == int(UsePostureFailure[i]))
        {
            return false;
        }
        -- i;
        // [Loop Continue]
        goto J0x87;
    }
    return true;
    return;
}

final simulated function bool CheckUserPhysics(Pawn User)
{
    local int i;

    // End:0x54
    if(string(UsePhysicsSuccess) > 0)
    {
        i = string(UsePhysicsSuccess) - 1;
        J0x1B:

        // End:0x54 [Loop If]
        if(i >= 0)
        {
            // End:0x4A
            if(int(User.Physics) == int(UsePhysicsSuccess[i]))
            {
                // [Explicit Break]
                goto J0x54;
            }
            -- i;
            // [Loop Continue]
            goto J0x1B;
        }
    }
    J0x54:

    // End:0x61
    if(i < 0)
    {
        return false;
    }
    i = string(UsePhysicsFailure) - 1;
    J0x70:

    // End:0xA8 [Loop If]
    if(i >= 0)
    {
        // End:0x9E
        if(int(User.Physics) == int(UsePhysicsFailure[i]))
        {
            return false;
        }
        -- i;
        // [Loop Continue]
        goto J0x70;
    }
    return true;
    return;
}

final simulated function bool CheckUserUseAngle(Pawn User)
{
    local float Dot;
    local Vector Delta;

    // End:0x17
    if(! User.bIsPlayerPawn)
    {
        return true;
    }
    // End:0x24
    if(! bCheckUseAngle)
    {
        return true;
    }
    Delta = Normal(User.Location - Location);
    Dot = Delta Dot Vector(Rotation);
    // End:0x66
    if(Dot < UseAngleThreshold)
    {
        return false;
    }
    return true;
    return;
}

// Export UInteractiveActor::execCheckUserShrunkUse(FFrame&, void* const)
native final simulated function bool CheckUserShrunkUse(Pawn User, InteractiveActor.EShrunkUseStyle TestShrunkUseStyle);

final simulated function bool CheckUserSwitchingWeapons(Pawn User)
{
    // End:0x5E
    if(User.Weapon == none)
    {
        // End:0x5E
        if((int(User.Weapon.WeaponState) == int(2)) || int(User.Weapon.WeaponState) == int(1))
        {
            return true;
        }
    }
    return false;
    return;
}

simulated event string GetUsePhrase()
{
    // End:0x1F
    if(ShouldMimicOwner())
    {
        return InteractiveActor(Owner).GetUsePhrase();
    }
    return UsePhrase;
    return;
}

simulated event string GetGrabUsePhrase()
{
    // End:0x1F
    if(ShouldMimicOwner())
    {
        return InteractiveActor(Owner).GetGrabUsePhrase();
    }
    // End:0x35
    if(GrabUsePhrase != "")
    {
        return GrabUsePhrase;        
    }
    else
    {
        return "";
    }
    return;
}

simulated event bool CanGrabUseCombine(InteractiveActor Combinee)
{
    // End:0x24
    if(ShouldMimicOwner())
    {
        return InteractiveActor(Owner).CanGrabUseCombine(Combinee);
    }
    return false;
    return;
}

simulated event string GetGrabUseCombinePhrase(InteractiveActor Combinee, string SpecialKey)
{
    // End:0x29
    if(ShouldMimicOwner())
    {
        return InteractiveActor(Owner).GetGrabUseCombinePhrase(Combinee, SpecialKey);
    }
    // End:0x3F
    if(GrabUseCombinePhrase != "")
    {
        return GrabUseCombinePhrase;        
    }
    else
    {
        return "";
    }
    return;
}

// Export UInteractiveActor::execGetTargetedPoint(FFrame&, void* const)
native(858) final function int GetTargetedPoint(Vector fromPt, Vector lookingDir, array<Vector> Points);

function int GetUserLookAtPoint(Pawn User, array<Vector> Points)
{
    local Vector Origin, lookAt;

    Origin = User.SetDestinationActor();
    lookAt = Vector(User.ViewRotation);
    return RemovePawn(Origin, lookAt, Points);
    return;
}

function int GetUserFacingPoint(Pawn User, array<Vector> Points)
{
    local Vector Origin, lookAt;

    Origin = User.Location;
    lookAt = Vector(User.Rotation);
    return RemovePawn(Origin, lookAt, Points);
    return;
}

event Used(Actor Other, Pawn EventInstigator)
{
    super(Actor).Used(Other, EventInstigator);
    // End:0x5E
    if((bPassUseToOwner && Owner == none) && Owner.CanBeUsedBy(EventInstigator))
    {
        Owner.Used(Other, EventInstigator);        
    }
    else
    {
        // End:0x77
        if(bUseTriggered)
        {
            Trigger(Other, EventInstigator);
        }
    }
    return;
}

simulated function AnimCallback_UserPressed()
{
    return;
}

simulated function AnimCallback_UserReleased()
{
    return;
}

simulated function AnimCallback_UserAttached()
{
    return;
}

simulated function AnimCallback_UserDetached()
{
    return;
}

simulated function AnimCallback_UserAnimEnd()
{
    return;
}

simulated function HandleDecoAnimEvent(EventInfo EventParms)
{
    return;
}

simulated function Grabbed(Pawn Grabber)
{
    local KarmaActor KA;

    // End:0x0E
    if(Grabber != none)
    {
        return;
    }
    // End:0x1F
    if(bChallengeGlow)
    {
        bDoOverlayEffect = false;
    }
    WasGrabbed();
    // End:0x8C
    if((bPassUseToOwner && Owner == none) && Owner.bIsInteractiveActor)
    {
        Grabber.CarriedActor = InteractiveActor(Owner);
        Grabber.CarriedActor.Grabbed(Grabber);
        return;
    }
    // End:0xB5
    if(VendOwner == none)
    {
        VendOwner.NotifyPickup(self, Grabber);
        VendOwner = none;
    }
    GetGravity();
    CarriedBy = Grabber;
    CreateDesiredLocationEx(CarriedBy);
    RemoteRole = ROLE_SimulatedProxy;
    bNeverTravel = false;
    SetRotation(0);
    StoreCollision();
    MountToCarrier();
    // End:0x100
    if(IsMP())
    {
        ClientGrabbed(Grabber);
    }
    return;
}

function WasGrabbed()
{
    return;
}

simulated delegate ClientGrabbed(Pawn Grabber)
{
    StoreCollision();
    ForceMountUpdate(, false, false, false, false);
    SetRotation(0);
    return;
}

final simulated function MountToCarrier()
{
    // End:0x0E
    if(CarriedBy != none)
    {
        return;
    }
    ForceMountUpdate(, false, false, false, false);
    // End:0x6C
    if(NameForString(GrabInfo.GrabAnimName, 'LeaveAsIs_'))
    {
        SetScaleModifier();
        // End:0x47
        if(MeshInstance == none)
        {
            MeshInstance.CopyBoneInfo();
        }
        // End:0x6C
        if(NameForString(GrabInfo.GrabAnimName, 'None'))
        {
            DecoPlayAnim(GrabInfo.GrabAnimName);
        }
    }
    // End:0xD0
    if((NameForString(GrabInfo.MountItemOverride, 'None') && CarriedBy.SetScaleModifier() == none) && CarriedBy.MeshInstance.BoneGetRotate(GrabInfo.MountItemOverride))
    {
        MountMeshItem = GrabInfo.MountItemOverride;        
    }
    else
    {
        MountMeshItem = CarriedBy.CarriedActorMountMeshItem;
    }
    MountType = 2;
    MountOrigin = GrabInfo.MountOrigin;
    MountAngles = GrabInfo.MountAngles;
    MoveActor(CarriedBy);
    return;
}

simulated function GrabComplete()
{
    CarriedBy.SetAnimControllerState(GrabInfo.CarrierAnimName);
    return;
}

simulated function bool CanBeThrown()
{
    return bCanBeThrown;
    return;
}

simulated function SetCylinderState(int stateIndex)
{
    return;
}

simulated function UnGrabbed(Pawn Grabber, bool Thrown)
{
    // End:0x11
    if(bChallengeGlow)
    {
        bDoOverlayEffect = true;
    }
    GetGravity();
    CarriedBy = none;
    Instigator = Grabber;
    RemoteRole = default.RemoteRole;
    CreateDesiredLocationEx(none);
    RestoreCollision();
    SetRotation(ThrowPhysics);
    bGrabbable = true;
    // End:0x6F
    if(Thrown)
    {
        KFindPhysicsAction(0);
        TraceFire(1.5, false, 'ResetDynamicInteractionClassification');
        WasThrownByPlayer = true;
    }
    return;
}

simulated delegate ClientUnGrabbed(Pawn Grabber, bool Thrown, Vector Loc, Rotator Rot, float Force, Rotator DropDirection, float HeldTime, Vector AngularVelocity)
{
    // End:0x28
    if(Grabber.IsLocallyControlled() && int(Physics) == int(ThrowPhysics))
    {
        return;
    }
    GetGravity();
    SetDesiredRotation(Loc);
    DisableDesiredRotation_Roll(Rot);
    RestoreCollision();
    // End:0x5A
    if(int(Physics) != int(ThrowPhysics))
    {
        SetRotation(ThrowPhysics);
    }
    bGrabbable = true;
    // End:0x7E
    if(Thrown)
    {
        KFindPhysicsAction(0);
        TraceFire(1.5, false, 'ResetDynamicInteractionClassification');
    }
    // End:0x9C
    if(! Thrown)
    {
        Grabber.ApplyCarriedActorForce_Dropping();        
    }
    else
    {
        Grabber.ApplyCarriedActorForce_Throwing(Force, DropDirection, HeldTime, AngularVelocity);
    }
    return;
}

final simulated function ResetDynamicInteractionClassification()
{
    // End:0x24
    if((int(DynamicInteractionClassification) != int(default.DynamicInteractionClassification)) && ShouldResetDynamicInteractionClassification())
    {
        KFindPhysicsAction(default.DynamicInteractionClassification);
    }
    WasThrownByPlayer = false;
    bGrabbable = default.bGrabbable;
    return;
}

simulated function bool ShouldResetDynamicInteractionClassification()
{
    return true;
    return;
}

function Vector GetImpulseLocation_Throwing()
{
    local Vector ImpulseLocation;

    return ImpulseLocation;
    return;
}

simulated function Rotator GetBaseRotation_Throwing(Pawn Thrower, Rotator TestThrowRotation)
{
    return TestThrowRotation + RVar(ThrowBaseRotation, ThrowBaseRotationVariance, false);
    return;
}

simulated function Rotator GetBaseRotation_Dropping(Pawn Thrower, Rotator TestDropRotation)
{
    return Rot(0, TestDropRotation.Yaw, 0);
    return;
}

function float GetImpulseStrength_Throwing(Pawn Thrower, float BaseStrength, float HeldTime)
{
    local float ThrowStrength, HelperForce;

    HelperForce = 0;
    // End:0x2D
    if(Thrower == none)
    {
        HelperForce = Thrower.CalculateCarriedActorThrowForce();
    }
    ThrowStrength = ThrowForceScale * (FClamp(BaseStrength, 0, Abs(BaseStrength)) + HelperForce);
    return 50000;
    return;
}

simulated function Vector GetThrowVelocity(Pawn Thrower, Vector ThrowDirection, float HeldTime)
{
    return Thrower.Velocity + ((ThrowDirection * 1500) * ThrowForceScale);
    return;
}

simulated function Rotator AdjustDropDirection_Throwing(Pawn Thrower, Rotator DropDirection)
{
    return DropDirection;
    return;
}

simulated function Vector AdjustAngularVelocity_Throwing(Pawn Thrower, Vector CurrentAngularVelocity)
{
    return CurrentAngularVelocity;
    return;
}

static function bool CanBeVended(Pawn PotentialBuyer)
{
    return default.bGrabbable;
    return;
}

function GrabUsed(Pawn Grabber)
{
    return;
}

function GrabUnUsed(Pawn Grabber)
{
    return;
}

function float GetPlayerMotionScale(PlayerPawn P)
{
    // End:0x19
    if(P.bOnSteroids)
    {
        return 1;
    }
    return 1 - FClamp((Mass - 100) / 100, 0, 1);
    return;
}

function StartTelekinesis(Pawn TKOwner)
{
    local PhysicsAction_ConstAccel MyPA;

    // End:0x0B
    if(UnderTelekineticControl)
    {
        return;
    }
    UnderTelekineticControl = true;
    BeingTelekineticThrown = false;
    Instigator = TKOwner;
    PostTKPhysics = Physics;
    Velocity = Vect(0, 0, 0);
    Acceleration = Velocity;
    // End:0x69
    if(int(Physics) != int(18))
    {
        SetRotation(2);        
    }
    else
    {
        KGetCollidingActors();
        MyPA = PhysicsAction_ConstAccel(ProcessSpawnActorPrefab(class'PhysicsAction_ConstAccel', true));
        MyPA.Setup(true, true, Vect(0, 0, 0), TelekinesisAngularVel);
    }
    PerformDamageCategoryEffectEx('ResetDynamicInteractionClassification');
    SpawnMotionPrefab(TKOwner);
    LifeSpan = 0;
    bGrabbable = false;
    CreateTelekinesisFX();
    Instigator.NotifyTeleKinesisStarted(self);
    return;
}

function TelekineticThrow(Vector Vel, bool bConstrain)
{
    local PhysicsAction_ConstVel MyPA;

    // End:0x0D
    if(! UnderTelekineticControl)
    {
        return;
    }
    LifeSpan = default.LifeSpan;
    Velocity = Vect(0, 0, 0);
    Acceleration = Velocity;
    SpawnMountPrefabActor(class'PhysicsAction_ConstAccel');
    SetRotation(PostTKPhysics);
    // End:0xBB
    if(int(Physics) == int(18))
    {
        KGetCollidingActors();
        // End:0xAA
        if(bConstrain)
        {
            BeingTelekineticThrown = true;
            KImpactThreshold = 0;
            MyPA = PhysicsAction_ConstVel(ProcessSpawnActorPrefab(class'PhysicsAction_ConstVel', true));
            MyPA.Setup(true, true, Vel, TelekinesisAngularVel);            
        }
        else
        {
            KPushGeneratedSimpleState(Vel);
            StopTelekinesis();
        }        
    }
    else
    {
        // End:0xCE
        if(int(Physics) != int(6))
        {
            SetRotation(2);
        }
        Velocity = Vel;
        StopTelekinesis();
    }
    return;
}

function StopTelekinesis()
{
    local Pawn MyTKOwner;

    // End:0x0D
    if(! UnderTelekineticControl)
    {
        return;
    }
    SpawnMountPrefabActor(class'PhysicsAction_ConstAccel');
    SpawnMountPrefabActor(class'PhysicsAction_ConstVel');
    ApplyMotionPrefab(Instigator);
    DestroyTelekinesisFX();
    UnderTelekineticControl = false;
    BeingTelekineticThrown = false;
    KImpactThreshold = default.KImpactThreshold;
    MyTKOwner = Instigator;
    Instigator = none;
    // End:0x75
    if(MyTKOwner == none)
    {
        MyTKOwner.NotifyTeleKinesisStopped(self);
    }
    TraceFire(1.5, false, 'ResetDynamicInteractionClassification');
    return;
}

function CreateTelekinesisFX()
{
    // End:0x0D
    if(! UnderTelekineticControl)
    {
        return;
    }
    // End:0x67
    if(TelekinesisChargeClassName != "")
    {
        TelekinesisCharge = EmptyTouchClasses(class<SoftParticleSystem>(SaveConfigFile(TelekinesisChargeClassName, class'Class')), self);
        TelekinesisCharge.MountType = 0;
        TelekinesisCharge.MoveActor(self, true, true);
        TelekinesisCharge.SetRotation(9);
    }
    // End:0xAD
    if(TelekinesisBeamSystemClassName != "")
    {
        TelekinesisBeamSystem = BeamSystem(FindStaticActor(class<BeamSystem>(SaveConfigFile(TelekinesisBeamSystemClassName, class'Class'))));
        TelekinesisBeamSystem.AddSegmentActor(Instigator, self);
    }
    return;
}

function DestroyTelekinesisFX()
{
    // End:0x0D
    if(! UnderTelekineticControl)
    {
        return;
    }
    // End:0x26
    if(TelekinesisCharge == none)
    {
        TelekinesisCharge.RemoveTouchClass();
    }
    // End:0x3F
    if(TelekinesisBeamSystem == none)
    {
        TelekinesisBeamSystem.RemoveTouchClass();
    }
    return;
}

function ReserveForPickup(bool ReserveMe)
{
    // End:0x13
    if(ReservedForPickup == ReserveMe)
    {
        return;
    }
    // End:0x39
    if(ReserveMe)
    {
        SetRotation(0);
        SavedbGrabbable = bGrabbable;
        bGrabbable = false;        
    }
    else
    {
        SetRotation(18);
        bGrabbable = SavedbGrabbable;
    }
    ReservedForPickup = ReserveMe;
    return;
}

event PickedUp(Pawn Carrier)
{
    MountType = 2;
    MountMeshItem = Carrier.PickupMountBone;
    MoveActor(Carrier);
    SetRotation(0);
    Instigator = Carrier;
    SpawnMotionPrefab(Carrier);
    return;
}

function Thrown(Vector Vel, Pawn Thrower)
{
    GetGravity();
    ReserveForPickup(false);
    KGetCollidingActors();
    MountType = default.MountType;
    MountMeshItem = default.MountMeshItem;
    Velocity = Vect(0, 0, 0);
    Acceleration = Vect(0, 0, 0);
    BeingThrown = true;
    Instigator = Thrower;
    KImpactThreshold = 0;
    KLinearDamping = 0;
    KPushGeneratedSimpleState(Vel);
    SetMinDamageVelocityThrown();
    KFindPhysicsAction(0);
    TraceFire(1.5, false, 'ResetDynamicInteractionClassification');
    return;
}

function ThrowLanded()
{
    ApplyMotionPrefab(Instigator);
    BeingThrown = false;
    KImpactThreshold = default.KImpactThreshold;
    KLinearDamping = default.KLinearDamping;
    return;
}

event KImpact(name SelfBoneName, KarmaActor Other, name OtherBoneName, Vector Position, Vector ImpactVelocity, Vector ImpactNormal)
{
    // End:0x2F
    if(BeingThrown && (Instigator != none) || Other == Instigator)
    {
        ThrowLanded();
    }
    // End:0x69
    if((UnderTelekineticControl && BeingTelekineticThrown) && (Instigator != none) || Other == Instigator)
    {
        StopTelekinesis();
    }
    super(KarmaActor).KImpact(SelfBoneName, Other, OtherBoneName, Position, ImpactVelocity, ImpactNormal);
    return;
}

simulated function InteractUser(Pawn User)
{
    return;
}

function TriggerFunc_ForceEMP()
{
    HitByEMP(ForcedEMPDisableTime);
    return;
}

function TriggerFunc_ChallengeGlowOn()
{
    bChallengeGlow = true;
    bDoOverlayEffect = true;
    return;
}

function TriggerFunc_ChallengeGlowOff()
{
    bChallengeGlow = false;
    bDoOverlayEffect = false;
    return;
}

function TriggerFunc_ForceUnEMP()
{
    PerformDamageCategoryEffectEx('EMPDone');
    EMPDone();
    return;
}

function HitByEMP(optional float Duration, optional Pawn Instigator)
{
    local float RelevantDuration;

    // End:0x18
    if(! bMultiEMPulse && bEMPulsed)
    {
        return;
    }
    RelevantDuration = Duration;
    // End:0x3D
    if(RelevantDuration == 0)
    {
        RelevantDuration = EMPDisableTime;
    }
    // End:0x4E
    if(RelevantDuration < 0)
    {
        return;
    }
    bEMPulsed = true;
    LastEMPTime = Level.GameTimeSeconds;
    PerformDamageCategoryEffectEx('EMPDone');
    // End:0x90
    if(RelevantDuration > 0)
    {
        TraceFire(RelevantDuration, false, 'EMPDone');
    }
    return;
}

function EMPDone()
{
    bEMPulsed = false;
    return;
}

simulated function HideShield()
{
    // End:0x3A
    if(ShieldActor == none)
    {
        ShieldActor.GetZoneLastRenderTime(true);
        ShieldActor.StoreCollision();
        ShieldActor.ForceMountUpdate(false, false, false);
    }
    return;
}

simulated function UnHideShield()
{
    // End:0x2A
    if(ShieldActor == none)
    {
        ShieldActor.GetZoneLastRenderTime(false);
        ShieldActor.RestoreCollision();
    }
    return;
}

simulated function DestroyShield()
{
    // End:0x20
    if(ShieldActor == none)
    {
        ShieldActor.RemoveTouchClass();
        ShieldActor = none;
    }
    return;
}

simulated event CreateShield()
{
    local int SkinsToReplace, i;

    // End:0x0B
    if(bEMPulsed)
    {
        return;
    }
    // End:0xDB
    if((ShieldActor != none) && ShieldClass == none)
    {
        ShieldActor = EmptyTouchClasses(ShieldClass, self);
        // End:0xD8
        if(ShieldActor == none)
        {
            ShieldActor.IsMountedTo(CollisionRadius * ShieldScaleFactor, CollisionHeight * ShieldScaleFactor);
            ShieldActor.RemoveActorColor(ShieldScaleFactor);
            ShieldActor.GetOverlayEffectAlpha(SetCallbackTimer());
            SkinsToReplace = EvalTimeRamp();
            i = SkinsToReplace - 1;
            J0x9E:

            // End:0xCA [Loop If]
            if(i >= 0)
            {
                ShieldActor.VisibleActors(i, ShieldTex);
                -- i;
                // [Loop Continue]
                goto J0x9E;
            }
            ShieldActor.MoveActor(self);
        }        
    }
    else
    {
        UnHideShield();
    }
    return;
}

function ClearNukingActor()
{
    return;
}

function bool CanMicrowave()
{
    return MicrowaveInfo.TimeToMicrowave > 0;
    return;
}

function PlacedInMicrowave(InteractiveActor MicrowaveActor)
{
    return;
}

function float StartMicrowaving(InteractiveActor MicrowaveActor)
{
    // End:0x1A
    if(MicrowaveInfo.TimeToMicrowave <= 0)
    {
        return 0;
    }
    MicrowaveInfo.MicrowaveActor = MicrowaveActor;
    MicrowaveInfo.LastMicrowaveTime = Level.GameTimeSeconds;
    Destroy(MicrowaveInfo.TimeToMicrowave, false, 'CompleteMicrowaving');
    return MicrowaveInfo.TimeToMicrowave;
    return;
}

function StopMicrowaving()
{
    // End:0x16
    if(MicrowaveInfo.TimeToMicrowave <= 0)
    {
        return;
    }
    Spawn('CompleteMicrowaving');
    MicrowaveInfo.MicrowaveActor = none;
    MicrowaveInfo.TimeToMicrowave -= (Level.GameTimeSeconds - MicrowaveInfo.LastMicrowaveTime);
    // End:0x6B
    if(MicrowaveInfo.TimeToMicrowave <= 0)
    {
        CompleteMicrowaving();
    }
    return;
}

function InterruptMicrowaving()
{
    Spawn('CompleteMicrowaving');
    MicrowaveInfo.MicrowaveActor = none;
    MicrowaveInfo.TimeToMicrowave = 0;
    return;
}

function CompleteMicrowaving()
{
    Spawn('CompleteMicrowaving');
    MicrowaveInfo.MicrowaveActor = none;
    MicrowaveInfo.TimeToMicrowave = 0;
    return;
}

final event MimicOwner(InteractiveActor ThisOwner)
{
    // End:0x9D
    if(ThisOwner == none)
    {
        CreateDesiredLocationEx(ThisOwner);
        bDrawHUDInfo = ThisOwner.bDrawHUDInfo;
        bNoUseKeyInfo = ThisOwner.bNoUseKeyInfo;
        bDrawUsePhrase = ThisOwner.bDrawUsePhrase;
        bForceUsePhrase = ThisOwner.bForceUsePhrase;
        bOccludeSounds = ThisOwner.bOccludeSounds;
        TraceFalseMask = -1;
        TraceTrueMask = -1;
    }
    return;
}

final event UnMimicOwner()
{
    CreateDesiredLocationEx(none);
    bDrawHUDInfo = default.bDrawHUDInfo;
    bNoUseKeyInfo = default.bNoUseKeyInfo;
    bDrawUsePhrase = default.bDrawUsePhrase;
    bForceUsePhrase = default.bForceUsePhrase;
    bOccludeSounds = default.bOccludeSounds;
    return;
}

function bool ShouldMimicOwner()
{
    return (bMimicOwner && Owner == none) && Owner.bIsInteractiveActor;
    return;
}

event EnumerateRawAnimationSequences(out array<SAnimationEnumeration> References)
{
    super.EnumerateRawAnimationSequences(References);
    // End:0x30
    if(NameForString(StartAnimSequence, 'None'))
    {
        AddAnimationEnumeration(References, StartAnimSequence, Mesh);
    }
    return;
}

simulated function bool UseThrowingFix()
{
    return true;
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(Actor).RegisterPrecacheComponents(PrecacheIndex);
    // End:0x42
    if(bGrabbable)
    {
        PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', 'Toss');
        PrecacheIndex.InitAnimationControllerEx(class'VoicePack_Duke', 'Grab');
    }
    return;
}

defaultproperties
{
    ProximityDistance=100
    GlowDistance=360
    bDrawUsePhrase=true
    bUnUseOnLookChange=true
    ShrunkGrabStyle=2
    ThrowPhysics=11
    UsePhrase="<?int?Engine.InteractiveActor.UsePhrase?>"
    UseAngleThreshold=-1
    EndViewingAngleMinDiff=0.1
    GrabInfo=(bCanDuckWhileHeld=true,MountItemOverride=mount_handright,MountOrigin=(X=0,Y=0,Z=0),MountAngles=(Pitch=0,Yaw=0,Roll=0),GrabAnimName=None,CarrierAnimName=CarryBarbell100,CarrierMountPose=CarryPoseBarbell100,GrabSoundName=None,ThrowSoundName=None,GrabSoundInfo=(bAllowRepeats=false,bPlayAsAmbient=false,MixerGroupOverride=None,SimpleSingleSound=none,Sounds=none,SlotPriority=0,VolumePrefab=0,Slots=none,Volume=0,VolumeVariance=0,InnerRadius=0,InnerRadiusVariance=0,Radius=0,RadiusVariance=0,Pitch=0,PitchVariance=0,Flags=(bNoOverride=false,bMenuSound=false,bNoFilter=false,bNoOcclude=false,bNoAIHear=false,bNoScale=false,bSpoken=false,bPlayThroughListener=false,bNoDoppler=false,bDialogSound=false,bNoReverb=false,bEnableVis=false,bSkipFlangePrevention=false,bSkipSoundRadiusTest=false,bIgnoreTimeDilation=false),SoundLocationOverride=(bMakeRelativeForLocalPlayer=false,bMakeAbsoluteForActor=false,OverrideType=0,Location3D=(X=0,Y=0,Z=0),Velocity3D=(X=0,Y=0,Z=0)),Offset=0,Delay=0,SlotIndex=0,ForcedIndex=0,SoundFadeInfo=(FadeInDuration=0,FadeOutStartTime=0,FadeOutDuration=0,FadeInEndCallback=None,FadeOutEndCallback=None),SoundEndCallback=None,PlayedSounds=none,Filters=none),ThrowSoundInfo=(bAllowRepeats=false,bPlayAsAmbient=false,MixerGroupOverride=None,SimpleSingleSound=none,Sounds=none,SlotPriority=0,VolumePrefab=0,Slots=none,Volume=0,VolumeVariance=0,InnerRadius=0,InnerRadiusVariance=0,Radius=0,RadiusVariance=0,Pitch=0,PitchVariance=0,Flags=(bNoOverride=false,bMenuSound=false,bNoFilter=false,bNoOcclude=false,bNoAIHear=false,bNoScale=false,bSpoken=false,bPlayThroughListener=false,bNoDoppler=false,bDialogSound=false,bNoReverb=false,bEnableVis=false,bSkipFlangePrevention=false,bSkipSoundRadiusTest=false,bIgnoreTimeDilation=false),SoundLocationOverride=(bMakeRelativeForLocalPlayer=false,bMakeAbsoluteForActor=false,OverrideType=0,Location3D=(X=0,Y=0,Z=0),Velocity3D=(X=0,Y=0,Z=0)),Offset=0,Delay=0,SlotIndex=0,ForcedIndex=0,SoundFadeInfo=(FadeInDuration=0,FadeOutStartTime=0,FadeOutDuration=0,FadeInEndCallback=None,FadeOutEndCallback=None),SoundEndCallback=None,PlayedSounds=none,Filters=none))
    ThrowBone=Root
    ThrowForceScale=1
    ThrowForceScaleAI=1
    TelekinesisChargeClassName="dnParticles.dnOctabrainFX_ChargeDecorationA"
    TelekinesisBeamSystemClassName="dnParticles.dnOctabrainBeamFX"
    TelekinesisAngularVel=(X=5,Y=5,Z=5)
    TelekinesisThrowVel=1400
    VendInfo=VendItemInfo'InteractiveActor.VI_InteractiveActor_Default'
    ShieldLifetime=1
    ShieldScaleFactor=1.05
    EMPDisableTime=-1
    bIsInteractiveActor=true
}