/*******************************************************************************
 * Dispatcher generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Dispatcher extends Triggers
    native
    collapsecategories
    notplaceable
    hidecategories(Filter,Interactivity,Karma,Lighting,Networking,Sound,Collision,Interactivity,Karma,Lighting,Mounting,movement,Sound,Filter,Networking,Interpolation,Material);

cpptext
{
// Stripped
}

var() noexport deprecated array<name> OutEvents "Events that get called.";
var() noexport array<float> OutDelays "Time to delay before calling the corresponding event (is relative to the prior event). A negative value will just print the matching OutEvent as a message for simple debugging.";
var() noexport name ResetTag "Triggering this tag will reset this dispatcher and cease dispatching. Does nothing if set to None";
var() noexport bool bLoop "Loop the dispatcher automatically, otherwise it waits to be triggered to go again.";
var() noexport bool bInterruptable "Dispatcher can be restarted by retriggering. Otherwise it won't trigger until it has gone through all the events and delays.";
var() noexport bool bTriggerOnlyOnce "Only Dispatch once and then go dormant.";
var int Index;
var bool bDispatching;
var bool bPreparing;
var bool bTriggeredOnce;
var Object.ETickStyle DefaultTickStyle;
var bool bPauseDispatch;
var() noexport name PauseDispatchingTag "Will stop the dispatching of events";
var() noexport name UnPauseDispatchingTag "Will restart the dispatching of events";

event PostVerifySelf()
{
    super(Actor).PostVerifySelf();
    DefaultTickStyle = TickStyle;
    TickStyle = 0;
    GetPointRegion('EndDispatching', ResetTag);
    TriggerFunc_EndDispatching();
    GetPointRegion('PauseDispatching', PauseDispatchingTag);
    GetPointRegion('UnPauseDispatching', UnPauseDispatchingTag);
    return;
}

function bool VerifySelf()
{
    local int i;
    local bool bValidLoop;

    // End:0x2B
    if(string(OutEvents) > string(OutDelays))
    {
        OutDelays.Insert(string(OutDelays), string(OutEvents) - string(OutDelays));
    }
    // End:0x56
    if(string(OutDelays) > string(OutEvents))
    {
        OutDelays.Remove(string(OutEvents), string(OutDelays) - string(OutEvents));
    }
    i = string(OutEvents) - 1;
    J0x65:

    // End:0xD6 [Loop If]
    if(i >= 0)
    {
        // End:0xCC
        if(OutEvents[i] != 'None')
        {
            // End:0xB4
            if(i < (string(OutEvents) - 1))
            {
                OutDelays[i + 1] += OutDelays[i];
            }
            OutEvents.Remove(i, 1);
            OutDelays.Remove(i, 1);
        }
        -- i;
        // [Loop Continue]
        goto J0x65;
    }
    // End:0x126
    if(string(OutEvents) == 0)
    {
        InvalidAlert(("Warning: " $ string(self)) $ " had 0 OutEvents and will be destroyed.");
        return false;
    }
    i = 0;
    J0x12D:

    // End:0x167 [Loop If]
    if(i < string(OutDelays))
    {
        // End:0x15D
        if(OutDelays[i] != 0)
        {
            bValidLoop = true;
            // [Explicit Break]
            goto J0x167;
        }
        ++ i;
        // [Loop Continue]
        goto J0x12D;
    }
    J0x167:

    // End:0x1ED
    if(bLoop && ! bValidLoop)
    {
        BroadcastLog(("Warning: " $ string(self)) $ " wants to loop, but has no delays, which would cause a crash. Disabling loop.");
        bLoop = false;
    }
    return super(Actor).VerifySelf();
    return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
    super(Actor).Trigger(Other, EventInstigator);
    // End:0x1B
    if(bTriggeredOnce)
    {
        return;
    }
    // End:0x2C
    if(bTriggerOnlyOnce)
    {
        bTriggeredOnce = true;
    }
    Instigator = EventInstigator;
    // End:0x53
    if(bInterruptable || ! bDispatching)
    {
        StartDispatching();
    }
    return;
}

final function StartDispatching()
{
    local int i;
    local float CurrentDelay;

    // End:0x0B
    if(bPreparing)
    {
        return;
    }
    bPreparing = true;
    TriggerFunc_EndDispatching();
    Index = 0;
    bDispatching = true;
    TickStyle = DefaultTickStyle;
    i = 0;
    J0x3A:

    // End:0x78 [Loop If]
    if(i < string(OutDelays))
    {
        CurrentDelay += Abs(OutDelays[i]);
        Destroy(CurrentDelay, false, 'Dispatch', true, true);
        ++ i;
        // [Loop Continue]
        goto J0x3A;
    }
    bPreparing = false;
    return;
}

final function TriggerFunc_EndDispatching()
{
    bDispatching = false;
    TickStyle = 0;
    Spawn('Dispatch');
    return;
}

final function TriggerFunc_PauseDispatching()
{
    bPauseDispatch = true;
    return;
}

final function TriggerFunc_UnPauseDispatching()
{
    bPauseDispatch = false;
    return;
}

final function Dispatch()
{
    local bool bContinue;
    local int CurrentIndex;

    // End:0x0B
    if(bPauseDispatch)
    {
        return;
    }
    // End:0x31
    if((Index == (string(OutDelays) - 1)) && ! bLoop)
    {
        TriggerFunc_EndDispatching();
    }
    bContinue = bDispatching;
    CurrentIndex = Index;
    // End:0x78
    if(OutDelays[Index] >= 0)
    {
        GlobalTrigger(OutEvents[Index], Instigator, self);        
    }
    else
    {
        BroadcastLog(((((((string(self) $ ": Tag=") $ string(Tag)) $ " called ") $ string(OutEvents[Index])) $ " after ") $ string(Abs(OutDelays[Index]))) $ " seconds.");
    }
    // End:0x136
    if((bContinue && bDispatching) && CurrentIndex == Index)
    {
        ++ Index;
        // End:0x136
        if(bLoop && Index == string(OutDelays))
        {
            TriggerFunc_EndDispatching();
            Destroy(1E-05, false, 'StartDispatching');
        }
    }
    return;
}

defaultproperties
{
    TickStyle=2
    Texture=Texture'S_Dispatcher'
}