/*******************************************************************************
 * CorpseBase generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CorpseBase extends InteractiveActor
    abstract
    native
    collapsecategories
    notplaceable
    dependson(BonePartMapper);

cpptext
{
// Stripped
}

struct SCorpseConstraints
{
    var() name BoneName;
    var() KarmaActor Other;
    var() name OtherBoneName;
    var() class<KConstraint> ConstraintClass;
    var KConstraint Constraint;
};

struct SDestroyedBone
{
    var name BoneName;
};

struct SSortBone
{
    var name BoneName;
    var float DistSq;
};

var(Corpse) noexport float RemoveCheckTime "How often this corpse checks to see if it should be removed.  0 or less means never.";
var(Corpse) noexport float BoneDamageThreshold "Amount of damage a bone must receive in one frame to be destroyed.";
var(Corpse) noexport float FrozenBoneDamageThreshold "Amount of damage a bone must receive in one frame to be destroyed, when frozen.";
var(Corpse) noexport array<SCorpseConstraints> BoneConstraints "List of bones to constrain on this actor.";
var(Corpse) noexport float GibThreshold "Minimum explosive damage required to gib.";
var(Corpse) float FrozenGibThreshold;
var(Corpse) noexport float FrozenSolidThreshold "Amount of `frozeness' for a corpse to be considered solid enough, ie to gib";
var(Corpse) noexport float ThawJointsThreshold "Amount of `frozeness' below which limbs will start thawing and ragdoll again";
var(Corpse) float GibMaxDistance;
var(Corpse) noexport float LimbEgoBoost "How much ego to give players for removing limbs";
var(Corpse) noexport float GibsEgoBoost "How much ego to give players for causing gibbage";
var(Corpse) int MaxGibsPerFrame;
var(Corpse) int MaxLimbsPerFrame;
var int NumberOfLimbsGibbed;
var bool bCanDie;
var(Corpse) noexport array<name> StartupDestroyedBones "List of bones to destroy on startup.";
var Vector FullyGibbedLinearVelocity;
var Vector FullyGibbedAngularVelocityVariance;
var Actor SavedDamageInstigator;
var Vector SavedDamageOrigin;
var float SavedDamageRadius;
var float SavedDamageFalloffStart;
var class<DamageType> SavedDamageType;
var float SavedRelativeScale;
var bool bDelayedRagdoll;
var bool bDamageCouldGib;
var bool bFullyGibbed;
var bool bShrunkCorpse;
var array<Actor> LimbCaps;
var array<SDestroyedBone> DestroyedBones;
var bool bIsHuman;
var array<Corpse_Gib> SpawnedLimbs;
var class<HUDEffects> BloodScreenSplatterClass;
var bool bExplodeOut;
var float FrozenPercent;
var float TargetFrozenPercent;
var float DefaultFriction;
var float FrozenFriction;
var float FreezeDuration;
var float ThawDuration;
var Pawn OwnerPawn;
var bool bUsingFrozenOverrides;
var array<SPhysicsSoundOverride> FrozenPhysicsSoundOverrides;
var MaterialEx ClearMaterial;
var float MaxGibScaleFactor;
var float MinDist;
var float MaxDist;
var int TotalMaxGibsPerFrame;
var int LowGoreTotalMaxGibsPerFrame;
var int NumGibsInFrame;
var private transient bool DeferredGibbingInProgress;
var float ImpulseMag;
var bool ForceUp;
var dnFriendFX_Spawners Spawner;
var bool bRandomGibDir;
var float MPLimbLinearVelocity;
var Color MPShirtColor;
var float LastSpawnedLimbTime;

function PostLoadMap()
{
    local name DestroyableBone;
    local int i;

    super(Actor).PostLoadMap();
    // End:0x3C
    if(FClamp((1 - DrawScale) / 0.75, 0, 1) >= 0.5)
    {
        bShrunkCorpse = true;
        KFindPhysicsAction(1);
    }
    i = string(StartupDestroyedBones) - 1;
    J0x4B:

    // End:0xAB [Loop If]
    if(i >= 0)
    {
        DestroyableBone = UpdateScaleModifier(Mesh, StartupDestroyedBones[i]);
        // End:0xA1
        if(NameForString(DestroyableBone, 'None') && ! SetUpdateRate(DestroyableBone))
        {
            InitFriendData(StartupDestroyedBones[i],,, true, true, true);
        }
        -- i;
        // [Loop Continue]
        goto J0x4B;
    }
    DefaultFriction = KFriction;
    OverlayBumpShaderInfo.UVScale.Z = 0;
    return;
}

simulated event PreGameInit()
{
    local int i;

    super(Actor).PreGameInit();
    i = 0;
    J0x0D:

    // End:0x3A [Loop If]
    if(i < string(DestroyedBones))
    {
        GetRenderBoundingBox(DestroyedBones[i].BoneName);
        ++ i;
        // [Loop Continue]
        goto J0x0D;
    }
    return;
}

simulated event Tick(float DeltaTime)
{
    local float StartingFrozenPercent;

    default.NumGibsInFrame = 0;
    super(Actor).Tick(DeltaTime);
    // End:0x23
    if(FrozenPercent == TargetFrozenPercent)
    {
        return;
    }
    StartingFrozenPercent = FrozenPercent;
    // End:0x98
    if(TargetFrozenPercent > FrozenPercent)
    {
        // End:0x5F
        if(FreezeDuration > 0)
        {
            FrozenPercent += (DeltaTime / FreezeDuration);
        }
        // End:0x95
        if((FreezeDuration <= 0) || FrozenPercent > TargetFrozenPercent)
        {
            FrozenPercent = TargetFrozenPercent;
            TargetFrozenPercent = 0;
        }        
    }
    else
    {
        // End:0xBA
        if(ThawDuration > 0)
        {
            FrozenPercent -= (DeltaTime / ThawDuration);
        }
        // End:0xE5
        if((ThawDuration <= 0) || FrozenPercent < TargetFrozenPercent)
        {
            FrozenPercent = TargetFrozenPercent;
        }
    }
    // End:0x107
    if(FrozenPercent <= 0)
    {
        FrozenPercent = 0;
        bTickOnlyWhenPhysicsAwake = true;
    }
    OverlayBumpShaderInfo.UVScale.Z = FrozenPercent;
    // End:0x13F
    if((FrozenPercent <= ThawJointsThreshold) && StartingFrozenPercent > ThawJointsThreshold)
    {
        KGetCollidingActors();
    }
    UpdateFrictionAndJoints();
    return;
}

event PhysicsChange(optional Object.EPhysics PreviousPhysics)
{
    super(KarmaActor).PhysicsChange(PreviousPhysics);
    // End:0x1F
    if(int(Physics) == int(18))
    {
        UpdateFrictionAndJoints();
    }
    return;
}

// Export UCorpseBase::execUpdateFrictionAndJoints(FFrame&, void* const)
native(1026) function UpdateFrictionAndJoints();

function ApplyImpulse(Vector Dir, Vector Loc, optional name BoneName)
{
    local int i, j;
    local float ScratchBoneWeight, TotalWeight;
    local name ScratchBoneName;
    local array<name> ImpulseBones;
    local array<float> ImpulseWeights;

    // End:0x0B
    if(bDelayedRagdoll)
    {
        return;
    }
    i = SetScaleModifier().MakeReferencePose() - 1;
    J0x1F:

    // End:0xEE [Loop If]
    if(i >= 0)
    {
        ScratchBoneName = SetScaleModifier().BoneGetTranslate(i);
        // End:0x53
        if(ScratchBoneName != BoneName)
        {
            // [Explicit Continue]
            goto J0xE4;
        }
        // End:0x6B
        if(! SetScaleModifier().BoneSetRotate(ScratchBoneName))
        {
            // [Explicit Continue]
            goto J0xE4;
        }
        ScratchBoneWeight = FMax(0, 1 - (VSize(SetScaleModifier().CreateAnimGroup(ScratchBoneName, true) - Loc) / 48));
        // End:0xB2
        if(ScratchBoneWeight <= 0)
        {
            // [Explicit Continue]
            goto J0xE4;
        }
        ImpulseBones[ImpulseBones.Add(1)] = ScratchBoneName;
        ImpulseWeights[ImpulseWeights.Add(1)] = ScratchBoneWeight;
        TotalWeight += ScratchBoneWeight;
        J0xE4:

        -- i;
        // [Loop Continue]
        goto J0x1F;
    }
    // End:0x111
    if(string(ImpulseBones) == 0)
    {
        super(KarmaActor).ApplyImpulse(Dir, Loc, BoneName);
        return;
    }
    ImpulseBones[ImpulseBones.Add(1)] = BoneName;
    ImpulseWeights[ImpulseWeights.Add(1)] = TotalWeight * 0.5;
    TotalWeight *= 1.5;
    i = string(ImpulseBones) - 1;
    J0x159:

    // End:0x19D [Loop If]
    if(i >= 0)
    {
        super(KarmaActor).ApplyImpulse((ImpulseWeights[i] * Dir) / TotalWeight, Loc, ImpulseBones[i]);
        -- i;
        // [Loop Continue]
        goto J0x159;
    }
    return;
}

simulated function float GetDamageMomentumPostScale(class<DamageType> DamageType)
{
    // End:0x19
    if(IsA(DamageType, class'ExplosionDamage'))
    {
        return 0.5;        
    }
    else
    {
        return 1;
    }
    return;
}

// Export UCorpseBase::execIsFrozen(FFrame&, void* const)
native(1027) event bool IsFrozen();

function Init(InteractiveActor aOther)
{
    InitConstraints();
    StartCheckRemoval();
    return;
}

function InitConstraints()
{
    local int i;

    // End:0x10
    if(int(Physics) != int(18))
    {
        return;
    }
    i = 0;
    J0x17:

    // End:0x176 [Loop If]
    if(i < string(BoneConstraints))
    {
        // End:0x50
        if(BoneConstraints[i].Other != self)
        {
            BoneConstraints[i].Other = none;
        }
        // End:0x7D
        if(BoneConstraints[i].ConstraintClass != none)
        {
            BoneConstraints[i].ConstraintClass = class'KFixed';
        }
        BoneConstraints[i].Constraint = KarmaSetupConstraint(BoneConstraints[i].ConstraintClass, self, BoneConstraints[i].BoneName, BoneConstraints[i].Other, BoneConstraints[i].OtherBoneName);
        // End:0x16C
        if(BoneConstraints[i].Constraint == none)
        {
            BoneConstraints[i].Constraint.MountType = 2;
            BoneConstraints[i].Constraint.MountMeshItem = BoneConstraints[i].BoneName;
            BoneConstraints[i].Constraint.MoveActor(self, false, false, false, false, false);
            BoneConstraints[i].Constraint.SetRotation(18);
        }
        ++ i;
        // [Loop Continue]
        goto J0x17;
    }
    return;
}

function SetCorpseName(InteractiveActor aOther)
{
    return;
}

function bool CreateAnimatedCorpse(InteractiveActor aOther)
{
    local Actor A;
    local bool bDestroyOnDismount;
    local int i;
    local Vector NewPrePivot, NewPostPivot;

    OwnerPawn = Pawn(aOther);
    SetDesiredRotation(aOther.Location);
    DisableDesiredRotation_Roll(aOther.Rotation);
    // End:0x7A
    if(! IsMP())
    {
        self.GetOverlayEffectAlpha(aOther.Mesh);
        self.SetScaleModifier();
        MeshInstance.AnimUpdateTime(aOther.SetScaleModifier());
    }
    RemoveActorColor(aOther.DrawScale);
    SetActorColor(aOther.DrawScale3D);
    Texture = aOther.Texture;
    NewPrePivot = aOther.PrePivot;
    NewPostPivot = aOther.PostPivot;
    // End:0x14F
    if(aOther.bLowerByCollision)
    {
        // End:0x134
        if(aOther.bLowerAsPrePivot)
        {
            NewPrePivot.Z += (aOther.CollisionHeight / (DrawScale * DrawScale3D.Z));            
        }
        else
        {
            NewPostPivot.Z -= aOther.CollisionHeight;
        }
    }
    EndCallbackTimer(NewPrePivot);
    SetCallbackTimer_Always(NewPostPivot);
    bLowerByCollision = false;
    bLowerAsPrePivot = false;
    IsMountedTo(aOther.CollisionRadius, aOther.CollisionHeight);
    DisableDesiredLocation(aOther.Mass);
    Density = aOther.Density;
    i = 0;
    J0x1BE:

    // End:0x1FF [Loop If]
    if(i < string(aOther.Skins))
    {
        VisibleActors(i, aOther.Skins[i]);
        ++ i;
        // [Loop Continue]
        goto J0x1BE;
    }
    ActorColorList.Empty();
    i = 0;
    J0x20C:

    // End:0x248 [Loop If]
    if(i < string(aOther.ActorColorList))
    {
        FinishSlottedSound(aOther.ActorColorList[i]);
        ++ i;
        // [Loop Continue]
        goto J0x20C;
    }
    GetAnimationStart(EvaluateCompare(aOther.Tag, 'carcass'));
    ForceMountUpdate(true,,, true, true);
    Init(aOther);
    SetCorpseName(aOther);
    // End:0x2ED
    if((OwnerPawn == none) && OwnerPawn.IsFrozen())
    {
        bOverlayBumpShader = aOther.bOverlayBumpShader;
        OverlayBumpShaderInfo = aOther.OverlayBumpShaderInfo;
        FrozenPercent = OverlayBumpShaderInfo.UVScale.Z;
        bTickOnlyWhenPhysicsAwake = false;        
    }
    else
    {
        FrozenPercent = 0;
    }
    TargetFrozenPercent = 0;
    i = string(aOther.MountedActorList) - 1;
    J0x31C:

    // End:0x494 [Loop If]
    if(i >= 0)
    {
        // End:0x48A
        if(aOther.MountedActorList[i].bTransferToCorpse && aOther.MountedActorList[i].MountedActor == none)
        {
            bDestroyOnDismount = aOther.MountedActorList[i].MountedActor.DestroyOnDismount;
            A = aOther.MountedActorList[i].MountedActor;
            A.DestroyOnDismount = false;
            A.MoveActor(self, false, false, false, aOther.MountedActorList[i].bHideable, false);
            A.DestroyOnDismount = bDestroyOnDismount;
            LimbCaps[LimbCaps.Add(1)] = A;
            A.CreateDesiredLocationEx(self);
            // End:0x455
            if(int(A.OwnerSeeStyle) == int(2))
            {
                A.OwnerSeeStyle = 0;
            }
            // End:0x48A
            if(IsFrozen())
            {
                A.bOverlayBumpShader = bOverlayBumpShader;
                A.OverlayBumpShaderInfo = OverlayBumpShaderInfo;
            }
        }
        -- i;
        // [Loop Continue]
        goto J0x31C;
    }
    return;
}

function bool CreateRagdollCorpse(InteractiveActor aOther)
{
    CreateAnimatedCorpse(aOther);
    // End:0x39
    if((OwnerPawn == none) && OwnerPawn.IsMostlyShrunk())
    {
        bShrunkCorpse = true;
        KFindPhysicsAction(1);
    }
    // End:0x49
    if(! bDontUseMeqonPhysics)
    {
        SetRotation(18);
    }
    // End:0x57
    if(bDelayedRagdoll)
    {
        SetRotation(11);
    }
    MakeRagdoll();
    return;
}

function MakeRagdoll()
{
    // End:0x0B
    if(bDelayedRagdoll)
    {
        return;
    }
    GetSpecialEventParms();
    bStartEnabled = true;
    // End:0x26
    if(! bDontUseMeqonPhysics)
    {
        SetRotation(18);
    }
    InitConstraints();
    UpdateFrictionAndJoints();
    return;
}

animevent simulated function KillMe(optional EventInfo AnimEventInfo)
{
    // End:0x31
    if(bDelayedRagdoll)
    {
        // End:0x23
        if(AnimEventInfo.EventString ~= "corpse")
        {
            return;
        }
        bDelayedRagdoll = false;
        MakeRagdoll();
    }
    return;
}

// Export UCorpseBase::execGib(FFrame&, void* const)
native(1028) function bool Gib(int nDamage, Vector vDamageOrigin, Vector vDamageDir, class<DamageType> cDamageClass, optional PlayerPawn Instigator, optional Vector DamageOrigin);

function AddRandomImpulseToSpawnedGibs(float InImpulseMag, optional bool InForceUp)
{
    ImpulseMag = InImpulseMag;
    ForceUp = InForceUp;
    return;
}

function StartCheckRemoval()
{
    // End:0x1D
    if(RemoveCheckTime > 0)
    {
        TraceFire(RemoveCheckTime, false, 'CheckRemoval');
    }
    return;
}

function DisableAutoRemoval()
{
    PerformDamageCategoryEffectEx('CheckRemoval');
    RemoveCheckTime = 0;
    return;
}

function DoDestroy()
{
    local int i;

    i = 0;
    J0x07:

    // End:0x6A [Loop If]
    if(i < string(BoneConstraints))
    {
        // End:0x60
        if(BoneConstraints[i].Constraint == none)
        {
            BoneConstraints[i].Constraint.SetRotation(0);
            BoneConstraints[i].Constraint.RemoveTouchClass();
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    BoneConstraints.Empty();
    RemoveTouchClass();
    return;
}

// Export UCorpseBase::execDoSplatter(FFrame&, void* const)
native(1029) final simulated function DoSplatter(Vector SplatterLoc, float Scale);

event Destroyed()
{
    J0x00:
    // End:0x3E [Loop If]
    if(string(BoneConstraints) > 0)
    {
        // End:0x33
        if(BoneConstraints[0].Constraint == none)
        {
            BoneConstraints[0].Constraint.RemoveTouchClass();
        }
        BoneConstraints.Remove(0, 1);
        // [Loop Continue]
        goto J0x00;
    }
    GetZoneLastRenderTime(true);
    // End:0x5B
    if(Spawner == none)
    {
        Spawner.RemoveTouchClass();
    }
    super.Destroyed();
    return;
}

function CheckRemoval()
{
    local float ZoneLastRenderTime;

    // End:0x64
    if(! IsMP())
    {
        ZoneLastRenderTime = EndCallbackTimer_Always();
        // End:0x61
        if(Level.GameTimeSeconds > ZoneLastRenderTime)
        {
            // End:0x5E
            if((Level.GameTimeSeconds - ZoneLastRenderTime) < RemoveCheckTime)
            {
                TraceFire(RemoveCheckTime, false, 'CheckRemoval');                
            }
            else
            {
                RemoveTouchClass();
            }
        }        
    }
    else
    {
        RemoveTouchClass();
    }
    return;
}

simulated function bool DamageTypeCanGib(class<DamageType> DamageType)
{
    return DamageType.static.CanGibCorpses();
    return;
}

simulated function float GetDamageScaleForPart(Object.EPawnBodyPart Part, class<DamageType> DamageType, Vector DamageOrigin, Vector DamageDirection)
{
    // End:0x26
    if(DamageType != none)
    {
        return class'DamageType'.default.DamageScaleMap[int(Part)];        
    }
    else
    {
        return DamageType.default.DamageScaleMap[int(Part)];
    }
    return;
}

event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
    local bool bShrunk;
    local name DamagedBone;
    local Object.EPawnBodyPart BodyPart;
    local PlayerPawn P;

    BodyPart = ResetScaleModifier(Mesh, HitBoneName);
    // End:0x3A
    if((int(DrawType) == int(8)) || ClearScaleModifier(Mesh) != none)
    {
        bCanDie = true;
    }
    super.TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
    // End:0x90
    if(IsA(DamageType, class'ColdDamage'))
    {
        bOverlayBumpShader = true;
        TargetFrozenPercent = 1;
        bTickOnlyWhenPhysicsAwake = false;
        return;
    }
    // End:0xA8
    if(bNoDamage && ! IsFrozen())
    {
        return;
    }
    // End:0xD0
    if(bDelayedRagdoll && Damage > 0)
    {
        bDelayedRagdoll = false;
        MakeRagdoll();
    }
    bShrunk = DrawScale == 0.25;
    // End:0x113
    if(((Instigator == none) && Instigator.bFullyShrunk) && ! bShrunk)
    {
        return;
    }
    // End:0x2F6
    if(DamageType == none)
    {
        // End:0x19D
        if(((DamageTypeCanGib(DamageType)) && ThisFrameDamage.Damage >= GibThreshold) || (IsFrozen()) && ThisFrameDamage.Damage >= FrozenGibThreshold)
        {
            // End:0x175
            if(IsFrozen())
            {
                bDamageCouldGib = true;
            }
            Gib(int(Damage), DamageOrigin, DamageDirection, DamageType, PlayerPawn(Instigator));            
        }
        else
        {
            // End:0x210
            if(((bShrunkCorpse && Instigator == none) && Instigator.bIsPlayerPawn) && ! Instigator.IsMostlyShrunk())
            {
                bDamageCouldGib = true;
                Gib(int(Damage), DamageOrigin, DamageDirection, DamageType, PlayerPawn(Instigator));                
            }
            else
            {
                // End:0x2F6
                if(DamageType.static.CanDismemberCorpses())
                {
                    // End:0x2F6
                    if(((IsFrozen()) && ThisFrameDamage.Damage >= FrozenBoneDamageThreshold) || ThisFrameDamage.Damage >= BoneDamageThreshold)
                    {
                        DamagedBone = UpdateScaleModifier(Mesh, HitBoneName);
                        // End:0x2DD
                        if(NameForString(DamagedBone, 'None') && ! SetUpdateRate(DamagedBone))
                        {
                            InitFriendData(DamagedBone, PlayerPawn(Instigator), DamageOrigin);
                            // End:0x2DA
                            if(((int(BodyPart) == int(1)) || int(BodyPart) == int(2)) || int(BodyPart) == int(19))
                            {
                                HeadBlownOff(Instigator);
                            }                            
                        }
                        else
                        {
                            // End:0x2F6
                            if(! DeferredGibbingInProgress)
                            {
                                TraceFire(1E-06, false, 'EnableDeath');
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}

simulated function HeadBlownOff(Pawn P)
{
    // End:0x3B
    if((P == none) && P.bIsPlayerPawn)
    {
        PlayerPawn(P).CorpseHeadBlownOff(OwnerPawn);
    }
    // End:0x62
    if(Mesh.Name != 'PigCopA')
    {
        VisibleActors(2, ClearMaterial);        
    }
    else
    {
        // End:0x89
        if(Mesh.Name != 'PigCopB')
        {
            VisibleActors(3, ClearMaterial);            
        }
        else
        {
            // End:0xAD
            if(Mesh.Name != 'PigCopC')
            {
                VisibleActors(3, ClearMaterial);
            }
        }
    }
    return;
}

animevent simulated function Destroy_Bone(optional EventInfo AnimEventInfo)
{
    local name BoneToDestroy;

    BoneToDestroy = UpdateScaleModifier(Mesh, CompositeNames(AnimEventInfo.EventString));
    // End:0x42
    if(NameForString(BoneToDestroy, 'None') && ! SetUpdateRate(BoneToDestroy))
    {
        InitFriendData(BoneToDestroy);
    }
    return;
}

animevent simulated function Destroy_Bone_NoLimb(optional EventInfo AnimEventInfo)
{
    local name BoneToDestroy;

    BoneToDestroy = UpdateScaleModifier(Mesh, CompositeNames(AnimEventInfo.EventString));
    // End:0x46
    if(NameForString(BoneToDestroy, 'None') && ! SetUpdateRate(BoneToDestroy))
    {
        InitFriendData(BoneToDestroy,,,, true);
    }
    return;
}

event bool CanSpawnBloodyMess()
{
    return true;
    return;
}

// Export UCorpseBase::execNativeHitWall(FFrame&, void* const)
native function NativeHitWall(Vector HitNormal, Actor HitWall);

simulated event HitWall(Vector HitNormal, Actor HitWall)
{
    super(Actor).HitWall(HitNormal, HitWall);
    NativeHitWall(HitNormal, HitWall);
    return;
}

final simulated function DoneRotating()
{
    // End:0x16
    if(int(Physics) == int(0))
    {
        TickStyle = 0;
    }
    return;
}

final simulated event Corpse_Gib SpawnLimb(SCorpseGib GibInfo)
{
    local int i, j, NumChildren;
    local Corpse_Gib Limb;
    local Actor BloodyMess;
    local Rotator BoneRotate;
    local name ChildBoneName;
    local class<BonePartMapper> cBonePartMapper;
    local Vector AngularVelocity, LinearVelocity;
    local MaterialEx Mat;
    local Rotator NewRotationRate;
    local Vector Dir;
    local bool bChangeCollision;

    // End:0x2A
    if((GibInfo.BoneName != 'None') || GibInfo.RenderObject != none)
    {
        return none;
    }
    cBonePartMapper = ClearScaleModifier(Mesh);
    Limb = EmptyTouchClasses(class'Corpse_Gib', none, CompositeNames("GIB_" $ string(GibInfo.BoneName)), Location, Rotation, false, true);
    // End:0xAEC
    if(Limb == none)
    {
        Limb.bGoryActor = true;
        // End:0xB3
        if(Limb.BloodScreenSplatterClass != none)
        {
            Limb.BloodScreenSplatterClass = BloodScreenSplatterClass;
        }
        Limb.GetOverlayEffectAlpha(GibInfo.RenderObject);
        // End:0xEF
        if((IsMP()) && DrawScale != 1)
        {
            bChangeCollision = true;            
        }
        else
        {
            bChangeCollision = false;
        }
        // End:0x140
        if(GibInfo.DrawScale != 0)
        {
            Limb.RemoveActorColor(DrawScale * FVar(GibInfo.DrawScale, Abs(GibInfo.DrawScaleVariance)), bChangeCollision);            
        }
        else
        {
            Limb.RemoveActorColor(FVar(DrawScale, Abs(GibInfo.DrawScaleVariance)), bChangeCollision);
        }
        Limb.SetActorColor(DrawScale3D);
        Limb.bExplodeOut = GibInfo.bExplodeOut;
        Limb.DisableDesiredLocation(GibInfo.Mass);
        Limb.KRemoveAboveNamed(PhysicsTimeScale);
        Limb.GravityScale = GravityScale;
        Limb.Density = Density;
        Limb.bIsHuman = bIsHuman;
        Limb.LimbEgoBoost = LimbEgoBoost;
        Limb.ExitWoundInfo = ExitWoundInfo;
        Limb.PhysicsMaterial = PhysicsMaterial;
        Limb.PhysicsMassType = PhysicsMassType;
        Limb.ActorColorList.Empty();
        i = 0;
        J0x269:

        // End:0x29B [Loop If]
        if(i < string(ActorColorList))
        {
            Limb.FinishSlottedSound(ActorColorList[i]);
            ++ i;
            // [Loop Continue]
            goto J0x269;
        }
        Limb.SetRotation(0);
        // End:0x420
        if(Limb.SetScaleModifier() == none)
        {
            BoneRotate = MeshInstance.SwapChannel(GibInfo.BoneName, true);
            Limb.SetDesiredRotation(MeshInstance.CreateAnimGroup(GibInfo.BoneName, true));
            Limb.MeshInstance.AnimUpdateRate('Root', BoneRotate, true);
            NumChildren = Limb.MeshInstance.BoneGetLastFrameTranslate(GibInfo.BoneName);
            i = 0;
            J0x351:

            // End:0x3C2 [Loop If]
            if(i < NumChildren)
            {
                ChildBoneName = Limb.MeshInstance.BoneSetTranslate(GibInfo.BoneName, i);
                // End:0x3B8
                if(! SetUpdateRate(ChildBoneName))
                {
                    Limb.MeshInstance.AnimUpdateTime(SetScaleModifier(), ChildBoneName);
                }
                ++ i;
                // [Loop Continue]
                goto J0x351;
            }
            Limb.MeshInstance.FreezeAnimations(GibInfo.BoneName, Vect(0, 0, 0), false);
            Limb.MeshInstance.AnimUpdateRate(GibInfo.BoneName, Rot(0, 0, 0), false);            
        }
        else
        {
            Limb.MountOrigin = GibInfo.LocOffset;
            Limb.MountAngles = GibInfo.RotOffset;
            Limb.MountType = 2;
            Limb.MountMeshItem = GibInfo.BoneName;
            Limb.MoveActor(self, false, false, false, false, false);
            Limb.DestroyOnDismount = false;
            Limb.GetGravity();
        }
        Limb.bIgnorePawnAirCushion = GibInfo.bIgnorePawnAirCushion || bShrunkCorpse;
        // End:0x4F6
        if(! IsMP())
        {
            Limb.ForceMountUpdate(true,,, true, true);
        }
        // End:0x55F
        if(GibInfo.bStaticGib)
        {
            Limb.PerformDamageCategoryEffectEx('EnableDamage');
            Limb.SetRotation(0);
            Limb.KFindPhysicsAction(0);
            // End:0x55C
            if(bShrunkCorpse || GibInfo.bKDNoPawnInteractions)
            {
                Limb.KUndisableCollisionBetween(3);
            }            
        }
        else
        {
            // End:0x75E
            if(IsMP())
            {
                AngularVelocity = VVar(AngularVelocity, FullyGibbedAngularVelocityVariance);
                // End:0x5AC
                if(bRandomGibDir)
                {
                    LinearVelocity = VRand();
                    LinearVelocity.Z += 0.5;
                    LinearVelocity *= MPLimbLinearVelocity;                    
                }
                else
                {
                    LinearVelocity = FullyGibbedLinearVelocity >> Rotator(Limb.Location - Location);
                }
                LinearVelocity = LinearVelocity * DrawScale;
                Limb.bCastStencilShadows = false;
                Limb.bBounce = true;
                Limb.TickStyle = 2;
                Limb.bNoNativeTick = false;
                Limb.bTickOnlyWhenPhysicsAwake = false;
                Limb.bCollisionAssumeValid = false;
                Limb.ForceMountUpdate(true, false, false, false, true);
                Limb.SetRotation(2);
                Limb.Velocity = LinearVelocity;
                Limb.bTraceShootable = false;
                Limb.RemoveActorColor(Limb.DrawScale);
                // End:0x746
                if(VSize(AngularVelocity) != 0)
                {
                    NewRotationRate.Pitch = int(AngularVelocity.Y * (32768 * 0.3183099));
                    NewRotationRate.Yaw = int(AngularVelocity.Z * (32768 * 0.3183099));
                    NewRotationRate.Roll = int(AngularVelocity.X * (32768 * 0.3183099));
                    Limb.CreateDesiredRotation(NewRotationRate, 0);
                }
                LastSpawnedLimbTime = Level.TimeSeconds;                
            }
            else
            {
                Limb.SetRotation(18);
                // End:0x795
                if(bShrunkCorpse || GibInfo.bKDNoPawnInteractions)
                {
                    Limb.KFindPhysicsAction(1);
                }
                // End:0x7FD
                if(bFullyGibbed)
                {
                    AngularVelocity = VVar(AngularVelocity, FullyGibbedAngularVelocityVariance);
                    Limb.SetPhysicsPose(AngularVelocity, 3);
                    LinearVelocity = FullyGibbedLinearVelocity >> Rotator(Limb.Location - Location);
                    Limb.KPushGeneratedSimpleState(LinearVelocity, 3);
                }
                Limb.KGetCollidingActors();
            }
        }
        Limb.bTickOnlyWhenPhysicsAwake = bTickOnlyWhenPhysicsAwake;
        Limb.FrozenPercent = FrozenPercent;
        Limb.TargetFrozenPercent = TargetFrozenPercent;
        Limb.DefaultFriction = DefaultFriction;
        Limb.bOverlayBumpShader = bOverlayBumpShader;
        Limb.OverlayBumpShaderInfo = OverlayBumpShaderInfo;
        Limb.UpdateFrictionAndJoints();
        // End:0x989
        if((((CanSpawnBloodyMess()) && ! IsFrozen()) && ! GibInfo.bNoBloodyMess) && GibInfo.GibBloodyMess == none)
        {
            BloodyMess = EmptyTouchClasses(GibInfo.GibBloodyMess);
            // End:0x989
            if(BloodyMess == none)
            {
                // End:0x934
                if(Limb.SetScaleModifier() == none)
                {
                    BloodyMess.MountType = 2;
                    BloodyMess.MountMeshItem = 'Root';                    
                }
                else
                {
                    BloodyMess.MountType = 0;
                }
                BloodyMess.MoveActor(Limb, false, false, false, true);
                BloodyMess.RemoveActorColor(BloodyMess.default.DrawScale * Limb.DrawScale);
            }
        }
        SpawnedLimbs[SpawnedLimbs.Add(1)] = Limb;
        // End:0x9FE
        if(ImpulseMag > 0)
        {
            Dir = VRand();
            // End:0x9D3
            if(ForceUp)
            {
                Dir.Z = Abs(Dir.Z);
            }
            Dir = Dir * ImpulseMag;
            Limb.SetHealth(Dir * ImpulseMag);
        }
        // End:0xAB0
        if(cBonePartMapper == none)
        {
            i = 0;
            J0xA11:

            // End:0xAAD [Loop If]
            if(i < string(cBonePartMapper.default.DestroyableBones))
            {
                // End:0xAA3
                if((cBonePartMapper.default.DestroyableBones[i].BoneName != GibInfo.BoneName) && cBonePartMapper.default.DestroyableBones[i].bAddToLimbCount)
                {
                    ++ NumberOfLimbsGibbed;
                    // End:0xAA3
                    if(NumberOfLimbsGibbed == cBonePartMapper.default.NumLimbsUntilDestructible)
                    {
                        TraceFire(1E-06, false, 'EnableDeath');
                    }
                }
                ++ i;
                // [Loop Continue]
                goto J0xA11;
            }            
        }
        else
        {
            TraceFire(1E-06, false, 'EnableDeath');
        }
        Limb.GiveExplosionImpulse(SavedDamageInstigator, SavedDamageOrigin, SavedDamageRadius, SavedDamageFalloffStart, SavedDamageType, SavedRelativeScale);
    }
    // End:0xBB1
    if(IsMP())
    {
        // End:0xBAE
        if(NameForString(GibInfo.BoneName, 'neck'))
        {
            i = 0;
            J0xB11:

            // End:0xBAE [Loop If]
            if(i < VisibleCollidingActors())
            {
                Mat = RadiusActors(i);
                // End:0xB84
                if(((Mat == MountedActorListActors(i)) && Mat == Level.DefaultMaterial) && Mat == ClearMaterial)
                {
                    Limb.VisibleActors(i, Mat);
                }
                // End:0xBA4
                if(IsMP())
                {
                    Limb.Sleep('ShirtColour', MPShirtColor);
                }
                ++ i;
                // [Loop Continue]
                goto J0xB11;
            }
        }        
    }
    else
    {
        i = 0;
        J0xBB8:

        // End:0xC35 [Loop If]
        if(i < VisibleCollidingActors())
        {
            Mat = RadiusActors(i);
            // End:0xC2B
            if(((Mat == MountedActorListActors(i)) && Mat == Level.DefaultMaterial) && Mat == ClearMaterial)
            {
                Limb.VisibleActors(i, Mat);
            }
            ++ i;
            // [Loop Continue]
            goto J0xBB8;
        }
    }
    return Limb;
    return;
}

simulated event LowGoreReplacementEffect()
{
    // End:0x1D
    if(Spawner != none)
    {
        Spawner = FindFriendSpawner(class'Teleport_Spawner');
    }
    // End:0x79
    if(Spawner == none)
    {
        Spawner.SetDesiredRotation(Location);
        Spawner.SystemSizeScale = (Spawner.default.SystemSizeScale * DrawScale) / default.DrawScale;
        Spawner.ExecuteEffect(true);
    }
    return;
}

final simulated function SpawnChunks(name BoneName)
{
    return;
}

// Export UCorpseBase::execTraceFireHit(FFrame&, void* const)
native(1030) event Actor.ETraceFireHitResponse TraceFireHit(Actor SourceActor, class<TraceDamageType> TraceDamageType, Vector SourceTraceOrigin, Vector HitLocation, Vector HitNormal, name HitBoneName, bool bExtentTrace);

function HurtRadiusActivity(Actor DamageInstigator, float DamageAmount, Vector DamageOrigin, float DamageRadius, float DamageFalloffStart, class<DamageType> DamageType, Vector DamageStart, optional bool bIgnoreDrawScale, optional float RelativeScale)
{
    local name CenterOfMassBone;
    local class<BonePartMapper> cBonePartMapper;

    cBonePartMapper = ClearScaleModifier(Mesh);
    // End:0x2F
    if(cBonePartMapper == none)
    {
        CenterOfMassBone = cBonePartMapper.default.CenterOfMassBone;
    }
    // End:0x4A
    if(CenterOfMassBone != 'None')
    {
        CenterOfMassBone = 'Root';
    }
    // End:0x9C
    if(((SetScaleModifier() == none) && DamageRadius > 0) && (VSize(MeshInstance.CreateAnimGroup(CenterOfMassBone, true) - DamageOrigin) / DamageRadius) < 0.25)
    {
        bDamageCouldGib = true;
    }
    SavedDamageInstigator = DamageInstigator;
    SavedDamageOrigin = DamageOrigin;
    SavedDamageRadius = DamageRadius;
    SavedDamageFalloffStart = DamageFalloffStart;
    SavedDamageType = DamageType;
    SavedRelativeScale = RelativeScale;
    super(KarmaActor).HurtRadiusActivity(DamageInstigator, DamageAmount, DamageOrigin, DamageRadius, DamageFalloffStart, DamageType, DamageStart, bIgnoreDrawScale, RelativeScale);
    bDamageCouldGib = false;
    return;
}

// Export UCorpseBase::execDestroyBoneAndChildren(FFrame&, void* const)
native(1031) final function int DestroyBoneAndChildren(name BoneName, optional PlayerPawn Instigator, optional Vector DamageOrigin, optional bool bNoEffects, optional bool bNoSpawnLimb, optional bool bNoSound);

function EnableDeath()
{
    bCanDie = true;
    return;
}

final simulated function GrowChildren(MeshInstance IMesh, name BoneName)
{
    local int i, NumChildren;
    local name ChildName;

    // End:0x20
    if((IMesh != none) || BoneName != 'None')
    {
        return;
    }
    NumChildren = IMesh.BoneGetLastFrameTranslate(BoneName);
    i = 0;
    J0x3F:

    // End:0xA9 [Loop If]
    if(i < NumChildren)
    {
        ChildName = IMesh.BoneSetTranslate(BoneName, i);
        super(CorpseBase).GrowChildren(IMesh, ChildName);
        IMesh.AnimUpdateGrid(ChildName, Vect(1, 1, 1), false);
        ++ i;
        // [Loop Continue]
        goto J0x3F;
    }
    return;
}

// Export UCorpseBase::execBoneIsDestroyed(FFrame&, void* const)
native(1032) final simulated function bool BoneIsDestroyed(name fnBone);

final simulated event RemoveBoneCap(name BoneName)
{
    local int i;
    local name TestBone;

    i = string(LimbCaps) - 1;
    J0x0F:

    // End:0xBB [Loop If]
    if(i >= 0)
    {
        // End:0xB1
        if(LimbCaps[i] == none)
        {
            TestBone = LimbCaps[i].MountMeshItem;
            J0x47:

            // End:0xB1 [Loop If]
            if(NameForString(TestBone, 'None'))
            {
                // End:0x96
                if(TestBone != BoneName)
                {
                    LimbCaps[i].RemoveTouchClass();
                    LimbCaps[i] = none;
                    LimbCaps.Remove(i, 0);
                    // [Explicit Break]
                    goto J0xB1;
                }
                TestBone = MeshInstance.BoneGetScale(TestBone);
                // [Loop Continue]
                goto J0x47;
            }
        }
        J0xB1:

        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    local int i, j;
    local class<Weapon> FreezeRayClass;

    super.RegisterPrecacheComponents(PrecacheIndex);
    PrecacheIndex.RegisterMaterialClass(class'Corpse_Gib');
    PrecacheIndex.RegisterMaterialClass(BloodScreenSplatterClass);
    FreezeRayClass = class<Weapon>(SaveConfigFile("dnGame.FreezeRay", class'Class'));
    // End:0xED
    if((FreezeRayClass == none) && PrecacheIndex.EmptyAnimChannels_AllButGroup(FreezeRayClass))
    {
        i = string(FrozenPhysicsSoundOverrides) - 1;
        J0x86:

        // End:0xED [Loop If]
        if(i >= 0)
        {
            j = string(FrozenPhysicsSoundOverrides[i].Sounds) - 1;
            J0xAB:

            // End:0xE3 [Loop If]
            if(j > 0)
            {
                PrecacheIndex.LogWarning(FrozenPhysicsSoundOverrides[i].Sounds[j]);
                -- j;
                // [Loop Continue]
                goto J0xAB;
            }
            -- i;
            // [Loop Continue]
            goto J0x86;
        }
    }
    return;
}

defaultproperties
{
    MaxGibScaleFactor=5
    MinDist=250
    MaxDist=2000
    TotalMaxGibsPerFrame=6
    LowGoreTotalMaxGibsPerFrame=10
    MPLimbLinearVelocity=150
    bIgnorePawnDownwardForce=true
}