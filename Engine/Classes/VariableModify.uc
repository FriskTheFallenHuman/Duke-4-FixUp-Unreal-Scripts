/*******************************************************************************
 * VariableModify generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class VariableModify extends Triggers
    collapsecategories
    notplaceable
    hidecategories(Filter,Interactivity,Karma,Lighting,Networking,Sound);

enum EVariableModifyType
{
    VM_Set,
    VM_Add,
    VM_Subtract,
    VM_Multiply,
    VM_Divide,
    VM_Remainder,
    VM_AND,
    VM_OR,
    VM_NOT,
    VM_BAND,
    VM_BOR,
    VM_BXOR,
    VM_BNOT,
    VM_ShiftLeft,
    VM_ShiftRight,
    VM_Factorial,
    VM_Random,
    VM_Keypad
};

enum EStorageModifyType
{
    SM_Set,
    SM_Add,
    SM_Multiply,
    SM_Random
};

var(ModVariable) noexport bool bModifyVariable "Set to true if you want to be modifying the Variable property of the Variable Actor.";
var(ModVariable) noexport name ArgumentVariable "If set then set the value of argument from this.";
var(ModVariable) noexport int Argument "Argument to the modification type.";
var(ModVariable) noexport VariableModify.EVariableModifyType VariableModifyType "Modification type to apply to the variable.";
var(ModStorage) noexport bool bModifyStorage "Set to true if you want to be modifying the Storage property of the Variable Actor.";
var(ModStorage) noexport float StorageArgument "Argument for modifying the StorageValue of the Variable.";
var(ModStorage) noexport VariableModify.EStorageModifyType StorageModifyType "Modification type to apply tot he storage variable.";

event Trigger(Actor Other, Pawn EventInstigator)
{
    local Variable V;

    super(Actor).Trigger(Other, EventInstigator);
    // End:0x3C
    foreach RotateVectorAroundAxis(class'Variable', V, Event)
    {
        ModifyVariable(V);
        ModifyStorage(V);        
    }    
    return;
}

final function ModifyVariable(Variable V)
{
    local int i, j, Value, Result;

    // End:0x0D
    if(! bModifyVariable)
    {
        return;
    }
    Argument = GetVariableValue(ArgumentVariable, Argument);
    Value = V.Value;
    switch(VariableModifyType)
    {
        // End:0x53
        case 0:
            Result = Argument;
            // End:0x236
            break;
        // End:0x6D
        case 1:
            Result = Value + Argument;
            // End:0x236
            break;
        // End:0x87
        case 2:
            Result = Value - Argument;
            // End:0x236
            break;
        // End:0xA1
        case 3:
            Result = Value * Argument;
            // End:0x236
            break;
        // End:0xBB
        case 4:
            Result = Value / Argument;
            // End:0x236
            break;
        // End:0xD5
        case 5:
            Result = Value % Argument;
            // End:0x236
            break;
        // End:0xF5
        case 6:
            Result = int(bool(Value) && bool(Argument));
            // End:0x236
            break;
        // End:0x115
        case 7:
            Result = int(bool(Value) || bool(Argument));
            // End:0x236
            break;
        // End:0x12C
        case 8:
            Result = int(! bool(Value));
            // End:0x236
            break;
        // End:0x146
        case 9:
            Result = Value & Argument;
            // End:0x236
            break;
        // End:0x160
        case 10:
            Result = Value | Argument;
            // End:0x236
            break;
        // End:0x17A
        case 11:
            Result = Value ^ Argument;
            // End:0x236
            break;
        // End:0x18F
        case 12:
            Result = ~ Value;
            // End:0x236
            break;
        // End:0x1A9
        case 13:
            Result = Value << Argument;
            // End:0x236
            break;
        // End:0x1C3
        case 14:
            Result = Value >> Argument;
            // End:0x236
            break;
        // End:0x200
        case 15:
            Result = 1;
            i = 2;
            J0x1D7:

            // End:0x1FD [Loop If]
            if(i <= Value)
            {
                Result *= float(i);
                ++ i;
                // [Loop Continue]
                goto J0x1D7;
            }
            // End:0x236
            break;
        // End:0x215
        case 16:
            Result = Rand(Argument);
            // End:0x236
            break;
        // End:0x233
        case 17:
            Result = (Value * 10) + Argument;
            // End:0x236
            break;
        // End:0xFFFF
        default:
            break;
    }
    V.SetValue(Result);
    return;
}

final function ModifyStorage(Variable V)
{
    local float Value, Result;

    // End:0x0D
    if(! bModifyStorage)
    {
        return;
    }
    Value = V.StorageValue;
    switch(StorageModifyType)
    {
        // End:0x3D
        case 0:
            Result = StorageArgument;
            // End:0x8B
            break;
        // End:0x57
        case 1:
            Result = Value + StorageArgument;
            // End:0x8B
            break;
        // End:0x71
        case 2:
            Result = Value * StorageArgument;
            // End:0x8B
            break;
        // End:0x88
        case 3:
            Result = FRand() * StorageArgument;
            // End:0x8B
            break;
        // End:0xFFFF
        default:
            break;
    }
    V.SetStorageValue(Result);
    return;
}

defaultproperties
{
    bModifyVariable=true
    Texture=Texture'S_VariableModify'
}