/*******************************************************************************
 * TriggerSplashGeowater generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class TriggerSplashGeowater extends Triggers
    collapsecategories
    notplaceable
    hidecategories(Filter,Interactivity,Karma,Lighting,Networking,Sound);

var() noexport name TagEnable "Call this to enable the effect. You can also simply trigger the actor toggle whether it's currently splashing.";
var() noexport name TagDisable "Call this to disable the effect.";
var() noexport Vector SplashLocationVariance "Randomly select within this many units around the actor to perform the splash.";
var() noexport float SplashRadius "Radius of the water splash influence.";
var() noexport float SplashRadiusVariance "Variance of the splash radius.";
var() noexport float SplashStrength "Strength of the water splash.";
var() noexport float SplashStrengthVariance "Variance of the splash strength.";
var() noexport float LoopDelay "Amount of time to delay before splashing again. Delay can not be less than or equal to 0 in order to loop.";
var() noexport float LoopDelayVariance "Amount to vary the delay by. Can't be more than  2 * Delay.";
var() noexport int LoopCountMax "Number of times to loop. If 0, never loop. If -1, loop forever.";
var() noexport int LoopCountMaxVariance "Variance of the number of times to loop. Can't be more than 2 * LoopCountMax";
var() noexport bool bOnlyFindWaterOnSpawn "If true, then it only checks for the water when it spawns in and never again.";
var int ActualLoopCountMax;
var int LoopCount;
var bool bCurrentlyLooping;
var GeoWater Water;

function bool VerifySelf()
{
    // End:0x23
    if(LoopDelay < float(0))
    {
        LoopDelay = float(Max(int(Abs(LoopDelay)), int(0.001)));
    }
    // End:0x53
    if(LoopDelay > float(0))
    {
        // End:0x53
        if((LoopDelayVariance / float(2)) > LoopDelay)
        {
            LoopDelayVariance = LoopDelay * float(2);
        }
    }
    // End:0x80
    if(LoopCountMax > 0)
    {
        // End:0x80
        if((LoopCountMaxVariance / 2) > LoopCountMax)
        {
            LoopCountMaxVariance = LoopCountMax * 2;
        }
    }
    return super(Actor).VerifySelf();
    return;
}

function PostVerifySelf()
{
    super(Actor).PostVerifySelf();
    GetPointRegion('EnableSplashing', TagEnable);
    GetPointRegion('DisableSplashing', TagDisable);
    // End:0x99
    if(bOnlyFindWaterOnSpawn)
    {
        // End:0x70
        if((PhysicsVolume == none) && PhysicsVolume.GeoWaterActor == none)
        {
            Water = PhysicsVolume.CheckForGeoWater(Location, SplashRadius);            
        }
        else
        {
            Water = GeoWater(TraceEx(class'GeoWater', Location, Vect(SplashRadius, SplashRadius, SplashRadius)));
        }
    }
    return;
}

final function PerformSplash()
{
    local Vector ActualSplashLocation;
    local float ActualSplashStrength, ActualSplashRadius;

    ActualSplashLocation = Vect(FVar(Location.X, SplashLocationVariance.X), FVar(Location.Y, SplashLocationVariance.Y), FVar(Location.Z, SplashLocationVariance.Z));
    ActualSplashRadius = FVar(SplashRadius, SplashRadiusVariance);
    ActualSplashStrength = FVar(SplashStrength, SplashStrengthVariance);
    // End:0xE9
    if(! bOnlyFindWaterOnSpawn)
    {
        // End:0xC0
        if((PhysicsVolume == none) && PhysicsVolume.GeoWaterActor == none)
        {
            Water = PhysicsVolume.CheckForGeoWater(ActualSplashLocation, ActualSplashRadius);            
        }
        else
        {
            Water = GeoWater(TraceEx(class'GeoWater', ActualSplashLocation, Vect(ActualSplashRadius, ActualSplashRadius, ActualSplashRadius)));
        }
    }
    // End:0x111
    if(Water == none)
    {
        Water.ParseURL(ActualSplashLocation, ActualSplashStrength, ActualSplashRadius);
    }
    // End:0x181
    if((ActualLoopCountMax != 0) && LoopDelay != float(0))
    {
        // End:0x14D
        if(ActualLoopCountMax < 0)
        {
            Destroy(FVar(LoopDelay, LoopDelayVariance), false, 'PerformSplash');            
        }
        else
        {
            // End:0x17B
            if(LoopCount < ActualLoopCountMax)
            {
                ++ LoopCount;
                Destroy(FVar(LoopDelay, LoopDelayVariance), false, 'PerformSplash');                
            }
            else
            {
                TriggerFunc_DisableSplashing();
            }
        }
    }
    return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
    super(Actor).Trigger(Other, EventInstigator);
    // End:0x22
    if(bCurrentlyLooping)
    {
        TriggerFunc_DisableSplashing();        
    }
    else
    {
        TriggerFunc_EnableSplashing();
    }
    return;
}

final function TriggerFunc_EnableSplashing()
{
    TriggerFunc_DisableSplashing();
    LoopCount = 0;
    // End:0x2D
    if(LoopCountMax > 0)
    {
        ActualLoopCountMax = IVar(LoopCountMax, LoopCountMaxVariance);        
    }
    else
    {
        ActualLoopCountMax = -1;
    }
    TickStyle = 2;
    bCurrentlyLooping = true;
    PerformSplash();
    return;
}

final function TriggerFunc_DisableSplashing()
{
    Spawn('PerformSplash');
    bCurrentlyLooping = false;
    TickStyle = 0;
    return;
}

defaultproperties
{
    bOnlyFindWaterOnSpawn=true
}