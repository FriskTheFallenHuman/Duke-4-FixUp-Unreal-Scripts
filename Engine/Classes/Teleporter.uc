/*******************************************************************************
 * Teleporter generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Teleporter extends NavigationPoint
    native
    collapsecategories
    notplaceable;

var() string URL;
var() bool bChangesVelocity;
var() bool bChangesYaw;
var() bool bReversesX;
var() bool bReversesY;
var() bool bReversesZ;
var() bool bEnabled;
var() bool MusicChange;
var() bool SmoothTransition;
var() noexport bool bTeleportRadiusActors "If true, Teleporter will setup all Actors for level transition if they are within TeleportRadius and have bNeverTravel = false.";
var() string MusicFilename;
var() float TeleportRadius;
var() Vector TargetVelocity;
var(VehicleTransition) noexport bool bVehicleTransition "If true, this is a special transition that involves a vehicle.";
var(VehicleTransition) noexport deprecated name SourceVehicleTag "Tag of the vehicle in this map.";
var(VehicleTransition) noexport deprecated name DestinationVehicleTag "Tag of the vehicle in the destination map.";
var Actor TriggerActor;
var Actor TriggerActor2;
var float LastFired;

replication
{
    // Pos:0x000
    reliable if(int(Role) == int(ROLE_Authority))
        URL, bEnabled;

    // Pos:0x00B
    reliable if(bNetInitial && int(Role) == int(ROLE_Authority))
        TargetVelocity, bChangesVelocity, 
        bChangesYaw, bReversesX, 
        bReversesY, bReversesZ;
}

event PostBeginPlay()
{
    // End:0x15
    if(Len(URL) == 0)
    {
        SetTeleporterEnabled(false);
    }
    SetTeleporterEnabled(bEnabled);
    super(Actor).PostBeginPlay();
    return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
    super(Actor).Trigger(Other, EventInstigator);
    SetTeleporterEnabled(! bEnabled);
    return;
}

final function SetTeleporterEnabled(bool bNewEnabled)
{
    bEnabled = bNewEnabled;
    ForceMountUpdate(bEnabled);
    return;
}

final simulated function StartTeleportAttempt(Actor Incoming)
{
    GetPropertyText('Touch');
    return;
}

final simulated function EndTeleportAttempt(Actor Incoming, bool bSuccess, Object.EPhysics RestorePhysics)
{
    Disable('Touch');
    // End:0x28
    if(int(RestorePhysics) != int(11))
    {
        Incoming.SetRotation(RestorePhysics);
    }
    return;
}

simulated function bool Accept(Actor Incoming, Teleporter Source)
{
    local Rotator NewRot, OldRot;
    local int OldYaw;
    local float Mag;
    local Vector OldDir;
    local Pawn PawnIncoming;
    local Object.EPhysics IncomingPhysics;

    PawnIncoming = Pawn(Incoming);
    IncomingPhysics = Incoming.Physics;
    StartTeleportAttempt(Incoming);
    NewRot = Incoming.Rotation;
    // End:0x63
    if(bChangesYaw)
    {
        NewRot.Yaw = Rotation.Yaw;
    }
    // End:0x195
    if(PawnIncoming == none)
    {
        // End:0xFC
        if(! PawnIncoming.MoveToward(Location + Incoming.TravelLocation))
        {
            Localize("SetLocation failed. Invalid Destination for PawnIncoming. Destination is" $ string(self));
            EndTeleportAttempt(Incoming, false, IncomingPhysics);
            return false;
        }
        // End:0x17D
        if((int(Role) == int(ROLE_Authority)) || (Level.GameTimeSeconds - LastFired) > 0.5)
        {
            // End:0x168
            if(! Source.SmoothTransition)
            {
                PawnIncoming.DisableDesiredRotation_Roll(NewRot);
                PawnIncoming.ViewRotation = NewRot;
            }
            LastFired = Level.GameTimeSeconds;
        }
        PawnIncoming.MoveTimer = -1;        
    }
    else
    {
        Incoming.SetRotation(0);
        // End:0x1CE
        if(! Incoming.SetDesiredRotation(Location))
        {
            EndTeleportAttempt(Incoming, false, IncomingPhysics);
            return false;
        }
        // End:0x1E9
        if(bChangesYaw)
        {
            Incoming.DisableDesiredRotation_Roll(NewRot);
        }
    }
    EndTeleportAttempt(Incoming, true, IncomingPhysics);
    // End:0x21B
    if(bChangesVelocity)
    {
        Incoming.Velocity = TargetVelocity;        
    }
    else
    {
        // End:0x2B6
        if(bChangesYaw)
        {
            // End:0x248
            if(int(Incoming.Physics) == int(1))
            {
                OldRot.Pitch = 0;
            }
            OldDir = Vector(OldRot);
            Mag = Incoming.Velocity Dot OldDir;
            Incoming.Velocity = (Incoming.Velocity - (Mag * OldDir)) + (Mag * Vector(Incoming.Rotation));
        }
        // End:0x2DA
        if(bReversesX)
        {
            Incoming.Velocity.X *= -1;
        }
        // End:0x2FE
        if(bReversesY)
        {
            Incoming.Velocity.Y *= -1;
        }
        // End:0x322
        if(bReversesZ)
        {
            Incoming.Velocity.Z *= -1;
        }
    }
    PlayTeleportEffect(Incoming, false);
    return true;
    return;
}

final function PlayTeleportEffect(Actor Incoming, bool bOut)
{
    // End:0x39
    if(Incoming.bIsPawn)
    {
        Level.Game.PlayTeleportEffect(Incoming, bOut, true);
    }
    return;
}

simulated event Touch(Actor Other)
{
    local array<Teleporter> LocalTeleporterList;
    local Teleporter Dest;
    local RenderActor TravelRA;
    local Pawn PawnOther;
    local PlayerPawn PlayerPawnOther;
    local bool bChunkTransition;
    local KarmaActor Vehicle;

    PawnOther = Pawn(Other);
    PlayerPawnOther = PlayerPawn(PawnOther);
    // End:0x42
    if(! bEnabled || Other.bJustTeleported)
    {
        return;
    }
    // End:0x4AF
    if(Other.bCanTeleport)
    {
        // End:0x311
        if((InStr(URL, "/") >= 0) || InStr(URL, "#") >= 0)
        {
            // End:0x30E
            if((int(Role) == int(ROLE_Authority)) && PlayerPawnOther == none)
            {
                // End:0xAA
                if(PlayerPawnOther.IsDead())
                {
                    return;
                }
                PlayerPawnOther.bLevelTransition = true;
                // End:0x2EA
                if(SmoothTransition || bChunkTransition)
                {
                    PlayerPawnOther.TravelLocation = PlayerPawnOther.Location - Location;
                    PlayerPawnOther.TravelRotation = PlayerPawnOther.Rotation;
                    PlayerPawnOther.TravelViewRotation = PlayerPawnOther.ViewRotation;
                    PlayerPawnOther.TeleportTravel = true;
                    // End:0x175
                    if(bChunkTransition && bVehicleTransition)
                    {
                        Vehicle = KarmaActor(FindActor(class'KarmaActor', SourceVehicleTag));
                    }
                    // End:0x234
                    if(Vehicle == none)
                    {
                        PlayerPawnOther.TravelVehicleTag = DestinationVehicleTag;
                        PlayerPawnOther.TravelLocation = Vehicle.Location - Location;
                        PlayerPawnOther.TravelRotation = Vehicle.Rotation;
                        // End:0x212
                        if(int(Vehicle.Physics) == int(18))
                        {
                            Vehicle.GetConstraintCount(PlayerPawnOther.TravelVehicleVelocity);                            
                        }
                        else
                        {
                            PlayerPawnOther.TravelVehicleVelocity = Vehicle.Velocity;
                        }                        
                    }
                    else
                    {
                        PlayerPawnOther.TravelVehicleTag = 'None';
                    }
                    // End:0x2E7
                    if(bTeleportRadiusActors)
                    {
                        // End:0x2E6
                        foreach GetURLMap(class'RenderActor', TravelRA, TeleportRadius)
                        {
                            // End:0x2E5
                            if(! TravelRA.bNeverTravel)
                            {
                                TravelRA.bWillTravel = true;
                                TravelRA.bTravel = true;
                                TravelRA.TravelRotation = TravelRA.Rotation;
                                TravelRA.TravelLocation = TravelRA.Location - Location;
                            }                            
                        }                        
                    }                    
                }
                Level.Game.SendPlayer(PlayerPawnOther, URL);
            }            
        }
        else
        {
            // End:0x35E
            foreach RotateVectorAroundAxis(class'Teleporter', Dest)
            {
                // End:0x35D
                if((Dest == self) && string(Dest.Tag) ~= URL)
                {
                    LocalTeleporterList[LocalTeleporterList.Add(1)] = Dest;
                }                
            }            
            // End:0x37F
            if(string(LocalTeleporterList) > 0)
            {
                Dest = LocalTeleporterList[Rand(string(LocalTeleporterList))];
            }
            // End:0x45B
            if(Dest == none)
            {
                // End:0x404
                if(PlayerPawnOther == none)
                {
                    // End:0x404
                    if(SmoothTransition)
                    {
                        PlayerPawnOther.TravelLocation = PlayerPawnOther.Location - Location;
                        PlayerPawnOther.TravelRotation = PlayerPawnOther.Rotation;
                        PlayerPawnOther.TravelViewRotation = PlayerPawnOther.ViewRotation;
                    }
                }
                PlayTeleportEffect(PawnOther, true);
                Dest.Accept(Other, self);
                // End:0x458
                if(Other.bIsPawn)
                {
                    GlobalTrigger(Event, Other.Instigator, Other);
                }                
            }
            else
            {
                // End:0x4AF
                if(IsPS3())
                {
                    // End:0x4AF
                    if(int(Role) == int(ROLE_Authority))
                    {
                        PawnOther.ClientMessage(("Teleport destination for " $ string(self)) $ " not found!");
                    }
                }
            }
        }
    }
    return;
}

defaultproperties
{
    bChangesYaw=true
    bEnabled=true
    MusicChange=true
    TeleportRadius=400
    bDirectional=true
    bCollideActors=true
    CollisionRadius=18
    CollisionHeight=40
    Texture=Texture'S_Teleport'
}